# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PyMovie.ui'
#
# Created by: PyQt5 UI code generator 5.14.0
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1893, 820)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        MainWindow.setFont(font)
        MainWindow.setToolTipDuration(-1)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_10 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_10.setObjectName("gridLayout_10")
        self.splitterThree = QtWidgets.QSplitter(self.centralwidget)
        self.splitterThree.setOrientation(QtCore.Qt.Vertical)
        self.splitterThree.setObjectName("splitterThree")
        self.splitterTwo = QtWidgets.QSplitter(self.splitterThree)
        self.splitterTwo.setOrientation(QtCore.Qt.Horizontal)
        self.splitterTwo.setObjectName("splitterTwo")
        self.layoutWidget = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_17.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        self.infoButton.setMinimumSize(QtCore.QSize(40, 0))
        self.infoButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.infoButton.setObjectName("infoButton")
        self.horizontalLayout_4.addWidget(self.infoButton)
        self.label_2 = QtWidgets.QLabel(self.layoutWidget)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_4.addWidget(self.label_2)
        self.fileInUseEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.fileInUseEdit.setObjectName("fileInUseEdit")
        self.horizontalLayout_4.addWidget(self.fileInUseEdit)
        self.verticalLayout_17.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setSpacing(0)
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.saveApertureState = QtWidgets.QPushButton(self.layoutWidget)
        self.saveApertureState.setObjectName("saveApertureState")
        self.horizontalLayout_6.addWidget(self.saveApertureState)
        self.restoreApertureState = QtWidgets.QPushButton(self.layoutWidget)
        self.restoreApertureState.setObjectName("restoreApertureState")
        self.horizontalLayout_6.addWidget(self.restoreApertureState)
        self.editAperturesButton = QtWidgets.QPushButton(self.layoutWidget)
        self.editAperturesButton.setObjectName("editAperturesButton")
        self.horizontalLayout_6.addWidget(self.editAperturesButton)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.roiComboBox = QtWidgets.QComboBox(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.roiComboBox.sizePolicy().hasHeightForWidth())
        self.roiComboBox.setSizePolicy(sizePolicy)
        self.roiComboBox.setMinimumSize(QtCore.QSize(80, 0))
        self.roiComboBox.setMaximumSize(QtCore.QSize(80, 16777215))
        self.roiComboBox.setCurrentText("")
        self.roiComboBox.setMaxVisibleItems(3)
        self.roiComboBox.setObjectName("roiComboBox")
        self.horizontalLayout_3.addWidget(self.roiComboBox)
        self.selectApertureSizeLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.selectApertureSizeLabel.sizePolicy().hasHeightForWidth())
        self.selectApertureSizeLabel.setSizePolicy(sizePolicy)
        self.selectApertureSizeLabel.setObjectName("selectApertureSizeLabel")
        self.horizontalLayout_3.addWidget(self.selectApertureSizeLabel)
        self.horizontalLayout_6.addLayout(self.horizontalLayout_3)
        self.verticalLayout_17.addLayout(self.horizontalLayout_6)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_3 = QtWidgets.QLabel(self.layoutWidget)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout.addWidget(self.label_3)
        self.thresh_inc_1 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_1.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_1.setChecked(True)
        self.thresh_inc_1.setObjectName("thresh_inc_1")
        self.horizontalLayout.addWidget(self.thresh_inc_1)
        self.thresh_inc_10 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_10.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_10.setObjectName("thresh_inc_10")
        self.horizontalLayout.addWidget(self.thresh_inc_10)
        self.thresh_inc_100 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_100.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_100.setObjectName("thresh_inc_100")
        self.horizontalLayout.addWidget(self.thresh_inc_100)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.setMskthLabel = QtWidgets.QLabel(self.layoutWidget)
        self.setMskthLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.setMskthLabel.setObjectName("setMskthLabel")
        self.horizontalLayout.addWidget(self.setMskthLabel)
        self.threshValueEdit = QtWidgets.QSpinBox(self.layoutWidget)
        self.threshValueEdit.setToolTip("")
        self.threshValueEdit.setMaximum(99999)
        self.threshValueEdit.setObjectName("threshValueEdit")
        self.horizontalLayout.addWidget(self.threshValueEdit)
        self.verticalLayout_17.addLayout(self.horizontalLayout)
        self.horizontalLayout_28 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_28.setObjectName("horizontalLayout_28")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setSpacing(0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.viewFieldsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.viewFieldsCheckBox.setEnabled(False)
        self.viewFieldsCheckBox.setObjectName("viewFieldsCheckBox")
        self.verticalLayout_5.addWidget(self.viewFieldsCheckBox)
        self.processAsFieldsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.processAsFieldsCheckBox.setEnabled(True)
        self.processAsFieldsCheckBox.setObjectName("processAsFieldsCheckBox")
        self.verticalLayout_5.addWidget(self.processAsFieldsCheckBox)
        self.topFieldFirstRadioButton = QtWidgets.QRadioButton(self.layoutWidget)
        self.topFieldFirstRadioButton.setEnabled(True)
        self.topFieldFirstRadioButton.setChecked(False)
        self.topFieldFirstRadioButton.setObjectName("topFieldFirstRadioButton")
        self.verticalLayout_5.addWidget(self.topFieldFirstRadioButton)
        self.bottomFieldFirstRadioButton = QtWidgets.QRadioButton(self.layoutWidget)
        self.bottomFieldFirstRadioButton.setEnabled(True)
        self.bottomFieldFirstRadioButton.setChecked(True)
        self.bottomFieldFirstRadioButton.setObjectName("bottomFieldFirstRadioButton")
        self.verticalLayout_5.addWidget(self.bottomFieldFirstRadioButton)
        self.horizontalLayout_28.addLayout(self.verticalLayout_5)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_28.addItem(spacerItem1)
        self.verticalLayout_15 = QtWidgets.QVBoxLayout()
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.showImageControlCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showImageControlCheckBox.setObjectName("showImageControlCheckBox")
        self.verticalLayout_15.addWidget(self.showImageControlCheckBox)
        self.horizontalLayout_26 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_26.setObjectName("horizontalLayout_26")
        self.satPixelSpinBox = QtWidgets.QSpinBox(self.layoutWidget)
        self.satPixelSpinBox.setMaximumSize(QtCore.QSize(200, 16777215))
        self.satPixelSpinBox.setMaximum(999999)
        self.satPixelSpinBox.setSingleStep(10)
        self.satPixelSpinBox.setProperty("value", 200)
        self.satPixelSpinBox.setObjectName("satPixelSpinBox")
        self.horizontalLayout_26.addWidget(self.satPixelSpinBox)
        self.satPixelLabel = QtWidgets.QLabel(self.layoutWidget)
        self.satPixelLabel.setObjectName("satPixelLabel")
        self.horizontalLayout_26.addWidget(self.satPixelLabel)
        self.verticalLayout_15.addLayout(self.horizontalLayout_26)
        self.demoMeanPushButton = QtWidgets.QPushButton(self.layoutWidget)
        self.demoMeanPushButton.setObjectName("demoMeanPushButton")
        self.verticalLayout_15.addWidget(self.demoMeanPushButton)
        self.horizontalLayout_28.addLayout(self.verticalLayout_15)
        self.verticalLayout_17.addLayout(self.horizontalLayout_28)
        self.tabWidget = QtWidgets.QTabWidget(self.layoutWidget)
        self.tabWidget.setUsesScrollButtons(True)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_5 = QtWidgets.QWidget()
        self.tab_5.setObjectName("tab_5")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_5)
        self.gridLayout_2.setObjectName("gridLayout_2")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem2, 0, 2, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem3, 0, 0, 1, 1)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem4, 1, 1, 1, 1)
        self.h1 = QtWidgets.QLabel(self.tab_5)
        self.h1.setEnabled(False)
        self.h1.setText("")
        self.h1.setObjectName("h1")
        self.gridLayout_2.addWidget(self.h1, 0, 3, 1, 1)
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.readAviFileButton = QtWidgets.QPushButton(self.tab_5)
        self.readAviFileButton.setObjectName("readAviFileButton")
        self.verticalLayout_9.addWidget(self.readAviFileButton)
        self.createAVIWCSfolderButton = QtWidgets.QPushButton(self.tab_5)
        self.createAVIWCSfolderButton.setObjectName("createAVIWCSfolderButton")
        self.verticalLayout_9.addWidget(self.createAVIWCSfolderButton)
        self.line_5 = QtWidgets.QFrame(self.tab_5)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_5.setLineWidth(5)
        self.line_5.setMidLineWidth(5)
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setObjectName("line_5")
        self.verticalLayout_9.addWidget(self.line_5)
        self.selectAviWcsFolderButton = QtWidgets.QPushButton(self.tab_5)
        self.selectAviWcsFolderButton.setObjectName("selectAviWcsFolderButton")
        self.verticalLayout_9.addWidget(self.selectAviWcsFolderButton)
        self.readFitsFolderButton = QtWidgets.QPushButton(self.tab_5)
        self.readFitsFolderButton.setToolTipDuration(0)
        self.readFitsFolderButton.setStatusTip("")
        self.readFitsFolderButton.setObjectName("readFitsFolderButton")
        self.verticalLayout_9.addWidget(self.readFitsFolderButton)
        self.line_6 = QtWidgets.QFrame(self.tab_5)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_6.setLineWidth(5)
        self.line_6.setMidLineWidth(5)
        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_6.setObjectName("line_6")
        self.verticalLayout_9.addWidget(self.line_6)
        self.metadataButton = QtWidgets.QPushButton(self.tab_5)
        self.metadataButton.setObjectName("metadataButton")
        self.verticalLayout_9.addWidget(self.metadataButton)
        self.enableAdvFrameStatusDisplay = QtWidgets.QCheckBox(self.tab_5)
        self.enableAdvFrameStatusDisplay.setChecked(False)
        self.enableAdvFrameStatusDisplay.setObjectName("enableAdvFrameStatusDisplay")
        self.verticalLayout_9.addWidget(self.enableAdvFrameStatusDisplay)
        self.line_7 = QtWidgets.QFrame(self.tab_5)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_7.setLineWidth(5)
        self.line_7.setMidLineWidth(5)
        self.line_7.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_7.setObjectName("line_7")
        self.verticalLayout_9.addWidget(self.line_7)
        self.openBmpPushButton = QtWidgets.QPushButton(self.tab_5)
        self.openBmpPushButton.setObjectName("openBmpPushButton")
        self.verticalLayout_9.addWidget(self.openBmpPushButton)
        self.gridLayout_2.addLayout(self.verticalLayout_9, 0, 1, 1, 1)
        self.tabWidget.addTab(self.tab_5, "")
        self.tab_6 = QtWidgets.QWidget()
        self.tab_6.setObjectName("tab_6")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_6)
        self.gridLayout_3.setObjectName("gridLayout_3")
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem5, 1, 4, 1, 1)
        self.lprofileButtonSpacingLabel = QtWidgets.QLabel(self.tab_6)
        self.lprofileButtonSpacingLabel.setText("")
        self.lprofileButtonSpacingLabel.setObjectName("lprofileButtonSpacingLabel")
        self.gridLayout_3.addWidget(self.lprofileButtonSpacingLabel, 1, 3, 1, 1)
        self.vtiSpacerLabel = QtWidgets.QLabel(self.tab_6)
        self.vtiSpacerLabel.setText("")
        self.vtiSpacerLabel.setObjectName("vtiSpacerLabel")
        self.gridLayout_3.addWidget(self.vtiSpacerLabel, 1, 2, 1, 1)
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.vtiSelectLabel = QtWidgets.QLabel(self.tab_6)
        self.vtiSelectLabel.setObjectName("vtiSelectLabel")
        self.horizontalLayout_9.addWidget(self.vtiSelectLabel)
        self.vtiSelectComboBox = QtWidgets.QComboBox(self.tab_6)
        self.vtiSelectComboBox.setEnabled(False)
        self.vtiSelectComboBox.setCurrentText("")
        self.vtiSelectComboBox.setObjectName("vtiSelectComboBox")
        self.horizontalLayout_9.addWidget(self.vtiSelectComboBox)
        self.verticalLayout_10.addLayout(self.horizontalLayout_9)
        self.loadCustomProfilesButton = QtWidgets.QPushButton(self.tab_6)
        self.loadCustomProfilesButton.setObjectName("loadCustomProfilesButton")
        self.verticalLayout_10.addWidget(self.loadCustomProfilesButton)
        self.clearOcrDataButton = QtWidgets.QPushButton(self.tab_6)
        self.clearOcrDataButton.setObjectName("clearOcrDataButton")
        self.verticalLayout_10.addWidget(self.clearOcrDataButton)
        self.vtiHelpButton = QtWidgets.QPushButton(self.tab_6)
        self.vtiHelpButton.setFocusPolicy(QtCore.Qt.NoFocus)
        self.vtiHelpButton.setObjectName("vtiHelpButton")
        self.verticalLayout_10.addWidget(self.vtiHelpButton)
        self.gridLayout_3.addLayout(self.verticalLayout_10, 0, 1, 2, 3)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem6, 0, 0, 1, 1)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem7, 2, 2, 1, 1)
        self.tabWidget.addTab(self.tab_6, "")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.tab_3)
        self.gridLayout_4.setObjectName("gridLayout_4")
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem8, 0, 0, 1, 1)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem9, 0, 2, 1, 1)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.hotPixelHelpButton = QtWidgets.QPushButton(self.tab_3)
        self.hotPixelHelpButton.setObjectName("hotPixelHelpButton")
        self.verticalLayout_6.addWidget(self.hotPixelHelpButton)
        self.hotPixelEraseOff = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelEraseOff.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.hotPixelEraseOff.setChecked(True)
        self.hotPixelEraseOff.setObjectName("hotPixelEraseOff")
        self.verticalLayout_6.addWidget(self.hotPixelEraseOff)
        self.hotPixelEraseFromList = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelEraseFromList.setObjectName("hotPixelEraseFromList")
        self.verticalLayout_6.addWidget(self.hotPixelEraseFromList)
        self.hotPixelErase3x3median = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelErase3x3median.setObjectName("hotPixelErase3x3median")
        self.verticalLayout_6.addWidget(self.hotPixelErase3x3median)
        self.hotPixelErase5x5median = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelErase5x5median.setObjectName("hotPixelErase5x5median")
        self.verticalLayout_6.addWidget(self.hotPixelErase5x5median)
        self.loadHotPixelProfileButton = QtWidgets.QPushButton(self.tab_3)
        self.loadHotPixelProfileButton.setObjectName("loadHotPixelProfileButton")
        self.verticalLayout_6.addWidget(self.loadHotPixelProfileButton)
        self.createHotPixelListButton = QtWidgets.QPushButton(self.tab_3)
        self.createHotPixelListButton.setObjectName("createHotPixelListButton")
        self.verticalLayout_6.addWidget(self.createHotPixelListButton)
        self.gridLayout_4.addLayout(self.verticalLayout_6, 0, 1, 1, 1)
        spacerItem10 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem10, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_3, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.tab)
        self.gridLayout_5.setObjectName("gridLayout_5")
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem11, 0, 0, 1, 1)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.alignWithStarInfoButton = QtWidgets.QPushButton(self.tab)
        self.alignWithStarInfoButton.setObjectName("alignWithStarInfoButton")
        self.horizontalLayout_11.addWidget(self.alignWithStarInfoButton)
        self.alignWithTwoPointTrackInfoButton = QtWidgets.QPushButton(self.tab)
        self.alignWithTwoPointTrackInfoButton.setObjectName("alignWithTwoPointTrackInfoButton")
        self.horizontalLayout_11.addWidget(self.alignWithTwoPointTrackInfoButton)
        self.verticalLayout_3.addLayout(self.horizontalLayout_11)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.finderRedactTopLinesLabel = QtWidgets.QLabel(self.tab)
        self.finderRedactTopLinesLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.finderRedactTopLinesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.finderRedactTopLinesLabel.setObjectName("finderRedactTopLinesLabel")
        self.horizontalLayout_15.addWidget(self.finderRedactTopLinesLabel)
        self.redactLinesTopEdit = QtWidgets.QLineEdit(self.tab)
        self.redactLinesTopEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.redactLinesTopEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.redactLinesTopEdit.setToolTip("")
        self.redactLinesTopEdit.setObjectName("redactLinesTopEdit")
        self.horizontalLayout_15.addWidget(self.redactLinesTopEdit)
        self.redactLinesBottomEdit = QtWidgets.QLineEdit(self.tab)
        self.redactLinesBottomEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.redactLinesBottomEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.redactLinesBottomEdit.setObjectName("redactLinesBottomEdit")
        self.horizontalLayout_15.addWidget(self.redactLinesBottomEdit)
        self.finderRedactBottomLinesLabel = QtWidgets.QLabel(self.tab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.finderRedactBottomLinesLabel.sizePolicy().hasHeightForWidth())
        self.finderRedactBottomLinesLabel.setSizePolicy(sizePolicy)
        self.finderRedactBottomLinesLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.finderRedactBottomLinesLabel.setIndent(-1)
        self.finderRedactBottomLinesLabel.setObjectName("finderRedactBottomLinesLabel")
        self.horizontalLayout_15.addWidget(self.finderRedactBottomLinesLabel)
        self.verticalLayout_3.addLayout(self.horizontalLayout_15)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.finderNumFramesLabel = QtWidgets.QLabel(self.tab)
        self.finderNumFramesLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.finderNumFramesLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.finderNumFramesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.finderNumFramesLabel.setObjectName("finderNumFramesLabel")
        self.horizontalLayout_16.addWidget(self.finderNumFramesLabel)
        self.numFramesToStackEdit = QtWidgets.QLineEdit(self.tab)
        self.numFramesToStackEdit.setMinimumSize(QtCore.QSize(60, 0))
        self.numFramesToStackEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.numFramesToStackEdit.setToolTip("")
        self.numFramesToStackEdit.setObjectName("numFramesToStackEdit")
        self.horizontalLayout_16.addWidget(self.numFramesToStackEdit)
        spacerItem12 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_16.addItem(spacerItem12)
        self.verticalLayout_3.addLayout(self.horizontalLayout_16)
        self.horizontalLayout_33 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_33.setObjectName("horizontalLayout_33")
        self.stackFramesButton = QtWidgets.QPushButton(self.tab)
        self.stackFramesButton.setObjectName("stackFramesButton")
        self.horizontalLayout_33.addWidget(self.stackFramesButton)
        self.openFinderPushButton = QtWidgets.QPushButton(self.tab)
        self.openFinderPushButton.setObjectName("openFinderPushButton")
        self.horizontalLayout_33.addWidget(self.openFinderPushButton)
        self.verticalLayout_3.addLayout(self.horizontalLayout_33)
        self.stackerProgressBar = QtWidgets.QProgressBar(self.tab)
        self.stackerProgressBar.setProperty("value", 0)
        self.stackerProgressBar.setObjectName("stackerProgressBar")
        self.verticalLayout_3.addWidget(self.stackerProgressBar)
        self.finderMethodEdit = QtWidgets.QLineEdit(self.tab)
        self.finderMethodEdit.setReadOnly(True)
        self.finderMethodEdit.setObjectName("finderMethodEdit")
        self.verticalLayout_3.addWidget(self.finderMethodEdit)
        self.gridLayout_5.addLayout(self.verticalLayout_3, 0, 1, 1, 1)
        spacerItem13 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem13, 0, 2, 1, 1)
        spacerItem14 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem14, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.tab_7 = QtWidgets.QWidget()
        self.tab_7.setObjectName("tab_7")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab_7)
        self.gridLayout_6.setObjectName("gridLayout_6")
        spacerItem15 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem15, 0, 0, 1, 1)
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.flipImagesLeftToRightCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.flipImagesLeftToRightCheckBox.setObjectName("flipImagesLeftToRightCheckBox")
        self.verticalLayout_11.addWidget(self.flipImagesLeftToRightCheckBox)
        self.flipImagesTopToBottomCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.flipImagesTopToBottomCheckBox.setObjectName("flipImagesTopToBottomCheckBox")
        self.verticalLayout_11.addWidget(self.flipImagesTopToBottomCheckBox)
        self.line_3 = QtWidgets.QFrame(self.tab_7)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_3.setLineWidth(5)
        self.line_3.setMidLineWidth(5)
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setObjectName("line_3")
        self.verticalLayout_11.addWidget(self.line_3)
        self.cascadeCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.cascadeCheckBox.setMinimumSize(QtCore.QSize(0, 0))
        self.cascadeCheckBox.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.cascadeCheckBox.setSizeIncrement(QtCore.QSize(0, 0))
        self.cascadeCheckBox.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.cascadeCheckBox.setChecked(True)
        self.cascadeCheckBox.setObjectName("cascadeCheckBox")
        self.verticalLayout_11.addWidget(self.cascadeCheckBox)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.plotSymbolSizeLabel = QtWidgets.QLabel(self.tab_7)
        self.plotSymbolSizeLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.plotSymbolSizeLabel.setObjectName("plotSymbolSizeLabel")
        self.horizontalLayout_12.addWidget(self.plotSymbolSizeLabel)
        self.plotSymbolSizeSpinBox = QtWidgets.QSpinBox(self.tab_7)
        self.plotSymbolSizeSpinBox.setToolTip("")
        self.plotSymbolSizeSpinBox.setMinimum(1)
        self.plotSymbolSizeSpinBox.setMaximum(20)
        self.plotSymbolSizeSpinBox.setObjectName("plotSymbolSizeSpinBox")
        self.horizontalLayout_12.addWidget(self.plotSymbolSizeSpinBox)
        self.verticalLayout_11.addLayout(self.horizontalLayout_12)
        self.line_4 = QtWidgets.QFrame(self.tab_7)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_4.setLineWidth(5)
        self.line_4.setMidLineWidth(5)
        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_4.setObjectName("line_4")
        self.verticalLayout_11.addWidget(self.line_4)
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.gammaLabel = QtWidgets.QLabel(self.tab_7)
        self.gammaLabel.setObjectName("gammaLabel")
        self.horizontalLayout_14.addWidget(self.gammaLabel)
        self.gammaSettingOfCamera = QtWidgets.QDoubleSpinBox(self.tab_7)
        self.gammaSettingOfCamera.setMinimum(0.25)
        self.gammaSettingOfCamera.setMaximum(1.0)
        self.gammaSettingOfCamera.setSingleStep(0.05)
        self.gammaSettingOfCamera.setProperty("value", 1.0)
        self.gammaSettingOfCamera.setObjectName("gammaSettingOfCamera")
        self.horizontalLayout_14.addWidget(self.gammaSettingOfCamera)
        self.verticalLayout_11.addLayout(self.horizontalLayout_14)
        self.gridLayout_6.addLayout(self.verticalLayout_11, 0, 1, 1, 1)
        spacerItem16 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem16, 0, 2, 1, 1)
        spacerItem17 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem17, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_7, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.tab_2)
        self.gridLayout_7.setObjectName("gridLayout_7")
        spacerItem18 = QtWidgets.QSpacerItem(180, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem18, 0, 0, 1, 1)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.manualWcsButton = QtWidgets.QPushButton(self.tab_2)
        self.manualWcsButton.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.manualWcsButton.sizePolicy().hasHeightForWidth())
        self.manualWcsButton.setSizePolicy(sizePolicy)
        self.manualWcsButton.setMinimumSize(QtCore.QSize(0, 0))
        self.manualWcsButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.manualWcsButton.setObjectName("manualWcsButton")
        self.verticalLayout_8.addWidget(self.manualWcsButton)
        self.line = QtWidgets.QFrame(self.tab_2)
        self.line.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line.setLineWidth(5)
        self.line.setMidLineWidth(5)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.verticalLayout_8.addWidget(self.line)
        self.frameToFitsButton = QtWidgets.QPushButton(self.tab_2)
        self.frameToFitsButton.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frameToFitsButton.sizePolicy().hasHeightForWidth())
        self.frameToFitsButton.setSizePolicy(sizePolicy)
        self.frameToFitsButton.setMinimumSize(QtCore.QSize(150, 0))
        self.frameToFitsButton.setMaximumSize(QtCore.QSize(1677215, 16777215))
        self.frameToFitsButton.setObjectName("frameToFitsButton")
        self.verticalLayout_8.addWidget(self.frameToFitsButton)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.wcsRedactTopLinesLabel = QtWidgets.QLabel(self.tab_2)
        self.wcsRedactTopLinesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.wcsRedactTopLinesLabel.setObjectName("wcsRedactTopLinesLabel")
        self.horizontalLayout_8.addWidget(self.wcsRedactTopLinesLabel)
        self.wcsRedactLinesTopEdit = QtWidgets.QLineEdit(self.tab_2)
        self.wcsRedactLinesTopEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.wcsRedactLinesTopEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.wcsRedactLinesTopEdit.setObjectName("wcsRedactLinesTopEdit")
        self.horizontalLayout_8.addWidget(self.wcsRedactLinesTopEdit)
        self.wcsRedactLinesBottomEdit = QtWidgets.QLineEdit(self.tab_2)
        self.wcsRedactLinesBottomEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.wcsRedactLinesBottomEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.wcsRedactLinesBottomEdit.setObjectName("wcsRedactLinesBottomEdit")
        self.horizontalLayout_8.addWidget(self.wcsRedactLinesBottomEdit)
        self.wcsRedactBottomLinesLabel = QtWidgets.QLabel(self.tab_2)
        self.wcsRedactBottomLinesLabel.setObjectName("wcsRedactBottomLinesLabel")
        self.horizontalLayout_8.addWidget(self.wcsRedactBottomLinesLabel)
        self.verticalLayout_8.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.pixelHeightLabel = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pixelHeightLabel.sizePolicy().hasHeightForWidth())
        self.pixelHeightLabel.setSizePolicy(sizePolicy)
        self.pixelHeightLabel.setMinimumSize(QtCore.QSize(90, 0))
        self.pixelHeightLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.pixelHeightLabel.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.pixelHeightLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.pixelHeightLabel.setObjectName("pixelHeightLabel")
        self.horizontalLayout_7.addWidget(self.pixelHeightLabel)
        self.pixelHeightEdit = QtWidgets.QLineEdit(self.tab_2)
        self.pixelHeightEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.pixelHeightEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.pixelHeightEdit.setObjectName("pixelHeightEdit")
        self.horizontalLayout_7.addWidget(self.pixelHeightEdit)
        self.pixelWidthEdit = QtWidgets.QLineEdit(self.tab_2)
        self.pixelWidthEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.pixelWidthEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.pixelWidthEdit.setObjectName("pixelWidthEdit")
        self.horizontalLayout_7.addWidget(self.pixelWidthEdit)
        self.pixelWidthLabel = QtWidgets.QLabel(self.tab_2)
        self.pixelWidthLabel.setMinimumSize(QtCore.QSize(90, 0))
        self.pixelWidthLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.pixelWidthLabel.setObjectName("pixelWidthLabel")
        self.horizontalLayout_7.addWidget(self.pixelWidthLabel)
        self.verticalLayout_8.addLayout(self.horizontalLayout_7)
        self.line_2 = QtWidgets.QFrame(self.tab_2)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_2.setLineWidth(5)
        self.line_2.setMidLineWidth(5)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_8.addWidget(self.line_2)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSpacing(0)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.ucac4Label = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ucac4Label.sizePolicy().hasHeightForWidth())
        self.ucac4Label.setSizePolicy(sizePolicy)
        self.ucac4Label.setObjectName("ucac4Label")
        self.horizontalLayout_5.addWidget(self.ucac4Label)
        self.starIdEdit = QtWidgets.QLineEdit(self.tab_2)
        self.starIdEdit.setObjectName("starIdEdit")
        self.horizontalLayout_5.addWidget(self.starIdEdit)
        self.queryVizierButton = QtWidgets.QPushButton(self.tab_2)
        self.queryVizierButton.setObjectName("queryVizierButton")
        self.horizontalLayout_5.addWidget(self.queryVizierButton)
        self.verticalLayout_8.addLayout(self.horizontalLayout_5)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setSpacing(0)
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.coordinatesEdit = QtWidgets.QLineEdit(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.coordinatesEdit.sizePolicy().hasHeightForWidth())
        self.coordinatesEdit.setSizePolicy(sizePolicy)
        self.coordinatesEdit.setMinimumSize(QtCore.QSize(260, 0))
        self.coordinatesEdit.setObjectName("coordinatesEdit")
        self.horizontalLayout_13.addWidget(self.coordinatesEdit)
        self.saveTargetLocButton = QtWidgets.QPushButton(self.tab_2)
        self.saveTargetLocButton.setEnabled(False)
        self.saveTargetLocButton.setObjectName("saveTargetLocButton")
        self.horizontalLayout_13.addWidget(self.saveTargetLocButton)
        self.verticalLayout_8.addLayout(self.horizontalLayout_13)
        self.gridLayout_7.addLayout(self.verticalLayout_8, 0, 1, 1, 1)
        spacerItem19 = QtWidgets.QSpacerItem(180, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem19, 0, 2, 1, 1)
        spacerItem20 = QtWidgets.QSpacerItem(20, 26, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem20, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_2, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.gridLayout_9 = QtWidgets.QGridLayout(self.tab_4)
        self.gridLayout_9.setObjectName("gridLayout_9")
        spacerItem21 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_9.addItem(spacerItem21, 0, 2, 1, 1)
        spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_9.addItem(spacerItem22, 0, 0, 1, 1)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.toolButton_2 = QtWidgets.QToolButton(self.tab_4)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.toolButton_2.setFont(font)
        self.toolButton_2.setObjectName("toolButton_2")
        self.verticalLayout_7.addWidget(self.toolButton_2)
        self.twoPointHelpButton = QtWidgets.QToolButton(self.tab_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.twoPointHelpButton.sizePolicy().hasHeightForWidth())
        self.twoPointHelpButton.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.twoPointHelpButton.setFont(font)
        self.twoPointHelpButton.setObjectName("twoPointHelpButton")
        self.verticalLayout_7.addWidget(self.twoPointHelpButton)
        self.transportHelp = QtWidgets.QToolButton(self.tab_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.transportHelp.sizePolicy().hasHeightForWidth())
        self.transportHelp.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportHelp.setFont(font)
        self.transportHelp.setObjectName("transportHelp")
        self.verticalLayout_7.addWidget(self.transportHelp)
        self.documentationPushButton = QtWidgets.QPushButton(self.tab_4)
        self.documentationPushButton.setObjectName("documentationPushButton")
        self.verticalLayout_7.addWidget(self.documentationPushButton)
        self.gridLayout_9.addLayout(self.verticalLayout_7, 0, 1, 1, 1)
        spacerItem23 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_9.addItem(spacerItem23, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_4, "")
        self.tab_9 = QtWidgets.QWidget()
        self.tab_9.setObjectName("tab_9")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_9)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout()
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        spacerItem24 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_17.addItem(spacerItem24)
        self.appSizeToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.appSizeToolButton.setFont(font)
        self.appSizeToolButton.setObjectName("appSizeToolButton")
        self.horizontalLayout_17.addWidget(self.appSizeToolButton)
        spacerItem25 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_17.addItem(spacerItem25)
        self.verticalLayout_19.addLayout(self.horizontalLayout_17)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        spacerItem26 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem26)
        self.frame_2 = QtWidgets.QFrame(self.tab_9)
        self.frame_2.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")
        self.horizontalLayout_30 = QtWidgets.QHBoxLayout(self.frame_2)
        self.horizontalLayout_30.setObjectName("horizontalLayout_30")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout()
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.defAppSize51RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize51RadioButton.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.defAppSize51RadioButton.setChecked(True)
        self.defAppSize51RadioButton.setObjectName("defAppSize51RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize51RadioButton)
        self.defAppSize41RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize41RadioButton.setObjectName("defAppSize41RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize41RadioButton)
        self.defAppSize31RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize31RadioButton.setObjectName("defAppSize31RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize31RadioButton)
        self.defAppSize21RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize21RadioButton.setObjectName("defAppSize21RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize21RadioButton)
        self.defAppSize11RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize11RadioButton.setObjectName("defAppSize11RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize11RadioButton)
        self.horizontalLayout_30.addLayout(self.verticalLayout_18)
        self.horizontalLayout_10.addWidget(self.frame_2)
        spacerItem27 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem27)
        self.verticalLayout_19.addLayout(self.horizontalLayout_10)
        self.gridLayout.addLayout(self.verticalLayout_19, 0, 0, 1, 1)
        self.verticalLayout_21 = QtWidgets.QVBoxLayout()
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.horizontalLayout_25 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_25.setObjectName("horizontalLayout_25")
        spacerItem28 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem28)
        self.sigmaLevelToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.sigmaLevelToolButton.setFont(font)
        self.sigmaLevelToolButton.setObjectName("sigmaLevelToolButton")
        self.horizontalLayout_25.addWidget(self.sigmaLevelToolButton)
        spacerItem29 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem29)
        self.verticalLayout_21.addLayout(self.horizontalLayout_25)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.frame = QtWidgets.QFrame(self.tab_9)
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.horizontalLayout_31 = QtWidgets.QHBoxLayout(self.frame)
        self.horizontalLayout_31.setObjectName("horizontalLayout_31")
        spacerItem30 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem30)
        self.verticalLayout_20 = QtWidgets.QVBoxLayout()
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.oneSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.oneSigmaRadioButton.setChecked(False)
        self.oneSigmaRadioButton.setObjectName("oneSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.oneSigmaRadioButton)
        self.twoSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.twoSigmaRadioButton.setChecked(True)
        self.twoSigmaRadioButton.setObjectName("twoSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.twoSigmaRadioButton)
        self.threeSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.threeSigmaRadioButton.setObjectName("threeSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.threeSigmaRadioButton)
        self.horizontalLayout_31.addLayout(self.verticalLayout_20)
        spacerItem31 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem31)
        self.horizontalLayout_21.addWidget(self.frame)
        self.verticalLayout_21.addLayout(self.horizontalLayout_21)
        self.gridLayout.addLayout(self.verticalLayout_21, 0, 1, 1, 1)
        self.verticalLayout_24 = QtWidgets.QVBoxLayout()
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.horizontalLayout_29 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_29.setObjectName("horizontalLayout_29")
        spacerItem32 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem32)
        self.defaultMaskRadiusToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.defaultMaskRadiusToolButton.setFont(font)
        self.defaultMaskRadiusToolButton.setObjectName("defaultMaskRadiusToolButton")
        self.horizontalLayout_29.addWidget(self.defaultMaskRadiusToolButton)
        spacerItem33 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem33)
        self.verticalLayout_24.addLayout(self.horizontalLayout_29)
        self.horizontalLayout_27 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_27.setObjectName("horizontalLayout_27")
        spacerItem34 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem34)
        self.frame_3 = QtWidgets.QFrame(self.tab_9)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")
        self.horizontalLayout_32 = QtWidgets.QHBoxLayout(self.frame_3)
        self.horizontalLayout_32.setObjectName("horizontalLayout_32")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout()
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.radius20radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius20radioButton.setObjectName("radius20radioButton")
        self.verticalLayout_23.addWidget(self.radius20radioButton)
        self.radius28radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius28radioButton.setObjectName("radius28radioButton")
        self.verticalLayout_23.addWidget(self.radius28radioButton)
        self.radius32radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius32radioButton.setChecked(True)
        self.radius32radioButton.setObjectName("radius32radioButton")
        self.verticalLayout_23.addWidget(self.radius32radioButton)
        self.radius40radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius40radioButton.setObjectName("radius40radioButton")
        self.verticalLayout_23.addWidget(self.radius40radioButton)
        self.radius45radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius45radioButton.setObjectName("radius45radioButton")
        self.verticalLayout_23.addWidget(self.radius45radioButton)
        self.radius53radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius53radioButton.setObjectName("radius53radioButton")
        self.verticalLayout_23.addWidget(self.radius53radioButton)
        self.radius68radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius68radioButton.setObjectName("radius68radioButton")
        self.verticalLayout_23.addWidget(self.radius68radioButton)
        self.horizontalLayout_32.addLayout(self.verticalLayout_23)
        self.horizontalLayout_27.addWidget(self.frame_3)
        spacerItem35 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem35)
        self.verticalLayout_24.addLayout(self.horizontalLayout_27)
        self.gridLayout.addLayout(self.verticalLayout_24, 0, 2, 1, 1)
        self.tabWidget.addTab(self.tab_9, "")
        self.tab_10 = QtWidgets.QWidget()
        self.tab_10.setObjectName("tab_10")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.tab_10)
        self.gridLayout_8.setObjectName("gridLayout_8")
        self.horizontalLayout_34 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_34.setObjectName("horizontalLayout_34")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout()
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.lineNoiseFilterCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.lineNoiseFilterCheckBox.setEnabled(True)
        self.lineNoiseFilterCheckBox.setObjectName("lineNoiseFilterCheckBox")
        self.verticalLayout_26.addWidget(self.lineNoiseFilterCheckBox)
        self.line_11 = QtWidgets.QFrame(self.tab_10)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_11.setLineWidth(4)
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setObjectName("line_11")
        self.verticalLayout_26.addWidget(self.line_11)
        self.horizontalRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.horizontalRadioButton.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.horizontalRadioButton.setChecked(True)
        self.horizontalRadioButton.setObjectName("horizontalRadioButton")
        self.verticalLayout_26.addWidget(self.horizontalRadioButton)
        self.verticalRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.verticalRadioButton.setObjectName("verticalRadioButton")
        self.verticalLayout_26.addWidget(self.verticalRadioButton)
        self.bothRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.bothRadioButton.setObjectName("bothRadioButton")
        self.verticalLayout_26.addWidget(self.bothRadioButton)
        self.line_12 = QtWidgets.QFrame(self.tab_10)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_12.setLineWidth(4)
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setObjectName("line_12")
        self.verticalLayout_26.addWidget(self.line_12)
        self.horizontalLayout_38 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_38.setObjectName("horizontalLayout_38")
        self.upperTimestampLineLabel = QtWidgets.QLabel(self.tab_10)
        self.upperTimestampLineLabel.setObjectName("upperTimestampLineLabel")
        self.horizontalLayout_38.addWidget(self.upperTimestampLineLabel)
        self.upperTimestampMedianSpinBox = QtWidgets.QSpinBox(self.tab_10)
        self.upperTimestampMedianSpinBox.setEnabled(False)
        self.upperTimestampMedianSpinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.upperTimestampMedianSpinBox.setMaximum(99999)
        self.upperTimestampMedianSpinBox.setObjectName("upperTimestampMedianSpinBox")
        self.horizontalLayout_38.addWidget(self.upperTimestampMedianSpinBox)
        self.verticalLayout_26.addLayout(self.horizontalLayout_38)
        self.horizontalLayout_39 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_39.setObjectName("horizontalLayout_39")
        self.lowerTimestampLineLabel = QtWidgets.QLabel(self.tab_10)
        self.lowerTimestampLineLabel.setObjectName("lowerTimestampLineLabel")
        self.horizontalLayout_39.addWidget(self.lowerTimestampLineLabel)
        self.lowerTimestampMedianSpinBox = QtWidgets.QSpinBox(self.tab_10)
        self.lowerTimestampMedianSpinBox.setEnabled(False)
        self.lowerTimestampMedianSpinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.lowerTimestampMedianSpinBox.setMaximum(99999)
        self.lowerTimestampMedianSpinBox.setObjectName("lowerTimestampMedianSpinBox")
        self.horizontalLayout_39.addWidget(self.lowerTimestampMedianSpinBox)
        self.verticalLayout_26.addLayout(self.horizontalLayout_39)
        self.showMedianProfileButton = QtWidgets.QPushButton(self.tab_10)
        self.showMedianProfileButton.setEnabled(False)
        self.showMedianProfileButton.setObjectName("showMedianProfileButton")
        self.verticalLayout_26.addWidget(self.showMedianProfileButton)
        self.horizontalLayout_34.addLayout(self.verticalLayout_26)
        self.line_13 = QtWidgets.QFrame(self.tab_10)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_13.setLineWidth(5)
        self.line_13.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_13.setObjectName("line_13")
        self.horizontalLayout_34.addWidget(self.line_13)
        self.verticalLayout_27 = QtWidgets.QVBoxLayout()
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        self.lunarCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.lunarCheckBox.setObjectName("lunarCheckBox")
        self.verticalLayout_27.addWidget(self.lunarCheckBox)
        self.useYellowMaskCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.useYellowMaskCheckBox.setObjectName("useYellowMaskCheckBox")
        self.verticalLayout_27.addWidget(self.useYellowMaskCheckBox)
        self.view3DButton = QtWidgets.QPushButton(self.tab_10)
        self.view3DButton.setObjectName("view3DButton")
        self.verticalLayout_27.addWidget(self.view3DButton)
        self.horizontalLayout_34.addLayout(self.verticalLayout_27)
        self.gridLayout_8.addLayout(self.horizontalLayout_34, 0, 1, 1, 1)
        spacerItem36 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem36, 0, 0, 1, 1)
        spacerItem37 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem37, 0, 2, 1, 1)
        spacerItem38 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_8.addItem(spacerItem38, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_10, "")
        self.verticalLayout_17.addWidget(self.tabWidget)
        self.layoutWidget1 = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_16.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.frameView = ImageView(self.layoutWidget1)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(2)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frameView.sizePolicy().hasHeightForWidth())
        self.frameView.setSizePolicy(sizePolicy)
        self.frameView.setToolTip("")
        self.frameView.setObjectName("frameView")
        self.verticalLayout_16.addWidget(self.frameView)
        self.horizontalLayout_24 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_24.setObjectName("horizontalLayout_24")
        self.runPyote = QtWidgets.QCheckBox(self.layoutWidget1)
        self.runPyote.setEnabled(False)
        self.runPyote.setObjectName("runPyote")
        self.horizontalLayout_24.addWidget(self.runPyote)
        self.verticalLayout_13 = QtWidgets.QVBoxLayout()
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.horizontalLayout_19 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_19.setSpacing(0)
        self.horizontalLayout_19.setObjectName("horizontalLayout_19")
        self.transportMaxLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportMaxLeft.setFont(font)
        self.transportMaxLeft.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)
        self.transportMaxLeft.setObjectName("transportMaxLeft")
        self.horizontalLayout_19.addWidget(self.transportMaxLeft)
        self.transportBigLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportBigLeft.setFont(font)
        self.transportBigLeft.setObjectName("transportBigLeft")
        self.horizontalLayout_19.addWidget(self.transportBigLeft)
        self.transportSmallLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportSmallLeft.setFont(font)
        self.transportSmallLeft.setObjectName("transportSmallLeft")
        self.horizontalLayout_19.addWidget(self.transportSmallLeft)
        self.transportMinusOneFrame = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportMinusOneFrame.setFont(font)
        self.transportMinusOneFrame.setAutoRepeat(True)
        self.transportMinusOneFrame.setObjectName("transportMinusOneFrame")
        self.horizontalLayout_19.addWidget(self.transportMinusOneFrame)
        self.transportPlayLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportPlayLeft.setFont(font)
        self.transportPlayLeft.setObjectName("transportPlayLeft")
        self.horizontalLayout_19.addWidget(self.transportPlayLeft)
        self.transportPause = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportPause.setMinimumSize(QtCore.QSize(0, 0))
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportPause.setFont(font)
        self.transportPause.setObjectName("transportPause")
        self.horizontalLayout_19.addWidget(self.transportPause)
        self.transportAnalyze = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportAnalyze.setFont(font)
        self.transportAnalyze.setObjectName("transportAnalyze")
        self.horizontalLayout_19.addWidget(self.transportAnalyze)
        self.transportPlayRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportPlayRight.setFont(font)
        self.transportPlayRight.setObjectName("transportPlayRight")
        self.horizontalLayout_19.addWidget(self.transportPlayRight)
        self.transportPlusOneFrame = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportPlusOneFrame.setFont(font)
        self.transportPlusOneFrame.setAutoRepeat(True)
        self.transportPlusOneFrame.setObjectName("transportPlusOneFrame")
        self.horizontalLayout_19.addWidget(self.transportPlusOneFrame)
        self.transportSmallRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportSmallRight.setFont(font)
        self.transportSmallRight.setObjectName("transportSmallRight")
        self.horizontalLayout_19.addWidget(self.transportSmallRight)
        self.transportBigRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportBigRight.setFont(font)
        self.transportBigRight.setObjectName("transportBigRight")
        self.horizontalLayout_19.addWidget(self.transportBigRight)
        self.transportMaxRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.transportMaxRight.setFont(font)
        self.transportMaxRight.setObjectName("transportMaxRight")
        self.horizontalLayout_19.addWidget(self.transportMaxRight)
        self.horizontalLayout_18.addLayout(self.horizontalLayout_19)
        self.verticalLayout_13.addLayout(self.horizontalLayout_18)
        self.horizontalLayout_23 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_23.setObjectName("horizontalLayout_23")
        self.horizontalLayout_20 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_20.setSpacing(0)
        self.horizontalLayout_20.setObjectName("horizontalLayout_20")
        spacerItem39 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_20.addItem(spacerItem39)
        self.transportCsv = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportCsv.setFont(font)
        self.transportCsv.setObjectName("transportCsv")
        self.horizontalLayout_20.addWidget(self.transportCsv)
        self.transportPlot = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportPlot.setFont(font)
        self.transportPlot.setObjectName("transportPlot")
        self.horizontalLayout_20.addWidget(self.transportPlot)
        self.transportCurrentFrameLabel = QtWidgets.QLabel(self.layoutWidget1)
        self.transportCurrentFrameLabel.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.transportCurrentFrameLabel.setObjectName("transportCurrentFrameLabel")
        self.horizontalLayout_20.addWidget(self.transportCurrentFrameLabel)
        self.currentFrameSpinBox = QtWidgets.QSpinBox(self.layoutWidget1)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.currentFrameSpinBox.sizePolicy().hasHeightForWidth())
        self.currentFrameSpinBox.setSizePolicy(sizePolicy)
        self.currentFrameSpinBox.setMinimumSize(QtCore.QSize(73, 0))
        self.currentFrameSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.currentFrameSpinBox.setFrame(True)
        self.currentFrameSpinBox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
        self.currentFrameSpinBox.setMaximum(999999)
        self.currentFrameSpinBox.setObjectName("currentFrameSpinBox")
        self.horizontalLayout_20.addWidget(self.currentFrameSpinBox)
        self.horizontalLayout_23.addLayout(self.horizontalLayout_20)
        self.horizontalLayout_22 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_22.setSpacing(0)
        self.horizontalLayout_22.setObjectName("horizontalLayout_22")
        self.stopAtFrameSpinBox = QtWidgets.QSpinBox(self.layoutWidget1)
        self.stopAtFrameSpinBox.setMinimumSize(QtCore.QSize(73, 0))
        self.stopAtFrameSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.stopAtFrameSpinBox.setFrame(True)
        self.stopAtFrameSpinBox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
        self.stopAtFrameSpinBox.setMaximum(999999)
        self.stopAtFrameSpinBox.setObjectName("stopAtFrameSpinBox")
        self.horizontalLayout_22.addWidget(self.stopAtFrameSpinBox)
        self.transportStopAtFrameLabel = QtWidgets.QLabel(self.layoutWidget1)
        self.transportStopAtFrameLabel.setObjectName("transportStopAtFrameLabel")
        self.horizontalLayout_22.addWidget(self.transportStopAtFrameLabel)
        self.label = QtWidgets.QLabel(self.layoutWidget1)
        self.label.setText("")
        self.label.setObjectName("label")
        self.horizontalLayout_22.addWidget(self.label)
        self.transportMark = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportMark.setFont(font)
        self.transportMark.setObjectName("transportMark")
        self.horizontalLayout_22.addWidget(self.transportMark)
        self.transportReturnToMark = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportReturnToMark.setEnabled(False)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportReturnToMark.setFont(font)
        self.transportReturnToMark.setObjectName("transportReturnToMark")
        self.horizontalLayout_22.addWidget(self.transportReturnToMark)
        self.horizontalLayout_23.addLayout(self.horizontalLayout_22)
        self.transportClearData = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.transportClearData.setFont(font)
        self.transportClearData.setObjectName("transportClearData")
        self.horizontalLayout_23.addWidget(self.transportClearData)
        spacerItem40 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_23.addItem(spacerItem40)
        self.verticalLayout_13.addLayout(self.horizontalLayout_23)
        self.horizontalLayout_24.addLayout(self.verticalLayout_13)
        spacerItem41 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_24.addItem(spacerItem41)
        self.verticalLayout_16.addLayout(self.horizontalLayout_24)
        self.splitterOne = QtWidgets.QSplitter(self.splitterThree)
        self.splitterOne.setOrientation(QtCore.Qt.Horizontal)
        self.splitterOne.setObjectName("splitterOne")
        self.layoutWidget2 = QtWidgets.QWidget(self.splitterOne)
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.layoutWidget2)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout()
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.textOut = QtWidgets.QTextEdit(self.layoutWidget2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.textOut.sizePolicy().hasHeightForWidth())
        self.textOut.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font.setBold(True)
        font.setWeight(75)
        self.textOut.setFont(font)
        self.textOut.setToolTip("")
        self.textOut.setObjectName("textOut")
        self.verticalLayout_14.addWidget(self.textOut)
        self.verticalLayout_4.addLayout(self.verticalLayout_14)
        self.textOutLabel = QtWidgets.QLabel(self.layoutWidget2)
        self.textOutLabel.setObjectName("textOutLabel")
        self.verticalLayout_4.addWidget(self.textOutLabel)
        self.layoutWidget3 = QtWidgets.QWidget(self.splitterOne)
        self.layoutWidget3.setObjectName("layoutWidget3")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.layoutWidget3)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.thumbOneView = ImageView(self.layoutWidget3)
        self.thumbOneView.setObjectName("thumbOneView")
        self.verticalLayout_2.addWidget(self.thumbOneView)
        self.thumbnailOneLabel = QtWidgets.QLabel(self.layoutWidget3)
        self.thumbnailOneLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.thumbnailOneLabel.setObjectName("thumbnailOneLabel")
        self.verticalLayout_2.addWidget(self.thumbnailOneLabel)
        self.horizontalLayout_2.addLayout(self.verticalLayout_2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.thumbTwoView = ImageView(self.layoutWidget3)
        self.thumbTwoView.setObjectName("thumbTwoView")
        self.verticalLayout.addWidget(self.thumbTwoView)
        self.thumbnailTwoLabel = QtWidgets.QLabel(self.layoutWidget3)
        self.thumbnailTwoLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.thumbnailTwoLabel.setObjectName("thumbnailTwoLabel")
        self.verticalLayout.addWidget(self.thumbnailTwoLabel)
        self.horizontalLayout_2.addLayout(self.verticalLayout)
        self.gridLayout_10.addWidget(self.splitterThree, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionLike_special_settings = QtWidgets.QAction(MainWindow)
        self.actionLike_special_settings.setObjectName("actionLike_special_settings")
        self.actionOr_preferences = QtWidgets.QAction(MainWindow)
        self.actionOr_preferences.setObjectName("actionOr_preferences")
        self.actionOpen_AVI_SER_file = QtWidgets.QAction(MainWindow)
        self.actionOpen_AVI_SER_file.setObjectName("actionOpen_AVI_SER_file")

        self.retranslateUi(MainWindow)
        self.roiComboBox.setCurrentIndex(-1)
        self.tabWidget.setCurrentIndex(0)
        self.vtiSelectComboBox.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking on this button will open a pdf file that provides version history. The most recent version change descriptions will be at the top for easy reference to the historical record.</p></body></html>"))
        self.infoButton.setText(_translate("MainWindow", "Version Info"))
        self.label_2.setText(_translate("MainWindow", "File:"))
        self.saveApertureState.setToolTip(_translate("MainWindow", "<html><head/><body><p>This function is only available for videos contained in an AVI/SER-WCS folder or a FITS folder.</p><p>Clicking this button will record all the apertures (and all their properties) for later restoration along with the current frame position.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> You will be prompted to supply a name string that will be appended to the file names that comprise this aperture group. This is to allow for multiple aperture groups to be associated with a video.</p><p>To restore a previous configuration, first open the folder, then click the <span style=\" font-weight:600; color:#fc0107;\">Restore aperture group</span> button.</p></body></html>"))
        self.saveApertureState.setText(_translate("MainWindow", "Save aperture group"))
        self.restoreApertureState.setToolTip(_translate("MainWindow", "<html><head/><body><p>This function is only available for videos contained in an AVI/SER-WCS folder or a FITS folder.</p><p>Clicking this button will bring up a file selector dialog with candidates aperture groups highlighted for selection. Choosing one will restore a previously saved aperture group with all the property values present when the <span style=\" font-weight:600; color:#fc0107;\">Save aperture group</span> button was clicked including the frame position.</p><p>Note that this action will first remove all current apertures, including the one that was automatically placed through an available WCS solution. Typically the target aperture would have been included in the saved aperture group anyway.</p><p>It will then position the file to the frame that was current when the \'save\' was performed and recreate all apertures present at the time of \'saving\' on that frame.</p></body></html>"))
        self.restoreApertureState.setText(_translate("MainWindow", "Restore aperture group"))
        self.editAperturesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button brings up a table that contains a row for each aperture that has been placed on the image. The columns list the available properties of an aperture. All property values, including (x,y), can be changed from this dialog box.</p><p>When a row has been selected, Thumbnail One will show the image enclosed by the aperture and Thumbnail Two will show the computed mask unless the default mask radius cell is active, in which case the default mask will be displayed instead.  This allows for edits of threshold and default mask radius with \'live\' updates shown in Thumbnail Two.</p><p>Any changes made through this dialog take effect when either the enter key is pressed, the cell is exited (via a tab key or arrow key press for example), or the dialog is closed.</p><p>Columns for color, joggable, auto textOut, and thumbnail source have right-click context menus for making changes in those cells.</p><p>The columns for name, thresh, def mask radius, and csv output order are edited by highlighting the cell (single or double click) and then typing the new value. </p><p><span style=\" font-weight:600; color:#fc0107;\">!!! When editing the value in a cell, the edit is NOT complete until you leave that cell or press enter. Make it a practice to \'tab out\' of a cell that you have modified. (This procedure is not needed for a cell that has been modified by a right-click context menu) !!!</span></p><p><span style=\" color:#000000;\">Constraints on property values:</span></p><p><span style=\" color:#000000;\">---- name: none</span></p><p><span style=\" color:#000000;\">---- thresh: positive integer</span></p><p><span style=\" color:#000000;\">---- def mask radius: minimum value of 2.00 (initial value is 5.3)</span></p><p><span style=\" color:#000000;\">---- color: only one green allowed and no more than two yellows</span></p><p><span style=\" color:#000000;\">---- thumbnail source: only a single aperture can be set as the thumbnail source</span></p><p><span style=\" color:#000000;\">---- csv output order: positive integer (it\'s up to you to avoid duplicates!)</span></p></body></html>"))
        self.editAperturesButton.setText(_translate("MainWindow", "Examine/change aperture settings"))
        self.roiComboBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This drop-down selection box changes the measurement aperture size.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> it is a reqirement that all apertures be the same size during a lightcurve extraction, so changing the aperture size will automatically remove all existing apertures.</p><p>If there is substantial wind shake in the video, you should select an aperture size sufficent to contain the \'wanderings\' of the star you have selected for tracking or, if there is no tracking star, then the target star itself.</p><p>If there is no significant wind shake, use of a smaller aperture (like 31) may be more useful in dealing with dense star fields.</p></body></html>"))
        self.selectApertureSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This drop-down selection box changes the measurement aperture size.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> it is a reqirement that all apertures be the same size during a lightcurve extraction, so changing the aperture size will automatically remove all existing apertures.</p><p>If there is substantial wind shake in the video, you should select an aperture size sufficent to contain the \'wanderings\' of the star you have selected for tracking or, if there is no tracking star, then the target star itself.</p><p>If there is no significant wind shake, use of a smaller aperture (like 31) may be more useful in dealing with dense star fields.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note: </span><span style=\" font-weight:600; color:#0000ff;\">An aperture is never allowed to extend outside the image boundary. As a result, if an aperture is placed on a star that is close to the image edge and that star subsequently moves closer to the edge, tracking will be lost when the aperture bumps up against edge. In this case, use of a smaller aperture will allow tracking closer to the edge.</span></p></body></html>"))
        self.selectApertureSizeLabel.setText(_translate("MainWindow", "Select aperture size"))
        self.label_3.setText(_translate("MainWindow", "Threshold spinner increments:"))
        self.thresh_inc_1.setText(_translate("MainWindow", "1"))
        self.thresh_inc_10.setText(_translate("MainWindow", "10"))
        self.thresh_inc_100.setText(_translate("MainWindow", "100"))
        self.setMskthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there is a currently \'green\' aperture showing, its threshold value will be set to any new value from this spinner and <span style=\" font-weight:600; color:#fc0107;\">Thumbnail Two</span> in the lower right corner will update dynamically to show the effect of the change on the binary sample mask generation.</p><p>The mask threshold is always set as counts above average background. A good starting point for setting this value is to set it equal to the background noise (found in the column labelled <span style=\" font-weight:600; color:#fc0107;\">bkstd</span> in the text box) rounded up. The program tries to do this automatically so, in most cases, this value will already be preset. This is sometimes referred to as <span style=\" color:#0000ff;\">\'setting the threshold to 1 sigma\'</span>.</p><p>Note: <span style=\" font-weight:600; color:#fc0107;\">mskth</span> (mask threshold) and <span style=\" font-weight:600; color:#fc0107;\">bkavg</span> (background average) are column headings in the text box.</p></body></html>"))
        self.setMskthLabel.setText(_translate("MainWindow", "<html><head/><body><p>Set mask (mskth) counts above background (bkavg)</p></body></html>"))
        self.viewFieldsCheckBox.setText(_translate("MainWindow", "View avi fields"))
        self.processAsFieldsCheckBox.setText(_translate("MainWindow", "Process avi in field mode"))
        self.topFieldFirstRadioButton.setText(_translate("MainWindow", "top field is first in time"))
        self.bottomFieldFirstRadioButton.setText(_translate("MainWindow", "bottom field is first in time"))
        self.showImageControlCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If this box is checked, an image control widget will appear to the right of the main image.</p><p>This widget shows a useful/interesting histogram of the image pixel values and gives you the ability to change how pixel values are mapped to the black-to-white grayscale.</p><p>To change the pixel mappings, click and drag the horizontal bars (in the left portion of the widget) that enclose the histogram display and that connect visually to the black-white colorbar.</p><p><span style=\" font-weight:600; color:#fc0107;\">NOTE:</span> changes made via this control do <span style=\" font-weight:600; text-decoration: underline;\">not</span> affect the data that is used for generating lightcurves. It only changes what you see in the main image display. But when you right click on the main image and select \'export\', the display values are what gets exported; this is the <span style=\" font-weight:600; text-decoration: underline;\">only</span> time that \'display\' values are used.</p><p>Until this image control is opened, the grayscale mapping of each image changes based on the minimum and maximum pixel values in that image. This automatic rescaling is usually acceptable but can cause apparent \'flashing\' of the images during playback. Opening and then closing this image control will freeze the automatic rescaling.</p><p><span style=\" font-weight:600; color:#fc0107;\">NOTE:</span> if you do not close the image control, when you return to the frame that was used to decide the desired settings, the settings are automatically reset --- this is not a useful behavior, so ... Best practice: activate the control; adjust the sliders; close the control.</p></body></html>"))
        self.showImageControlCheckBox.setText(_translate("MainWindow", "Show image contrast control"))
        self.satPixelLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This value controls the coloring of pixels in ThumbNail One  and Thumbnail Two.</p><p>Pixels that are at or above this level will be colored in shades of red to give a visual clue that such pixels are at or near saturation.</p><p>Pixels that are below this level are shown in the usual gray scale.</p><p>Thumbnail Two shows the parts of the aperture that are \'masked off\' in yellow and allows the display of the pixels that are included by the mask to be shown as their actual values.</p></body></html>"))
        self.satPixelLabel.setText(_translate("MainWindow", "sat. pixel value"))
        self.demoMeanPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The \'robust\' calculation of the background average and the \'robust\' estimation of the dispersion (noise) in the background is an important factor in the calculation of signal intensities.</p><p>This button demonstrates with a detailed plot the calculation as it was performed for the current \'thumbnail\'.</p><p>This is meant primarily for education purposes but may be useful in special cases to confirm (or not) that the \'robust\' calculations are reasonable.</p><p>The algorithm works by calculating a histogram of the pixels present in an aperture. The \'background\' pixels show up in the prominent \'hump\' in that histogram at the left (low pixel values). The \'hump\' is analyzed to determine where the righthand tail ends.  A red line is drawn on the histogram to show where this demarcation is. Then, all the points to the left of this demarcation are used to calculate the mean and standard deviation of those points in the usual manner.</p></body></html>"))
        self.demoMeanPushButton.setText(_translate("MainWindow", "Plot Robust Mean"))
        self.h1.setToolTip(_translate("MainWindow", "<html><head/><body><p>You are seeing this help panel because you clicked on a <span style=\" font-weight:600; color:#fc0107;\">\'track path\'</span> menu item in a non-yellow aperture --- those menu items have an effect <span style=\" font-weight:600;\">only</span> in the context of a yellow aperture and are used to define a \'tracking path\', a tracking option designed to assist in processing \'drift-through\' videos.</p><p>A \'tracking path\' is a straight line across an image that is to be followed frame-by-frame by the center of a yellow tracking aperture as the video is analyzed. This can be used to \'follow\' an object that disappears completely, particularly useful in the situation where there are no other stars that remain visible enough to provide a separate tracking reference. And, as always, the presence of a yellow aperture locks all apertures into a \'constellation\' that moves as a unit.</p><p>Note: to ease the task of re-positioning the yellow aperture as you advance to later frames, enable jogging on the aperture.</p><p>To define a \'tracking path\', use a <span style=\" font-weight:600; text-decoration: underline;\">single</span> yellow aperture and position that aperture at a desired point early in the video (it does <span style=\" font-weight:600;\">not</span> have to be frame 0) and click on the menu item <span style=\" font-weight:600; color:#fc0107;\">Use current position as early track path point</span></p><p><span style=\" color:#000000;\">To complete the definition of the \'tracking path\', position the tracking aperture at a desired point late in the video (it does not have to be the last frame) and click on the menu item </span><span style=\" font-weight:600; color:#fc0107;\">Use current position as late track path point</span></p><p><span style=\" color:#000000;\">Note: with a \'tracking path\' defined, the entire aperture constellation will move in a straight line (defined by the xy and frame number values of the early and late points). While this constellation will not itself follow windshake, stars can continue to \'dance\' within the apertures and will be \'followed\' by the mask generating routines --- for red apertures, it will look for a bright blob within an 8 pixel radius; for yellow apertures, it will look for the brightest blob anywhere in the aperture. You can always set a very high threshold to force the use of fixed circular masks in apertures where you want to suppress this behavior.</span></p><p><span style=\" color:#000000;\">Note: If you delete the yellow aperture (or add a second one), the current tracking path data will be erased.</span></p><p><span style=\" color:#000000;\">Note: You can overwrite either of the data points at any time.</span></p></body></html>"))
        self.readAviFileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: video files are read using OpenCV which employs ffmpeg to do the actual file reading. As a result, a wide range of codecs are standardly available.</p><p>In particular, avi files using Lagarith compression will be read without problem.</p><p>There is a remote possibility that a video was recorded with an unusual codec and so fail to be read by PyMovie. In that case, you will need to use an external file conversion program that can decode the file as recorded and rewrite it using a more common codec.</p><p>.adv files must be Version 2, monochrome.</p><p>.aav files must be Version 2, monochrome.</p></body></html>"))
        self.readAviFileButton.setText(_translate("MainWindow", "Open AVI/MOV/SER/ADV/AAV file"))
        self.createAVIWCSfolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will only be active when a \'bare\' avi/mov/ser/adv/aav file is opened (rather than from an AVI/MOV/SER/ADV/AAV-WCS folder).</p><p>This button has been added because of the decision to perform timestamp OCR only on files that live in an AVI/MOV/SER/ADV/AAV-WCS folder. While that is a good way to collect the (many) files that result from OCR, WCS, PyMovie, and PyOTE operations, there are likely to be users that have opted for a flat (or flatter) directory structure. This button will ease (hopefully) the transition to an alternate file organization.</p><p>When clicked, a Directory dialog will appear to allow the user to select (or even create) the directory that is to hold the newly created (and filled) AVI/MOV/SER/ADV/AAV-WCS folder. It defaults to the directory that holds the opened video file.</p><p>The name of the newly created AVI/MOV/SER/ADV/AAV-WCS folder will always be the name of the video file with its outermost extension removed.</p><p>The folder will then be populated with an alias (Mac) to the video or a Shortcut (Windows) to the video, so this file structure will be frugal with file space.</p><p>Finally, behind-the-scenes, the program simulates the user clicking on <span style=\" font-weight:600; color:#fc0107;\">Select AVI/MOV/SER/ADV/AAV-WCS folder</span> and then clicking on <span style=\" font-weight:600; color:#fc0107;\">Accept</span> (possible because after a \'creation of AVI/MOV/SER/ADV/AAV-WCS folder\', the default directory/folder is set to that of the newly created folder). We could not imagine a workflow where a user would <span style=\" font-weight:600;\">not</span> want to immediately start processing the video from within an AVI/MOV/SER/ADV/AAV-WCS folder, so the automation seems reasonable and unlikely to get in anyone\'s way.<br/></p></body></html>"))
        self.createAVIWCSfolderButton.setText(_translate("MainWindow", "Create AVI/MOV/SER/ADV/AAV-WCS folder from file"))
        self.selectAviWcsFolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>An AVI/MOV/SER/ADV/AAV-WCS folder is a container for a single observation video and its related files. As such, there must be only a single .avi/.mov/.ser/.adv/.aav file in the folder either explicitly, or by shortcut (Windows) or alias (MacOS). This requirement is enforced.</p><p>This folder may also contain a simple text file that contains the Ra and DEC coordinates of the occulted star, filled in by the user through a dialog box that appears when this position information file is found missing during WCS calibration operations.</p><p>This folder is also where the WCS calibration data will be placed if the user opts for calibrating frame 0 by making an on-line submission to astrometry.net.</p><p>This folder is also the default location for storing csv files and copies of the last lightcurve plots.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> avi files are read using OpenCV which employs ffmpeg to do the actual file reading. As a result, a wide range of avi codecs are standardly available.</p><p>In particular, avi files using Lagarith compression will be read without problem.</p><p>There is a remote possibility that an avi was recorded with an unusual codec and so fail to be read by PyMovie. In that case, you will need to use an external file conversion program that can decode the file as recorded and rewrite it using a more common codec.</p><p>ADV and AAV files must be Version 2 monochrome.</p></body></html>"))
        self.selectAviWcsFolderButton.setText(_translate("MainWindow", "Select AVI/MOV/SER/ADV/AAV-WCS folder"))
        self.readFitsFolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>A <span style=\" color:#fc0107;\">FITS</span> folder should contain a set of *.fits files, all from a single recording.</p><p>There should be no other .fits files in that folder.</p><p>It is assumed that the alphabetic ordering of the file names corresponds to sequential frames.</p><p>There is a button titled <span style=\" font-weight:600; color:#fc0107;\">Show FITS/SER/ADV/AAV metadata</span> below that will read and display in the text box (lower left corner) all the metadata entries from the currently displayed .fits/.ser/.adv file image.</p></body></html>"))
        self.readFitsFolderButton.setText(_translate("MainWindow", "Select FITS folder"))
        self.metadataButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button will show (in the text box in the lower left corner of the GUI) all metadata from the currently displayed .fits/.ser/.adv/.aav file.</p><p>\'metadata\' is the text information that is present in the header of the .fits/.ser file or the SYSTEM and USER metadata that is present in an ADV or AAV Version 2 files.</p></body></html>"))
        self.metadataButton.setText(_translate("MainWindow", "Show FITS/SER/ADV/AAV file metadata"))
        self.enableAdvFrameStatusDisplay.setToolTip(_translate("MainWindow", "<html><head/><body><p>Data frames in ADV or AAV Version 2 files can have metadata associated with each frame. If this checkbox is checked, and there is metadata available, the metadata will be displayed in the text box (lower left corner of GUI) as each frame is read.</p></body></html>"))
        self.enableAdvFrameStatusDisplay.setText(_translate("MainWindow", "Display frame metadata for ADV/AAV frames"))
        self.openBmpPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a file selection dialog with all available &quot;finder&quot; image files highlighted --- it is not uncommon to have more than one.</p><p>The &quot;finder&quot; images generated by PyMovie have a frame number imbedded in the filename. That frame number will be extracted and used to position the video to that frame before displaying the &quot;finder&quot; image.</p><p>By judicious use of static apertures, a constellation of apertures can be placed on the &quot;finder&quot; image and will remain in place when the video frame replaces the &quot;finder&quot; image --- this happens whenever the current frame number is changed.</p><p><br/></p></body></html>"))
        self.openBmpPushButton.setText(_translate("MainWindow", "Open \"finder\" image"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_5), _translate("MainWindow", "File/Folder"))
        self.vtiSelectLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This control provides a drop-down list of VTI (video time inserter) models for which OCR (optical character recognition) timestamp processing is available. Selecting an entry will cause a constellation of character extraction boxes to be displayed on the image and there will be an automatic switch to field view and to a frame other than frame 0 --- which is often an improperly formatted frame with duplicate fields (a startup artifact of the frame grabber).</p><p><span style=\" font-weight:600; color:#fc0107;\">Note that this control will only be active when an AVI/SER-WCS folder is in use AND model digit training has not been completed. Its purpose is to provide a default set of ocr character selection boxes that are approximately in good positions.</span></p><p>If the character selection boxes enclose the correct characters and are reasonably well-aligned, then you\'re ready to do fine adjustments to the box positions and, after all the boxes have had their positions optimized, select the digits 0 to 9 that will be used as model digits for the optical character recognition algorithms.</p><p>If you\'re using a Kiwi VTI, which has two positions for the timestamp and switches from one to the other when the minutes field changes, you must first determine whether the timestamp is in its lefthand position or its righthand position because you need to know which set of selection boxes to put on the image (the dropdown list for Kiwi provides a lefthand and a righthand version). So, for the Kiwi you will need to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1)</span> Try both the lefthand and righthand selection box sets --- if one them already fits well, go ahead and use it, skipping steps 2 and 3 below. If there was <span style=\" text-decoration: underline;\">no</span> obvious \'winner\', then perform the next steps.</p><p><span style=\" font-weight:600; color:#fc0107;\">2)</span> Starting with frame 1, move forward in 10 second increments until the time stamp shifts. If it shifts to the right, then frame 1 has a left-positioned timestamp. If it shifts to the left, then frame 1 has a right-positioned timestamp.</p><p><span style=\" font-weight:600; color:#fc0107;\">3)</span> Move back to frame 1 and click the select VTI dropdown list --- choose Kiwi lefthand or righthand to match the position of the timestamp determined above.</p><p>The next step is jog the position of the selection boxes so that the enclosed characters are well-centered.</p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p><span style=\" font-weight:600;\">The easiest way to adjust the selection boxes is to put the mouse cursor inside a selection and press j on the keyboard. The selection box color will change from red to yellow to show that it can be jogged by the keyboard arrow keys. The thumbnail expanded view of the selection box will be active during jog movements, so it is very easy to see when good centering has been achieved. Press the j key again to disable jogging on that box and move your cursor to the next box. Rinse and repeat until all characters are well centered.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p>It is also possible to right-click on an ocr selection box and use the resulting pop-up menu to enable all ocr boxes in a row to be enabled for jogging, or even all selection boxes at once. The arrow keys control the jogs and their direction. When a selection box is joggable (responds to the keyboard arrow keys), its color will change from red to yellow.</p><p>Finally, record the digits 0 through 9 as model digits to complete the \'training\' for the avi in this folder --- you may have to advance the video to subsequent frames to get a particular character sample.</p><p>We call the set of character selection boxes and the model digits an OCR profile. OCR profiles can be saved to (and loaded from) a list. This facility is provided because, for a given recording chain --- camera, VTI, frame-grabber ---, it is very likely that the OSD characters will be in the same place for all recordings employing that chain. So once an OCR profile has been established for that chain, it should be saved for reuse.</p></body></html>"))
        self.vtiSelectLabel.setText(_translate("MainWindow", "select VTI: "))
        self.vtiSelectComboBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Note: this control will only be active when an AVI-WCS folder is in use.</span></p><p>This control provides a drop-down list of VTI (video time inserter) models for which timestamp extraction is available.</p><p>Except for the <span style=\" font-weight:600; color:#fc0107;\">SharpCap 8 bit avi</span> entry, selecting an entry will cause a constellation of character extraction boxes to be displayed on the image (which automatically switches to field view).</p><p>If the character selection boxes enclose the correct characters and are well-aligned, then you\'re ready to go.</p><p>If you\'re dealing with a Kiwi timestamp, which has two positions for the timestamp character --- a left position and a right position --- you should first select the position that best encloses the timestamp characters in the displayed frame.</p><p>If the character boxes are not well aligned, use the jogging buttons to the right to achieve a better alignment.</p><p><span style=\" font-weight:600; text-decoration: underline; color:#fc0107;\">Note: Kiwi timestamp boxes must only be adjusted (jogged) when the timestamp position is the same as that of frame 1.</span></p><p><span style=\" color:#000000;\">The </span><span style=\" font-weight:600; color:#fc0107;\">SharpCap 8 bit avi</span> entry is special in that no OCR (optical character recognition) is needed. This is because the SharpCap program encodes a 64 bit timestamp in the first 8 bytes of the image and that is where PyMovie gets its timestamp information. So, there are no character selection boxes and there is no need to save a profile.</p></body></html>"))
        self.loadCustomProfilesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is only active whan an AVI/SER-WCS folder is open.</p><p>In that case, it displays the list of available custom ocr profiles (character selection box placements and model digits) retrieved from the file found in your user home directory with the name pymovie-ocr-profiles.p</p><p>In the dialog box that appears, you can:</p><p>1) edit the names of previously saved profiles or </p><p>2) give a name to and save the current profile or</p><p>3) delete a saved profile or</p><p>4) select a profile and \'load it\'. This will overwrite the currently active ocr profile.</p><p>To share (or get a profile from another user), these are the files in the AVI-WCS folder that comprise the ocr profile:</p><p><span style=\" font-weight:600; color:#fc0107;\">custom-boxes-upper.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">custom-boxes-lower.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">custom-digits.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">formatter.txt</span></p><p>Sharing just those files is all that is required. Put them in your AVI/SER-WCS folder and then use this dialog to save that profile with a name of your choosing into your personal list of custom ocr profiles.</p></body></html>"))
        self.loadCustomProfilesButton.setText(_translate("MainWindow", "Select/save custom ocr profile"))
        self.clearOcrDataButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button deletes all OCR profile files from the current folder--- it\'s a \'clean start-over\' to be used when an OCR setup/training session has gone pear-shaped in a big way.</p></body></html>"))
        self.clearOcrDataButton.setText(_translate("MainWindow", "Clear ocr data"))
        self.vtiHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">The </span><span style=\" font-weight:600; color:#0000ff;\">select VTI:</span><span style=\" font-weight:600; color:#fc0107;\"> dropdown list will only be active when an AVI/SER-WCS folder is in use AND model digit training has not been completed.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">An AVI/SER-WCS folder is needed because setting up the VTI timestamp extraction profile (selection box positions and character trainings) produces files that are unique to the present video and so need a space of their own in which to be saved.</span></p><p>The <span style=\" font-weight:600; color:#0000ff;\">select VTI:</span> control provides a drop-down list of VTI (video time inserter) models for which OCR (optical character recognition) timestamp processing is available. Selecting an entry will cause a constellation of character extraction boxes to be displayed on the image and there will be an automatic switch to field view and to a frame other than frame 0 --- which is often an improperly formatted frame with duplicate fields (a startup artifact of the frame grabber).</p><p>If the character selection boxes enclose the correct characters and are reasonably well-aligned, then you\'re ready to do fine adjustments to the box positions and, after all the boxes have had their positions optimized, select the digits 0 to 9 that will be used as model digits for the optical character recognition algorithms.</p><p>If you\'re using a Kiwi VTI, which has two positions for the timestamp and switches from one to the other when the minutes field changes, you must first determine whether the timestamp is in its lefthand position or its righthand position because you need to know which set of selection boxes to put on the image (the dropdown list for Kiwi provides a lefthand and a righthand version). So, for the Kiwi you will need to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1)</span> Try both the lefthand and righthand selection box sets --- if one them already fits well, go ahead and use it, skipping steps 2 and 3 below. If there was <span style=\" text-decoration: underline;\">no</span> obvious \'winner\', then perform the next steps.</p><p><span style=\" font-weight:600; color:#fc0107;\">2)</span> Starting with frame 1, move forward in 10 second increments until the time stamp shifts. If it shifts to the right, then frame 1 has a left-positioned timestamp. If it shifts to the left, then frame 1 has a right-positioned timestamp.</p><p><span style=\" font-weight:600; color:#fc0107;\">3)</span> Move back to frame 1 and click the select VTI dropdown list --- choose Kiwi lefthand or righthand to match the position of the timestamp determined above.</p><p>The next step is jog the position of the selection boxes so that the enclosed characters are well-centered.</p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p><span style=\" font-weight:600;\">The easiest way to adjust the selection boxes is to put the mouse cursor inside a selection and press j on the keyboard. The selection box color will change from red to yellow to show that it can be jogged by the keyboard arrow keys. The thumbnail expanded view of the selection box will be active during jog movements, so it is very easy to see when good centering has been achieved. Press the j key again to disable jogging on that box and move your cursor to the next box. Rinse and repeat until all characters are well centered.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p>It is also possible to right-click on an ocr selection box and use the resulting pop-up menu to enable all ocr boxes in a row to be enabled for jogging, or even all selection boxes at once. The arrow keys control the jogs and their direction. When a selection box is joggable (responds to the keyboard arrow keys), its color will change from red to yellow.</p><p>Finally, record the digits 0 through 9 as model digits to complete the \'training\' for the avi in this folder --- you may have to advance the video to subsequent frames to get a particular character sample.</p><p>We call the set of character selection boxes and the model digits an OCR profile. OCR profiles can be saved to (and loaded from) a list. This facility is provided because, for a given recording chain --- camera, VTI, frame-grabber ---, it is very likely that the OSD characters will be in the same place for all recordings employing that chain. So once an OCR profile has been established for that chain, it should be saved for reuse.</p></body></html>"))
        self.vtiHelpButton.setText(_translate("MainWindow", "Timestamp setup help"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_6), _translate("MainWindow", "Timestamp"))
        self.hotPixelHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The primary use of hot-pixel removal is to help produce clean &quot;finder&quot; images. If there are hot-pixels in frames, they appear on stacked &quot;finder&quot; images as distracting streaks (if the star field is in motion between frames) or false/spurious stars that make it more difficult to correlate a star chart with the &quot;finder&quot; image and thus to locate the desired target star.</p><p>A second reason to remove hot-pixels is that it makes the images easier to look at during \'animations\' (when you click a \'play\' button).</p><p>The use of hot-pixel removal during analysis should be restricted to those rare occasions where the interaction of the target (or tracking) star with a hot-pixel must be mitigated. But, the resulting lightcurves have been modified, maybe for the good, but maybe not. In such cases, run the analysis both with and without hot-pixel removal and choose the \'without removal\' analysis preferentially.</p><p>One aspect of hot-pixels that must be dealt with is that they often &quot;flicker&quot;.  As a result, the hot-pixel constellation will change to some degree from frame to frame. This is a little hard to deal with when generating a custom hot-pixel list and is a good reason to select the 3x3 (or 5x5) median filter rather than a custom hot-pixel list. Such a filter is applied to each frame as read without any pre-knowledge being required.<br/></p></body></html>"))
        self.hotPixelHelpButton.setText(_translate("MainWindow", "Hot-pixel removal explanation/help"))
        self.hotPixelEraseOff.setToolTip(_translate("MainWindow", "<html><head/><body><p>When selected, all hot-pixel removal is disabled.</p></body></html>"))
        self.hotPixelEraseOff.setText(_translate("MainWindow", "No hot-pixel erase"))
        self.hotPixelEraseFromList.setToolTip(_translate("MainWindow", "<html><head/><body><p>If a custom hot pixel list is loaded, checking this box will cause the erasure of hot pixels during frame reading from the video using this specialized list and hot-pixel removal technique.</p><p><span style=\" font-weight:600; color:#fc0107;\">Beware:</span> there is always the possibility of gerating a spurious \'dip\' in a light curve that has a hot pixel group overlapping a star image, particularly on a drift-through video because every pixel identified in the list has its value replaced by the procedure explained below with a value that essentially removes it from the calculation of the star intensity.</p><p><span style=\" font-weight:600; color:#0000ff;\">Hot pixel erasure is performed on a frame by frame basis by calculating an average background for that frame through a Robust Mean calculation performed on a 51 x 51 pixel aperture placed at the center of the frame. Then, this value is used to overwrite the pixel value at each coordinate point present in the hot pixel list.</span></p><p><span style=\" color:#000000;\">It is usually better and easier to use a 3x3 median filter to remove hot-pixels --- there is no need to generate the hot-pixel list by laboriously placing apertures on hot-pixel groups. This always works well when hot-pixels are isolated, that is, actually single pixels. Such a filter has a minimal (but detectable) effect on a star image that covers many dozens of pixels and so </span><span style=\" font-style:italic; color:#000000;\">could</span><span style=\" color:#000000;\"> be allowed to be active during an analysis. It would remove positive spikes in the light curve when the star drifts through a hot pixel, but when the star is very dim, the median filter may possibly reduce the intensity even more. If you have a hot-pixel interference problem with a lightcurve, try the analysis both ways: with and without hot-pixel removal --- give preference to the \'without\' version.</span></p></body></html>"))
        self.hotPixelEraseFromList.setText(_translate("MainWindow", "hot-pixel erase from custom list"))
        self.hotPixelErase3x3median.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this radio button is selected, a 3x3 median filter is applied to all frames as they are read.</p><p>A median filter replaces the pixel value in the center by the median value of all 9 pixels.</p><p><span style=\" color:#000000;\">It is usually better and easier to use a 3x3 median filter to remove hot-pixels --- there is no need to place apertures on hot-pixels to create a custom list. This always works well when hot-pixels are isolated, that is, actually single pixels. Such a filter has a minimal (but detectable) effect on a star image that covers many dozens of pixels and so </span><span style=\" font-style:italic; color:#000000;\">could</span><span style=\" color:#000000;\"> be allowed to be active during an analysis. It would remove positive spikes in the light curve when the star drifts through a hot pixel, but when the star is very dim, the median filter may possibly reduce the intensity even more. If you have a hot-pixel interference problem with a lightcurve, try the analysis both ways: with and without hot-pixel removal.</span></p></body></html>"))
        self.hotPixelErase3x3median.setText(_translate("MainWindow", "hot-pixel erase by 3x3 median filtering"))
        self.hotPixelErase5x5median.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this radio button is selected, a 5x5 median filter is applied to all frames as they are read.</p><p>This median filter replaces the pixel value in the center by the median value of all 25 pixels in the 5x5 region.</p><p><span style=\" color:#000000;\">It is usually better to use a 3x3 median filter to remove hot-pixels. Such a filter has a minimal (but detectable) effect on a star image that covers many dozens of pixels and so </span><span style=\" font-style:italic; color:#000000;\">could</span><span style=\" color:#000000;\"> be allowed to be active during an analysis. It would remove positive spikes in the light curve when the star drifts through a hot pixel, but when the star is very dim, the median filter may possibly reduce the intensity even more. If you have a hot-pixel interference problem with a lightcurve, try the analysis both ways: with and without hot-pixel removal.</span></p><p><span style=\" color:#000000;\">Choose to use a 5x5 median filter if your hot-pixels appear in pairs or small groups as well as singly but expect a more significant effect on star images. This effect is immaterial for the production of &quot;finder&quot; images (it\'s primary intended use) but caution should be used if you allow this to be active during analysis --- it will affect the lightcurve.</span></p><p><span style=\" color:#000000;\">If you have extended clumps of hot-pixels that are not small relative to a 5x5 region, you will be forced to use a custom hot-pixel list generated by placing apertures on the offending groups and clicking the </span><span style=\" font-weight:600; color:#0000ff;\">extract hot-pixel list</span><span style=\" color:#000000;\"> button.</span></p></body></html>"))
        self.hotPixelErase5x5median.setText(_translate("MainWindow", "hot-pixel erase by 5x5 median filtering"))
        self.loadHotPixelProfileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you have created, named, and saved hot-pixel lists from previous videos captured with the current camera, clicking this button will bring up a table of those hot-pixel profiles.</p><p>Selecting one of those will restore the apertures and the hot-pixel list of the original session. This gives you an opportunity to verify that the list is still relevant and to make any changes that may be required.</p></body></html>"))
        self.loadHotPixelProfileButton.setText(_translate("MainWindow", "load/save/edit hot-pixel profiles"))
        self.createHotPixelListButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button after placing apertures on all of the hot pixel groups present in the image. Remember, the hot-pixel constellation may be different from frame to frame.</p><p>This list will be used to remove those hot-pixels from each frame that is to be used in the creation of a &quot;finder&quot; image. This is desirable because hot-pixels, which do not move, often produce annoying streaks or false/spurious stars in the &quot;finder&quot; images.</p><p>Even when hot-pixels don\'t produce streaks (guidance of the telescope has to very good in such a case) it is also useful to remove hot pixel groups so that they don\'t add confusing asterisms --- it\'s easier to correlate a finder image without spurious \'stars\' that don\'t appear in a sky chart.</p><p>Use the <span style=\" font-weight:600; color:#fc0107;\">load/save/edit hot-pixels profiles</span> button above if you want to to name and save this list into a hot-pixel list database for future use. Since the hot pixel constellation for a given camera/camera setting will change slowly with time, such saved profiles can be quickly recalled and will often be sufficient for hot pixel removal. At the very least, it will serve as good starting point.</p></body></html>"))
        self.createHotPixelListButton.setText(_translate("MainWindow", "extract hot-pixel list from apertures that you have placed"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Hot Pixels"))
        self.alignWithStarInfoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p>The simplest and easiest to use method for performing image alignment is use an aperture with a name that starts with \'stack\' to follow a bright star through the frames that are to be aligned --- the xy translations of that star are used subsequently to align the frames. </p><p>To use the <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> method: </p><p>1) Place a snap-to-blob aperture on the desired star while at the desired starting frame.</p><p>2) Give that aperture a name that starts with \'stack\' (case-insensitive)</p><p>3) Fill in the top and bottom redact numbers (used for removing timestamp overlays).</p><p>4) Specify the number of frames to stack. </p><p>5) Click on Generate &quot;finder&quot;. What you will see is an &quot;analysis&quot; run (with the \'stack\' aperture following the star), followed by an image alignment run, followed by the appearance of the &quot;finder&quot; image. Note: This is an actual analysis run so data will be collected. </p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.alignWithStarInfoButton.setText(_translate("MainWindow", "Align: star"))
        self.alignWithTwoPointTrackInfoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p><span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> requires that a 2 point tracking path be established for the video. A 2 point tracking path is a bit tedious to set up but works very well for frame alignment when there is just a single, possibly disappearing, star. Note that it cannot follow windshake. Use <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> if at all possible whenever there is much windshake. </p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> to get instructions on setting a 2 point tracking path, click on the Help tab, then on the button labeled \'Help for two point tracking\'</p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.alignWithTwoPointTrackInfoButton.setText(_translate("MainWindow", "Align: 2 point track"))
        self.finderRedactTopLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information.</p><p>For generating a &quot;finder&quot; image, getting rid of the timestamp is <span style=\" font-weight:600; color:#fc0107;\">essential</span> for getting a good image to image registration based on the star field movement. If the timestamp is not removed, then the stacking process will likely register on the timestamp instead.</p><p>This entry is also used when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (takes longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the top get this treatment.</p></body></html>"))
        self.finderRedactTopLinesLabel.setText(_translate("MainWindow", "redact: top "))
        self.finderRedactBottomLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information.</p><p>For generating a &quot;finder&quot; image, getting rid of the timestamp is <span style=\" font-weight:600; color:#fc0107;\">essential</span> for getting a good image to image registration based on the star field movement. If the timestamp is not removed, then the stacking process will likely register on the timestamp instead.</p><p>This entry is also used when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (takes longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the bottom get this treatment.</p></body></html>"))
        self.finderRedactBottomLinesLabel.setText(_translate("MainWindow", "bottom   "))
        self.finderNumFramesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This edit box specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p>Of course, your objective might be to get a \'pretty picture\' of the star field. If so, have at it, but be aware that stars may \'appear\' for which an occultation light curve cannot be extracted when processing is done frame by frame.</p></body></html>"))
        self.finderNumFramesLabel.setText(_translate("MainWindow", "num frames:"))
        self.stackFramesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p>There are two available algorithms for performing image alignment: </p><p>1) <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> uses an aperture with a name that starts with \'stack\' to follow a bright star through the frames that are to be aligned --- the xy translations of that star are used subsequently to align the frames. This is the simplest and most reliable method to use and takes priority over methods 2 and 3. Click the <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> button for how-to-use details.</p><p>2) <span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> uses a 2 point tracking path that has been established for the video. This is more tedious to set up but also works very well for frame alignment although it will not follow windshake. Use 1) whenever there is much windshake. Click the <span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> button for how-to-use details.</p><p>The &quot;finder\' image is calculated by summing the (aligned) frame stack, dividing that sum by the number of frames.</p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.stackFramesButton.setText(_translate("MainWindow", "Generate \"finder\""))
        self.openFinderPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a file selection dialog with all available &quot;finder&quot; image files highlighted --- it is not uncommon to have more than one.</p><p>The &quot;finder&quot; images generated by PyMovie have a frame number imbedded in the filename. That frame number will be extracted and used to position the video to that frame before displaying the &quot;finder&quot; image.</p><p>By judicious use of static apertures, a constellation of apertures can be placed on the &quot;finder&quot; image and will remain in place when the video frame replaces the &quot;finder&quot; image --- this happens whenever the current frame number is changed.</p><p><br/></p></body></html>"))
        self.openFinderPushButton.setText(_translate("MainWindow", "Open \"finder\""))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "\"finder\""))
        self.flipImagesLeftToRightCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to flip the image left to right.</p></body></html>"))
        self.flipImagesLeftToRightCheckBox.setText(_translate("MainWindow", "Flip images left/right"))
        self.flipImagesTopToBottomCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to invert the Y axes on the main image as well as the two thumbnails.</p><p>This control is necessary because: the origin of composite video images is the upper left corner of the image; for .fits files, the origin is at the lower left corner of the image.</p></body></html>"))
        self.flipImagesTopToBottomCheckBox.setText(_translate("MainWindow", "Flip images top/bottom"))
        self.cascadeCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If checked, lightcurve plots will cascade from the upper left of the monitor diagonally toward the lower right.</p><p>If unchecked, lightcurve plots will stack on top of each other in the center of the monitor.</p></body></html>"))
        self.cascadeCheckBox.setText(_translate("MainWindow", "cascade the lightcurve plots"))
        self.plotSymbolSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the size of the symbols used in the plots to show a data value position. </p><p>If you open a set of plots and would like to see smaller or larger dots, simply close the plots, change the symbol size using this spinner and reopen the plots.</p></body></html>"))
        self.plotSymbolSizeLabel.setText(_translate("MainWindow", "Plot symbol size:"))
        self.gammaLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the video was recorded with a gamma setting other than 1.00, put that value in this spin box (it can be directly edited if the 0.05 steps of the spinner are inappropriate).</p><p>If a value other than 1.00 is present in this edit box, all images will have a gamma reversal applied on a pixel by pixel basis. This is desirable when more accurate photometrics are needed as it improves the linearity of the pixel response to light.</p><p>The reversal equation used is: <span style=\" font-weight:600; color:#fc0107;\">xnew = maxval * ((x / maxval) ^ (1 / gamma))</span> where maxval is either 65535 (for 16 bit images) or 255 (for 8 bit images).</p></body></html>"))
        self.gammaLabel.setText(_translate("MainWindow", "gamma"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_7), _translate("MainWindow", "Image/Plot"))
        self.manualWcsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button starts a \'manual\' WCS calibration (user guided reference star designation).</p><p><span style=\" font-weight:600; color:#fc0107;\">Manual WCS calibration</span> utilizes two stars with known icrs coordinates together with their xy position in the image to compute a mapping from icrs coordinates to pixel coordinates.</p><p>When this button is pressed, all previous manual WCS calibration data is erased (you have to confirm this action). Then the work flow expected is:</p><p>1) Use the VizieR query to get the icrs coordinates of the first reference star. (So do your star chart with UCAC4 annotations).</p><p>2) Put an aperture on that star.</p><p>3) Adjust (if necessary) the aperture so that the centering is satisfactory.</p><p>4) Right click on the aperture and click on <span style=\" font-weight:600; color:#fc0107;\">Set RA Dec (from VizieR query results)</span></p><p><span style=\" color:#000000;\">5) Repeat steps 1...4 for the second reference star.</span></p><p><span style=\" color:#000000;\">6) If you have already defined the target coordinates, an aperture will immediately appear at the proper image location, otherwise ...</span></p><p><span style=\" color:#000000;\">7) ... use the VizieR query to get the target coordinates and then click the </span><span style=\" font-weight:600; color:#fc0107;\">Set as target</span><span style=\" color:#000000;\"> button. The target aperture will then appear.</span></p><p><br/></p></body></html>"))
        self.manualWcsButton.setText(_translate("MainWindow", "Manual WCS calib"))
        self.frameToFitsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is used to get a WCS calibration for the current image by utilizing the on-line service nova.astrometry.net</p><p>If this service fails (see discussion below) then you could try the<span style=\" font-weight:600; color:#fc0107;\"> Manual WCS calibration</span> button. It prompts you to put an aperture around two known stars in your image by using a star chart (preferably with UCAC4 star designations). If those stars are sufficiently far apart, we can use the icrs coordinates in conjuction with the xy position of the aperture to \'calibrate\' that image.</p><p>nova.astrometry.net is designed to do \'blind\' identification and WCS calibration on star field images. But it will not be able to identify images that have a too narrow field of view. If your field of view is under 15 arcmin, it is not likely to be able to calibrate that image and it will spend a long time (many minutes) trying. If an image is going to be successfully identified, it will take only a few seconds of cpu time after getting a job assigned (which takes one to two minutes).</p><p>Note: another possible reason for a \'failure\' is that the camera pixels used for the video were not square and the proper pixel width and height values were not specified properly.</p><p>Clicking this button reads the current frame and redacts the timestamp area by replacing all bytes in the timestamp zone with the Robust background (constant value).</p><p>The number of lines to be redacted are controlled by the <span style=\" font-weight:600; color:#fc0107;\">redact lines</span> edit box.</p><p>This redacted image is written as a file suitable for submission to nova.astrometry.net together with a user entered target star position (RA and Dec at J2000). The image will have been resized based on the pixel width and height information for non-square pixels in the source camera.</p><p>The entries for the star position values are entered into a star position dialog that will appear if no star position has yet been defined.</p><p>That same dialog form provides for the entry of the user\'s nova.astrometry.net api key. This value will be \'sticky\' (preserved across runs of PyMovie) and is required for submitting images for WCS calibration. It\'s easy (and free) to obtain. Simply go to nova.astrometry.net and sign in by clicking on your choice of credential supplier, no need to create a username/password combination. After signing in, click on My Profile and your api key will be displayed there.</p></body></html>"))
        self.frameToFitsButton.setText(_translate("MainWindow", "astrometry WCS calib"))
        self.wcsRedactTopLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (take longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacing those lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the top get this treatment.</p></body></html>"))
        self.wcsRedactTopLinesLabel.setText(_translate("MainWindow", "     redact: top"))
        self.wcsRedactBottomLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (take longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the bottom get this treatment.</p></body></html>"))
        self.wcsRedactBottomLinesLabel.setText(_translate("MainWindow", "bottom"))
        self.pixelHeightLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the camera used for the video does not have square pixels, the image sent to nova.astrometry.net for WCS calibration will need to have the image resized to compensate for the rectangular shape of the camera pixels. This is required so that the plate scale (arcseconds/pixel) will be the same in the x direction as the y direction.</p><p>This correction is needed for manual WCS calibration as well, but is accomplished in a different manner: a rescaling of x and y dimensions during the calculations rather than an image resize.</p><p>If you know that the camera pixels are square, enter the same number for pixel height and pixel width. The units don\'t matter. The number used doesn\'t matter. All that matters is that pixelWidth / pixelHeight = 1.000 (i.e., pixel aspect ratio = 1.000).</p><p>If the camera pixels are not square, but instead are rectangular, enter the correct width and height of the pixels in these edit boxes. The units used do not matter. All that matters is the ratio of these two numbers.</p><p>Example: for a Watec 910 camera, enter 9.8 as pixelHeight and 8.4 as pixelWidth. (The units are actually microns, but that does not matter.)</p><p>The RunCam Night Eagle Pro II camera has square pixels (6x6 microns). You can enter a 6 in both edit boxes for this camera.</p></body></html>"))
        self.pixelHeightLabel.setText(_translate("MainWindow", " pixel height: "))
        self.pixelWidthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the camera used for the video does not have square pixels, the image sent to nova.astrometry.net for WCS calibration will need to have the image resized to compensate for the rectangular shape of the camera pixels. This is required so that the plate scale (arcseconds/pixel) will be the same in the x direction as the y direction.</p><p>This correction is needed for manual WCS calibration as well, but is accomplished in a different manner: a rescaling of x and y dimensions during the calculations rather than an image resize.</p><p>If you know that the camera pixels are square, enter the same number for pixel height and pixel width. The units don\'t matter. The number used doesn\'t matter. All that matters is that pixelWidth / pixelHeight = 1.000 (i.e., pixel aspect ratio = 1.000).</p><p>If the camera pixels are not square, but instead are rectangular, enter the correct width and height of the pixels in these edit boxes. The units used do not matter. All that matters is the ratio of these two numbers.</p><p>Example: for a Watec 910 camera, enter 9.8 as pixelHeight and 8.4 as pixelWidth. (The units are actually microns, but that does not matter.)</p><p>The RunCam Night Eagle Pro II camera has square pixels (6x6 microns). You can enter a 6 in both edit boxes for this camera.</p></body></html>"))
        self.pixelWidthLabel.setText(_translate("MainWindow", ": pixel width"))
        self.ucac4Label.setToolTip(_translate("MainWindow", "<html><head/><body><p>The entry here must be of the form XXX-XXXXXX otherwise you will get a \'star not found\' message instead of the coordinates you were seeking.</p></body></html>"))
        self.ucac4Label.setText(_translate("MainWindow", "UCAC4"))
        self.starIdEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>The entry here <span style=\" text-decoration: underline;\">must</span> be of the form XXX-XXXXXX otherwise you will get a \'star not found\' message instead of the coordinates you were seeking.</p></body></html>"))
        self.queryVizierButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button triggers a query to Vizier for the J2000 coordinates of a UCAC4 star. The coordinates found are displayed in the edit box below in hms dms format.</p><p>The UCAC4 caltalog is used (VizieR catalog I/322A)</p></body></html>"))
        self.queryVizierButton.setText(_translate("MainWindow", "Query VizieR"))
        self.saveTargetLocButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you are working in a FITS folder or an AVI-WCS folder, clicking this button causes the location in the edit box to the left to be written to the file <span style=\" font-weight:600; color:#fc0107;\">target-location.txt </span>in that folder.  This is how one sets the coordinates of star-to-be-occulted --- the \'target\'.</p></body></html>"))
        self.saveTargetLocButton.setText(_translate("MainWindow", "Set as target"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "WCS"))
        self.toolButton_2.setText(_translate("MainWindow", "The best and most relevant help is obtained by right-clicking\n"
"on buttons. Most buttons have help info built into them.\n"
"There are some labels that provide the same service ---\n"
"this is used when the GUI element already has a right-click\n"
"action associated with it."))
        self.twoPointHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Two point tracking is a tool used primarily in conjunction with drift-through videos when there is no other suitable star for tracking other than the target star which will be (hopefully) disappearing somtime during the video.</p><p>Two point tracking allows a \'tracking path\' to be associated with a yellow aperture by using it to locate a star that is visible at two points in the video sequence and then recording the coordinate/frame values at those two points. </p><p>A \'tracking path\' is a straight line across an image that is to be followed frame-by-frame by the center of a yellow tracking aperture as the video is analyzed. This can be used to \'follow\' an object that disappears completely, particularly useful in the situation where there are no other stars that remain visible enough to provide a separate tracking reference. And, as always, the presence of a yellow aperture locks all apertures into a \'constellation\' that moves as a unit.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> to ease the task of re-positioning the yellow aperture as you advance to later frames, jogging on newly added apertures is automatically enabled.</p><p>To define a \'tracking path\', use a <span style=\" font-weight:600; text-decoration: underline;\">single</span> yellow aperture and position that aperture at a desired point early in the video (it does <span style=\" font-weight:600;\">not</span> have to be frame 0) and do a right-click on the aperture and then left-click on the menu item <span style=\" font-weight:600; color:#fc0107;\">Use current position as early track path point</span></p><p><span style=\" color:#000000;\">To complete the definition of the \'tracking path\', position the tracking aperture at a desired point late in the video (it does not have to be the last frame), do a right-click on the aperture and then left-click on the menu item </span><span style=\" font-weight:600; color:#fc0107;\">Use current position as late track path point</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> with a \'tracking path\' defined, the entire aperture constellation will move in a straight line (defined by the xy and frame number values of the early and late points). While this constellation will not itself follow windshake, stars can continue to \'dance\' within the apertures and will be \'followed\' by the mask generating routines --- for red apertures, it will look for a bright blob within an 8 pixel radius; for yellow apertures, it will look for the brightest blob anywhere in the aperture. You can always set a very high threshold to force the use of fixed circular masks in apertures where you want to suppress this behavior.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> If you delete the yellow aperture (or add a second one), the current tracking path data will be erased.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> You can overwrite either of the data points at any time.</span></p><p><span style=\" color:#000000;\">If an aperture group is saved, any tracking path defined will be saved as well.</span></p></body></html>"))
        self.twoPointHelpButton.setText(_translate("MainWindow", "Help for two point tracking"))
        self.transportHelp.setToolTip(_translate("MainWindow", "<html><head/><body><p>Context menus invoked by the usual mouse right-click are used to place measurement apertures, change their properties, name them, remove them, and control the image view itself.</p><p>For controlling the image view itself, a left-click and hold will allow the image to be panned in all directions with subsequent mouse movement.</p><p>A right-click and hold allows zooming in the direction of subsequent mouse movement.</p><p>A right-click in a region that does not contain a measuring aperture will cause a context menu to appear that has <span style=\" font-weight:600; color:#fc0107;\">Add snap-to-blob aperture</span> and <span style=\" font-weight:600; color:#fc0107;\">Add static aperture (no snap)</span> menu entries. You will almost always be using the \'snap-to-blob\' aperture; <span style=\" font-weight:600; color:#fc0107;\">Add static aperture (no snap</span><span style=\" font-weight:600;\">)</span> is used for placing an aperture exactly where you want it (i.e., no snap). This will most commonly be used for placing a <span style=\" font-weight:600; text-decoration: underline;\">white</span> aperture (see below) and for placing an aperture on a &quot;finder&quot; image.</p><p>On this same context menu, there are menu items for controlling aspects of the image view itself; the most used menu item will be <span style=\" font-weight:600; color:#fc0107;\">View all</span>, used after a <span style=\" font-weight:600; text-decoration: underline; color:#fc0107;\">scroll wheel zoom</span> or <span style=\" text-decoration: underline; color:#fc0107;\">left-click-drag-for-pan</span> have been used to adjust the view to return the size and position to the original condition.</p><p>A right-click <span style=\" font-weight:600; text-decoration: underline;\">inside</span> a measurement aperture brings up a context menu that allows you to change propertires of the aperture. You will be most concerned with the color of the aperture:</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">yellow</span> aperture around a bright star causes that star to be used as a tracking reference. If you select a single star as a tracking reference, translation movements (the image as a whole moves some number of pixels up, down, and sideways) of the star field will be tracked. The aperture constellation as a whole will be translated.</p><p>You can add a second yellow aperture (no more than two are allowed) if there a possibility of field rotation as well as field translation. In this case, tracking equations are used that allow for the aperture constellation as a whole to be both rotated and translated in order to follow the star field.</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">green</span> aperture is connected to the threshold setting spinner to make it easier to modify threshold settings. That spinner has the longish title: <span style=\" color:#fc0107;\">set mskth counts above bkavg</span></p><p>A <span style=\" font-weight:600; text-decoration: underline;\">white</span> aperture is useful when flash-tags have been recorded in the video. The special thing about a white aperture is that all pixels in the aperture are summed and output as the \'signal\' with no background subtraction. Such a signal can be employed by PyOTE to provide an alternative to the timestamp overlay from Video Time Inserters. In addition, a \'white\' aperture always stays where placed --- it does not track and is never part of an aperture constellation group.</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">red</span> aperture has the special property that it will only form a mask from a blob that is within 8 pixels of the center. This helps keep a nearby bright star from interfering with mask formation.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note: </span><span style=\" font-weight:600; color:#0000ff;\">An aperture is never allowed to extend outside the image boundary. As a result, if an aperture is placed on a star that is close to the image edge and that star subsequently moves closer to the edge, tracking will be lost when the aperture bumps up against edge. In this case, use of a smaller aperture will allow tracking closer to the edge.</span></p></body></html>"))
        self.transportHelp.setText(_translate("MainWindow", "Help for image area (aperture placement, etc)"))
        self.documentationPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking on this button will open a pdf file that provides additional documentation beyond that incorporated in the <span style=\" font-weight:600; color:#fc0107;\">right-click-for-help</span> system (which will/should be your first stop for assistance).</p></body></html>"))
        self.documentationPushButton.setText(_translate("MainWindow", "Documentation"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Help"))
        self.appSizeToolButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> The aperture size selected here will only take effect when PyMovie is closed and then reopened. The selected value will be used to set the<span style=\" font-weight:600; color:#fc0107;\"> Select aperture size</span> spinner on the main page when PyMovie starts up.</p></body></html>"))
        self.appSizeToolButton.setText(_translate("MainWindow", "aperture size to be\n"
"used at startup"))
        self.defAppSize51RadioButton.setText(_translate("MainWindow", "51"))
        self.defAppSize41RadioButton.setText(_translate("MainWindow", "41"))
        self.defAppSize31RadioButton.setText(_translate("MainWindow", "31"))
        self.defAppSize21RadioButton.setText(_translate("MainWindow", "21"))
        self.defAppSize11RadioButton.setText(_translate("MainWindow", "11"))
        self.sigmaLevelToolButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>When a snap-to-blob aperture is initially placed on an image, a mask threshold will be calculated as either one, two, or three sigma. (Sigma is extracted by the Robust Mean extraction routine from the background noise and is the standard deviation of the background.)</p><p>This radio button group determines whether one, two, or three sigma will be used as the mask threshold when the next snap-to-blob aperture is placed.</p></body></html>"))
        self.sigmaLevelToolButton.setText(_translate("MainWindow", "Number of sigmas \n"
"(std-dev) to set\n"
"mask threshold \n"
"above background"))
        self.oneSigmaRadioButton.setText(_translate("MainWindow", "1 sigma"))
        self.twoSigmaRadioButton.setText(_translate("MainWindow", "2 sigma"))
        self.threeSigmaRadioButton.setText(_translate("MainWindow", "3 sigma"))
        self.defaultMaskRadiusToolButton.setText(_translate("MainWindow", "Default mask radius.\n"
"This takes effect on next\n"
"aperture placement."))
        self.radius20radioButton.setText(_translate("MainWindow", "2.0"))
        self.radius28radioButton.setText(_translate("MainWindow", "2.8"))
        self.radius32radioButton.setText(_translate("MainWindow", "3.2"))
        self.radius40radioButton.setText(_translate("MainWindow", "4.0"))
        self.radius45radioButton.setText(_translate("MainWindow", "4.5"))
        self.radius53radioButton.setText(_translate("MainWindow", "5.3"))
        self.radius68radioButton.setText(_translate("MainWindow", "6.8"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_9), _translate("MainWindow", "Pref."))
        self.lineNoiseFilterCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Under some conditions for some cameras,&nbsp;the background will exhibit a \'patterning\' where some scan lines are a little brighter than others.</span></p><p><span style=\" font-size:18pt;\">We refer to this \'patterning\' as \'line noise\'.</span></p><p><span style=\" font-size:18pt;\">If you check this box,&nbsp;images will be subjected to a median filter on a line by line basis.</span></p><p><span style=\" font-size:18pt;\">The filter operates by finding the median value along a scan line and using this value to adust all rows such that they share a common median value.&nbsp;This procedure suppresses/eliminates the \'patterning\'.</span></p><p><span style=\" font-size:18pt;\">It is up to you to decide whether this is a valid procedure,&nbsp;but I have provided one tool that may help: I accumulate the line-by-line median values and calculate the average median value for each row.&nbsp;This plot can be displayed by clicking on the </span><span style=\" font-size:18pt; font-weight:600; color:#0000ff;\">Show Median Profile</span><span style=\" font-size:18pt;\"> button below.&nbsp;If the \'patterning\' is due to chip/camera construction,&nbsp;the median values for a line will be consistent from frame to frame and this plot will show the row to row variation in the background brightness of the rows.&nbsp;If there is a consistent and significant row to row brightness difference,&nbsp;I believe you have good justification in applying this filter as it \'corrects\' a systematic/instrumental effect from the chip/camera design.</span></p><p><span style=\" font-size:18pt;\">If,&nbsp;instead,&nbsp;the row to row brightness differences are random,&nbsp;the average median value from row to row will not differ much.&nbsp;That means that the chip/camera is NOT showing instrumental bias and you should be cautious and conservative in deciding whther to use median line filtering for such a video.</span></p></body></html>"))
        self.lineNoiseFilterCheckBox.setText(_translate("MainWindow", "apply \'line noise\' median filter"))
        self.horizontalRadioButton.setText(_translate("MainWindow", "apply horizontally"))
        self.verticalRadioButton.setText(_translate("MainWindow", "apply vertically"))
        self.bothRadioButton.setText(_translate("MainWindow", "apply horizontally and vertically"))
        self.upperTimestampLineLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">For OCR and the median filter to work properly,&nbsp;the median filter must avoid processing lines that include timestamp or other overlaid annotation.</span></p><p><span style=\" font-size:18pt;\">Use this spinner to move the red line from the topmost line down (increasing spinner values) until any timestamp or annotations are above it.</span></p></body></html>"))
        self.upperTimestampLineLabel.setText(_translate("MainWindow", "upper timestamp limit"))
        self.lowerTimestampLineLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">For OCR and the median filter to work properly, the median filter must avoid processing lines that include timestamp or other overlaid annotation.</span></p><p><span style=\" font-size:18pt;\">Use this spinner to move the yellow line from the bottom line up (increasing spinner values) until any timestamp or annotations are below it.</span></p></body></html>"))
        self.lowerTimestampLineLabel.setText(_translate("MainWindow", "lower timestamp limit"))
        self.showMedianProfileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">During the median filtering on each processed frame,&nbsp;the line-by-line median values are accumulated so that when this button is clicked,&nbsp;an average median value for each row can be calculated and displayed.</span></p><p><span style=\" font-size:18pt;\">If the \'line patterning\' is due to chip/camera construction,&nbsp;the median values for a line will be consistent from frame to frame and this plot will show a row to row variation in the background brightness of the rows.&nbsp;If there is a consistent and significant row to row brightness difference,&nbsp;then you have good justification in applying this filter and using the resulting light-curve because this filter process has \'corrected\' a systematic/instrumental effect from the chip/camera design.</span></p><p><span style=\" font-size:18pt;\">If,&nbsp;instead,&nbsp;the row to row brightness differences are random,&nbsp;the average median value from row to row will not differ much.&nbsp;That means that the chip/camera is NOT showing instrumental bias and you should be cautious and conservative in deciding whther to use median line filtering for such a video.</span></p></body></html>"))
        self.showMedianProfileButton.setText(_translate("MainWindow", "Show Median Profile"))
        self.lunarCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Only for use with lunar occultations</span></p><p><span style=\" color:#000000;\">When an aperture is placed on a sunlit lunar limb, it will contain pixels from the sky, pixels from the lunar limb, and pixels from the about-to-be-occulted star. This is also true for a fixed circular sampling mask positioned on the star. In that situation, what is the \'correct\' way to subtract \'background\'? Limovie has answered that question by providing a special aperture (Avoid Sunlit Face) that can be positioned so that a semi-circular area can be oriented so that only sky pixels are contained. Those pixels are then used to calculate the background value.</span></p><p><span style=\" color:#000000;\">When this box is checked, PyMovie does effectively the same thing but by a different method: it uses a statistical analysis of all the pixels in an aperture and sorts out which are from the sky and which are not by how their intensities are distributed. You can check what is happening by clicking on the Plot Robust Mean button to see where it placed the green line that shows the calculated mean value.</span></p></body></html>"))
        self.lunarCheckBox.setText(_translate("MainWindow", "lunar"))
        self.useYellowMaskCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there is significant wind shake during the occultation, the use of a default circular mask is inappropriate because we know that the star image is not circular but rather more snake-like.</p><p>However, it is reasonable to expect that the wanderings of the tracking star are the same as the wanderings of the target star and so a mask computed from the tracking star, while it will probably contain more pixels than one might like, has the correct shape to be used for the target star as well.</p><p>Checking this box will cause the \'yellow\' mask to be used for measuring all target images.</p><p>This is a \'last hope\' option: good luck with it.</p></body></html>"))
        self.useYellowMaskCheckBox.setText(_translate("MainWindow", "yellow mask = default"))
        self.view3DButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a new window that shows a 3D rendering of the Thumbnail One image.</p></body></html>"))
        self.view3DButton.setText(_translate("MainWindow", "Show 3D thumbnail"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_10), _translate("MainWindow", "Misc."))
        self.runPyote.setToolTip(_translate("MainWindow", "<html><head/><body><p>If PyOTE is installed on your machine, this checkbox will be enabled, otherwise it will remain disabled.</p><p>If this box is checked, when a new csv file has been written, PyOTE will be automatically started and will read the newly created csv file.</p></body></html>"))
        self.runPyote.setText(_translate("MainWindow", "auto-run PyOTE"))
        self.transportMaxLeft.setToolTip(_translate("MainWindow", "Jump to frame 0"))
        self.transportMaxLeft.setText(_translate("MainWindow", "<<"))
        self.transportBigLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump left 10 seconds (if avi in use) or 200 frames (if FITS file in use).</p></body></html>"))
        self.transportBigLeft.setText(_translate("MainWindow", "- 10 sec"))
        self.transportSmallLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump left 1 second (if avi in use) or 25 frames (if FITS file in use).</p></body></html>"))
        self.transportSmallLeft.setText(_translate("MainWindow", "- 1 sec"))
        self.transportMinusOneFrame.setToolTip(_translate("MainWindow", "<html><head/><body><p>Move left 1 frame</p></body></html>"))
        self.transportMinusOneFrame.setText(_translate("MainWindow", "-1 fr"))
        self.transportPlayLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Play the file continuously to the left (earlier in time). No data is recorded during \'play\'. You must click <span style=\" font-weight:600; color:#fc0107;\">analyze</span> in order to have data recorded.</p></body></html>"))
        self.transportPlayLeft.setText(_translate("MainWindow", "<"))
        self.transportPause.setToolTip(_translate("MainWindow", "<html><head/><body><p>Pause an analysis (light curve extraction) that is in progress.</p></body></html>"))
        self.transportPause.setText(_translate("MainWindow", "pause"))
        self.transportAnalyze.setToolTip(_translate("MainWindow", "<html><head/><body><p>Advance frame by frame from <span style=\" font-weight:600; color:#fc0107;\">cur frame</span> up to (or down to) <span style=\" font-weight:600; color:#fc0107;\">stop frame</span>, tracking and recording aperture data for plots and csv export. I.e., generate the light curve data.</p></body></html>"))
        self.transportAnalyze.setText(_translate("MainWindow", "analyze"))
        self.transportPlayRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Play the file to the right (forward in time). No data is recorded during \'play\'. You must click <span style=\" font-weight:600; color:#fc0107;\">analyze</span> in order to have data recorded.</p></body></html>"))
        self.transportPlayRight.setText(_translate("MainWindow", ">"))
        self.transportPlusOneFrame.setToolTip(_translate("MainWindow", "<html><head/><body><p>Move right 1 frame</p></body></html>"))
        self.transportPlusOneFrame.setText(_translate("MainWindow", "+1 fr"))
        self.transportSmallRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump right 1 second (if avi in use) or 25 frames (if FITS file in use).</p></body></html>"))
        self.transportSmallRight.setText(_translate("MainWindow", "+ 1 sec"))
        self.transportBigRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump right 10 seconds (if avi in use) or 200 frames (if FITS file in use).</p></body></html>"))
        self.transportBigRight.setText(_translate("MainWindow", "+ 10 sec"))
        self.transportMaxRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump to last frame.</p><p>In addition, set <span style=\" font-weight:600; color:#fc0107;\">stop frame</span> to the frame number of the last frame.</p></body></html>"))
        self.transportMaxRight.setText(_translate("MainWindow", ">>"))
        self.transportCsv.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button opens a Save File dialog. Use this dialog to name and, optionally select the directory where you wish the csv file to be written. The default directory is the directory from which the video data was read.</p><p>A set of columns is created for each aperture with the column naming incorporating the aperture name for identification.</p><p>Hopefully you named each aperture in a logical manner. While there is an automatic unique name given to each aperture at creation time, providing user-friendly aperture names will help greatly in identifying the csv file columns.</p><p>Apertures can be renamed at any time without losing any data, so please make use of this feature: it will make consumers of your csv file happy.</p></body></html>"))
        self.transportCsv.setText(_translate("MainWindow", "write csv"))
        self.transportPlot.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button triggers the production of a set of plots that provides a visual summary of the aperture data collected.  Note the <span style=\" font-weight:600; color:#fc0107;\">cascade</span> checkbox that controls whether these plots are done on top of each other (exactly aligned with each other) or spread like a deck of cards (cascased).</p><p>These plots make use of the name that you have assigned to each aperture (you did do that didn\'t you?). While there is an automatic unique name given to each aperture at creation time, providing user-friendly aperture names will help greatly in identifying the plots and is particularly useful in identifying csv file columns.</p><p>Apertures can be renamed at any time without losing any data, so please make use of this feature: it will make consumers of your lightcurves happy.</p><p>A composite plot is produced that contains the lightcurves for all of the apertures on a single plot.</p><p>Then a plot for each individual aperture is produced. This plot has two parts: a large \'signal intensity\' suplot at the top and a smaller \'number of mask pixels\' subplot at the bottom.</p><p>In the individual plots a symbol code is used to indicate when a default mask was used. Instead of a colored circle for signal intensity, a black triangle is used instead to indicate that the mask used in measuring this point\'s intensity was not computed from the image but was instead a \'default\' of some kind.</p></body></html>"))
        self.transportPlot.setText(_translate("MainWindow", "plot"))
        self.transportCurrentFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This box shows the frame number of the currently displayed frame.</p><p>This will be the first frame whose data will be recorded when an analysis is started.</p></body></html>"))
        self.transportCurrentFrameLabel.setText(_translate("MainWindow", "   current frame"))
        self.transportStopAtFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This box sets the final frame processed during an analysis run (light curve extraction).</p><p>If the<span style=\" font-weight:600; color:#fc0107;\"> stop frame</span> number is greater than the <span style=\" font-weight:600; color:#fc0107;\">cur frame</span> number, analysis proceeds in that direction and the data will include that of the stop frame.</p><p>If the <span style=\" font-weight:600; color:#fc0107;\">stop frame</span> number is less than the <span style=\" font-weight:600; color:#fc0107;\">cur frame</span> number, analysis proceeds backwards (toward earlier time) and stops one frame before the given stop at frame. This is to facilate building a light curve by analyzing both forward and backward in time.</p></body></html>"))
        self.transportStopAtFrameLabel.setText(_translate("MainWindow", "stop frame"))
        self.transportMark.setToolTip(_translate("MainWindow", "<html><head/><body><p>After a new video is loaded, when the first \'analysis\' run is started, the number and positions of the apertures present at that time are automatically \'remembered\' (\'marked\'). </p><p>This is very helpful if the starfield moves in a substantial way and yet you have a need to start over. A direct jump to the beginning would usually lose tracking and the apertures would need to be repositioned. But PyMovie \'remembers\' the aperture and frame number setup so that with a click on the <span style=\" font-weight:600; color:#fc0107;\">Return to \'mark\'</span> button in the transport button array under the image, you can jump back and start over without the need to reset the aperture positions.</p><p>Because that \'remembering\' is automatic, this will likely be a seldom used button.</p><p>But if there is a need to override the automatic \'mark\', this button is the one to push.</p><p>Note that <span style=\" font-weight:600; color:#fc0107;\">ONLY</span> the aperture count and positions are \'remembered\', not the accumulated data or any other property change that you may have instituted during the run (like a threshold change or change in default mask, etc). Therefore, be sure to click on the <span style=\" font-weight:600; color:#fc0107;\">Clear aperture data</span> button before resuming.</p><p>Note: a \'marked\' position is <span style=\" font-weight:600; color:#fc0107;\">NOT</span> remembered between runs. Use the <span style=\" font-weight:600; color:#fc0107;\">Save aperture group</span> button if it is desired to have an aperture group/constellation be \'sticky\'.</p></body></html>"))
        self.transportMark.setText(_translate("MainWindow", "mark"))
        self.transportReturnToMark.setToolTip(_translate("MainWindow", "<html><head/><body><p>Return to the aperture constellation position present when either the first \'analysis\' was started, or when the <span style=\" font-weight:600; color:#fc0107;\">mark</span> button was clicked (to override the normal automatic position recording).</p><p>The frame number is set as well.</p></body></html>"))
        self.transportReturnToMark.setText(_translate("MainWindow", "Return to \'mark\'"))
        self.transportClearData.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button deletes all data that has been accumulated in the apertures. (The apertures are \'objects\' with properties like color, location, threshold, and also hold the recorded data itself).</p><p>It is often the case that one will \'experiment\' with the video by analyzing short stretches of it.</p><p>All of the data produced while in the \'analyze\' state is accumulated, even when you do it piecemeal. This can cause data points to be recorded multiple times.</p><p>Best practice is, before starting a production by setting the starting and stopping frame numbers, that one clears any previous data.</p></body></html>"))
        self.transportClearData.setText(_translate("MainWindow", "clear data"))
        self.textOutLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Here is the \'decoder\' for the column headings:</p><p>signal = sum of all pixels included in the mask with the background (bkavg) subtracted from each one.</p><p>appsum = sum of all pixels included in the mask </p><p>bkavg = average background, calculated using a Robust Mean estimator with 50% outlier rejection.</p><p>bkstd = standard deviation of the background, calculated using a Robust Scale estimator with 50% outlier rejection (assumes gaussian distribution)</p><p>mskth = Thresh used in forming mask. This value is added to bkavg to compute binary mask</p><p>mskpx = number of pixels in binary mask - if negative, a default mask was used</p><p>cvxhull = convex hull: the area enclosed by a rubber band that surrounds the mask.</p><p>xpos = y position of centroid in image coordinates</p><p>ypos = x position of centroid in image coordinates</p><p>minpx = minimum value pixel contained in the pixels selected by the mask</p><p>maxpx = maximum value pixel contained in the pixels selected by the mask</p></body></html>"))
        self.textOutLabel.setText(_translate("MainWindow", "Right-click here for info"))
        self.thumbnailOneLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:14pt;\">This panel shows a zoomed version of the image contained within the aperture boundaries.</span></p></body></html>"))
        self.thumbnailOneLabel.setText(_translate("MainWindow", "<html><head/><body><p>Thumbnail One (right-click here for info)</p></body></html>"))
        self.thumbnailTwoLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This image shows the mask that will be applied to the image shown in Thumbnail One.</p><p>Currently, the \'mask\' is dynamically calculated by the following steps: </p><p>1) Thumbnail One is blurred using a 5x5 pixel Gaussian.</p><p>2)<span style=\" font-weight:600; color:#fc0107;\"> \'mask threshold above background</span><span style=\" color:#fc0107;\">\'</span> is used to turn the blurred Thumbnail One image into a binary image (only the values 0 and 1 are present) by setting to 0 all pixels that are &lt;= <span style=\" font-weight:600; color:#fc0107;\">\'mask threshold above background</span><span style=\" color:#fc0107;\">\'</span><span style=\" font-weight:600; color:#fc0107;\"/><span style=\" color:#fc0107;\">+ bkavg</span> and setting to 1 all pixels that are greater than <span style=\" font-weight:600; color:#fc0107;\">\'mask threshold above background</span><span style=\" color:#fc0107;\">\'</span><span style=\" font-weight:600; color:#fc0107;\"/><span style=\" color:#fc0107;\">+ bkavg</span>. </p><p>3) The resulting binary image is processed to find all \'blobs\' (connected groups of pixels with value 1).</p><p>4) The signal contained in each blob is computed (with background subtraction).</p><p>5) If a tracking star is present and this is a target star (non-yellow aperture), an additional constraint is enforced: the centroid of the \'blob\' must lie within a 8 pixel radius of the aperture center. This helps suppress any bright stars that may be in the aperture, but not in the center.</p><p>6) The \'blob\' found in step 5 is turned into the mask that is displayed in this thumbnail.</p></body></html>"))
        self.thumbnailTwoLabel.setText(_translate("MainWindow", "<html><head/><body><p>Thumbnail Two (right-click here for info)</p></body></html>"))
        self.actionLike_special_settings.setText(_translate("MainWindow", "Like special settings"))
        self.actionOr_preferences.setText(_translate("MainWindow", "Or preferences"))
        self.actionOpen_AVI_SER_file.setText(_translate("MainWindow", "Open AVI/SER file"))
from pyqtgraph import ImageView
