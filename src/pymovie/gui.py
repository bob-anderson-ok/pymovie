# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PyMovie.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1537, 806)
        MainWindow.setMinimumSize(QtCore.QSize(120, 0))
        MainWindow.setMaximumSize(QtCore.QSize(16777215, 16777215))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        MainWindow.setFont(font)
        MainWindow.setToolTipDuration(-1)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_12 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_12.setObjectName("gridLayout_12")
        self.splitterThree = QtWidgets.QSplitter(self.centralwidget)
        self.splitterThree.setOrientation(QtCore.Qt.Vertical)
        self.splitterThree.setObjectName("splitterThree")
        self.splitterTwo = QtWidgets.QSplitter(self.splitterThree)
        self.splitterTwo.setOrientation(QtCore.Qt.Horizontal)
        self.splitterTwo.setObjectName("splitterTwo")
        self.layoutWidget = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_17.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setSpacing(4)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        self.infoButton.setMinimumSize(QtCore.QSize(40, 0))
        self.infoButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.infoButton.setObjectName("infoButton")
        self.horizontalLayout_4.addWidget(self.infoButton)
        self.label_2 = QtWidgets.QLabel(self.layoutWidget)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_4.addWidget(self.label_2)
        self.fileInUseEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.fileInUseEdit.setObjectName("fileInUseEdit")
        self.horizontalLayout_4.addWidget(self.fileInUseEdit)
        self.verticalLayout_17.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setSpacing(0)
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.saveApertureState = QtWidgets.QPushButton(self.layoutWidget)
        self.saveApertureState.setObjectName("saveApertureState")
        self.horizontalLayout_6.addWidget(self.saveApertureState)
        self.restoreApertureState = QtWidgets.QPushButton(self.layoutWidget)
        self.restoreApertureState.setObjectName("restoreApertureState")
        self.horizontalLayout_6.addWidget(self.restoreApertureState)
        self.editAperturesButton = QtWidgets.QPushButton(self.layoutWidget)
        self.editAperturesButton.setObjectName("editAperturesButton")
        self.horizontalLayout_6.addWidget(self.editAperturesButton)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.roiComboBox = QtWidgets.QComboBox(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.roiComboBox.sizePolicy().hasHeightForWidth())
        self.roiComboBox.setSizePolicy(sizePolicy)
        self.roiComboBox.setMinimumSize(QtCore.QSize(80, 0))
        self.roiComboBox.setMaximumSize(QtCore.QSize(80, 16777215))
        self.roiComboBox.setCurrentText("")
        self.roiComboBox.setMaxVisibleItems(3)
        self.roiComboBox.setObjectName("roiComboBox")
        self.horizontalLayout_3.addWidget(self.roiComboBox)
        self.selectApertureSizeLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.selectApertureSizeLabel.sizePolicy().hasHeightForWidth())
        self.selectApertureSizeLabel.setSizePolicy(sizePolicy)
        self.selectApertureSizeLabel.setObjectName("selectApertureSizeLabel")
        self.horizontalLayout_3.addWidget(self.selectApertureSizeLabel)
        self.horizontalLayout_6.addLayout(self.horizontalLayout_3)
        self.verticalLayout_17.addLayout(self.horizontalLayout_6)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_3 = QtWidgets.QLabel(self.layoutWidget)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout.addWidget(self.label_3)
        self.thresh_inc_1 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_1.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_1.setChecked(True)
        self.thresh_inc_1.setObjectName("thresh_inc_1")
        self.horizontalLayout.addWidget(self.thresh_inc_1)
        self.thresh_inc_10 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_10.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_10.setObjectName("thresh_inc_10")
        self.horizontalLayout.addWidget(self.thresh_inc_10)
        self.thresh_inc_100 = QtWidgets.QRadioButton(self.layoutWidget)
        self.thresh_inc_100.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.thresh_inc_100.setObjectName("thresh_inc_100")
        self.horizontalLayout.addWidget(self.thresh_inc_100)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.setMskthLabel = QtWidgets.QLabel(self.layoutWidget)
        self.setMskthLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.setMskthLabel.setObjectName("setMskthLabel")
        self.horizontalLayout.addWidget(self.setMskthLabel)
        self.threshValueEdit = QtWidgets.QSpinBox(self.layoutWidget)
        self.threshValueEdit.setToolTip("")
        self.threshValueEdit.setMaximum(99999)
        self.threshValueEdit.setObjectName("threshValueEdit")
        self.horizontalLayout.addWidget(self.threshValueEdit)
        self.verticalLayout_17.addLayout(self.horizontalLayout)
        self.horizontalLayout_28 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_28.setObjectName("horizontalLayout_28")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setSpacing(0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.viewFieldsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.viewFieldsCheckBox.setEnabled(False)
        self.viewFieldsCheckBox.setObjectName("viewFieldsCheckBox")
        self.verticalLayout_5.addWidget(self.viewFieldsCheckBox)
        self.processAsFieldsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.processAsFieldsCheckBox.setEnabled(True)
        self.processAsFieldsCheckBox.setObjectName("processAsFieldsCheckBox")
        self.verticalLayout_5.addWidget(self.processAsFieldsCheckBox)
        self.topFieldFirstRadioButton = QtWidgets.QRadioButton(self.layoutWidget)
        self.topFieldFirstRadioButton.setEnabled(True)
        self.topFieldFirstRadioButton.setChecked(False)
        self.topFieldFirstRadioButton.setObjectName("topFieldFirstRadioButton")
        self.verticalLayout_5.addWidget(self.topFieldFirstRadioButton)
        self.bottomFieldFirstRadioButton = QtWidgets.QRadioButton(self.layoutWidget)
        self.bottomFieldFirstRadioButton.setEnabled(True)
        self.bottomFieldFirstRadioButton.setChecked(True)
        self.bottomFieldFirstRadioButton.setObjectName("bottomFieldFirstRadioButton")
        self.verticalLayout_5.addWidget(self.bottomFieldFirstRadioButton)
        self.horizontalLayout_28.addLayout(self.verticalLayout_5)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_28.addItem(spacerItem1)
        self.verticalLayout_15 = QtWidgets.QVBoxLayout()
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.showImageControlCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showImageControlCheckBox.setObjectName("showImageControlCheckBox")
        self.verticalLayout_15.addWidget(self.showImageControlCheckBox)
        self.horizontalLayout_26 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_26.setObjectName("horizontalLayout_26")
        self.satPixelSpinBox = QtWidgets.QSpinBox(self.layoutWidget)
        self.satPixelSpinBox.setMaximumSize(QtCore.QSize(200, 16777215))
        self.satPixelSpinBox.setMaximum(999999)
        self.satPixelSpinBox.setSingleStep(10)
        self.satPixelSpinBox.setProperty("value", 200)
        self.satPixelSpinBox.setObjectName("satPixelSpinBox")
        self.horizontalLayout_26.addWidget(self.satPixelSpinBox)
        self.satPixelLabel = QtWidgets.QLabel(self.layoutWidget)
        self.satPixelLabel.setObjectName("satPixelLabel")
        self.horizontalLayout_26.addWidget(self.satPixelLabel)
        self.verticalLayout_15.addLayout(self.horizontalLayout_26)
        self.demoMeanPushButton = QtWidgets.QPushButton(self.layoutWidget)
        self.demoMeanPushButton.setObjectName("demoMeanPushButton")
        self.verticalLayout_15.addWidget(self.demoMeanPushButton)
        self.horizontalLayout_28.addLayout(self.verticalLayout_15)
        self.verticalLayout_17.addLayout(self.horizontalLayout_28)
        self.tabWidget = QtWidgets.QTabWidget(self.layoutWidget)
        self.tabWidget.setEnabled(True)
        self.tabWidget.setUsesScrollButtons(True)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_5 = QtWidgets.QWidget()
        self.tab_5.setObjectName("tab_5")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_5)
        self.gridLayout_2.setObjectName("gridLayout_2")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem2, 0, 2, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem3, 0, 0, 1, 1)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem4, 1, 1, 1, 1)
        self.h1 = QtWidgets.QLabel(self.tab_5)
        self.h1.setEnabled(False)
        self.h1.setText("")
        self.h1.setObjectName("h1")
        self.gridLayout_2.addWidget(self.h1, 0, 3, 1, 1)
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.readAviFileButton = QtWidgets.QPushButton(self.tab_5)
        self.readAviFileButton.setObjectName("readAviFileButton")
        self.verticalLayout_9.addWidget(self.readAviFileButton)
        self.createAVIWCSfolderButton = QtWidgets.QPushButton(self.tab_5)
        self.createAVIWCSfolderButton.setObjectName("createAVIWCSfolderButton")
        self.verticalLayout_9.addWidget(self.createAVIWCSfolderButton)
        self.line_5 = QtWidgets.QFrame(self.tab_5)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_5.setLineWidth(5)
        self.line_5.setMidLineWidth(5)
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setObjectName("line_5")
        self.verticalLayout_9.addWidget(self.line_5)
        self.selectAviWcsFolderButton = QtWidgets.QPushButton(self.tab_5)
        self.selectAviWcsFolderButton.setObjectName("selectAviWcsFolderButton")
        self.verticalLayout_9.addWidget(self.selectAviWcsFolderButton)
        self.readFitsFolderButton = QtWidgets.QPushButton(self.tab_5)
        self.readFitsFolderButton.setToolTipDuration(0)
        self.readFitsFolderButton.setStatusTip("")
        self.readFitsFolderButton.setObjectName("readFitsFolderButton")
        self.verticalLayout_9.addWidget(self.readFitsFolderButton)
        self.line_6 = QtWidgets.QFrame(self.tab_5)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_6.setLineWidth(5)
        self.line_6.setMidLineWidth(5)
        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_6.setObjectName("line_6")
        self.verticalLayout_9.addWidget(self.line_6)
        self.metadataButton = QtWidgets.QPushButton(self.tab_5)
        self.metadataButton.setObjectName("metadataButton")
        self.verticalLayout_9.addWidget(self.metadataButton)
        self.enableAdvFrameStatusDisplay = QtWidgets.QCheckBox(self.tab_5)
        self.enableAdvFrameStatusDisplay.setChecked(False)
        self.enableAdvFrameStatusDisplay.setObjectName("enableAdvFrameStatusDisplay")
        self.verticalLayout_9.addWidget(self.enableAdvFrameStatusDisplay)
        self.line_7 = QtWidgets.QFrame(self.tab_5)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_7.setLineWidth(5)
        self.line_7.setMidLineWidth(5)
        self.line_7.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_7.setObjectName("line_7")
        self.verticalLayout_9.addWidget(self.line_7)
        self.openBmpPushButton = QtWidgets.QPushButton(self.tab_5)
        self.openBmpPushButton.setObjectName("openBmpPushButton")
        self.verticalLayout_9.addWidget(self.openBmpPushButton)
        self.gridLayout_2.addLayout(self.verticalLayout_9, 0, 1, 1, 1)
        self.tabWidget.addTab(self.tab_5, "")
        self.tab_6 = QtWidgets.QWidget()
        self.tab_6.setObjectName("tab_6")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_6)
        self.gridLayout_3.setObjectName("gridLayout_3")
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem5, 1, 4, 1, 1)
        self.lprofileButtonSpacingLabel = QtWidgets.QLabel(self.tab_6)
        self.lprofileButtonSpacingLabel.setText("")
        self.lprofileButtonSpacingLabel.setObjectName("lprofileButtonSpacingLabel")
        self.gridLayout_3.addWidget(self.lprofileButtonSpacingLabel, 1, 3, 1, 1)
        self.vtiSpacerLabel = QtWidgets.QLabel(self.tab_6)
        self.vtiSpacerLabel.setText("")
        self.vtiSpacerLabel.setObjectName("vtiSpacerLabel")
        self.gridLayout_3.addWidget(self.vtiSpacerLabel, 1, 2, 1, 1)
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.vtiSelectLabel = QtWidgets.QLabel(self.tab_6)
        self.vtiSelectLabel.setObjectName("vtiSelectLabel")
        self.horizontalLayout_9.addWidget(self.vtiSelectLabel)
        self.vtiSelectComboBox = QtWidgets.QComboBox(self.tab_6)
        self.vtiSelectComboBox.setEnabled(False)
        self.vtiSelectComboBox.setCurrentText("")
        self.vtiSelectComboBox.setObjectName("vtiSelectComboBox")
        self.horizontalLayout_9.addWidget(self.vtiSelectComboBox)
        self.verticalLayout_10.addLayout(self.horizontalLayout_9)
        self.loadCustomProfilesButton = QtWidgets.QPushButton(self.tab_6)
        self.loadCustomProfilesButton.setObjectName("loadCustomProfilesButton")
        self.verticalLayout_10.addWidget(self.loadCustomProfilesButton)
        self.clearOcrDataButton = QtWidgets.QPushButton(self.tab_6)
        self.clearOcrDataButton.setObjectName("clearOcrDataButton")
        self.verticalLayout_10.addWidget(self.clearOcrDataButton)
        self.vtiHelpButton = QtWidgets.QPushButton(self.tab_6)
        self.vtiHelpButton.setFocusPolicy(QtCore.Qt.NoFocus)
        self.vtiHelpButton.setObjectName("vtiHelpButton")
        self.verticalLayout_10.addWidget(self.vtiHelpButton)
        self.gridLayout_3.addLayout(self.verticalLayout_10, 0, 1, 2, 3)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem6, 0, 0, 1, 1)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem7, 2, 2, 1, 1)
        self.tabWidget.addTab(self.tab_6, "")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.tab_3)
        self.gridLayout_4.setObjectName("gridLayout_4")
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem8, 1, 0, 1, 1)
        spacerItem9 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem9, 2, 1, 1, 1)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.hotPixelHelpButton = QtWidgets.QPushButton(self.tab_3)
        self.hotPixelHelpButton.setObjectName("hotPixelHelpButton")
        self.verticalLayout_6.addWidget(self.hotPixelHelpButton)
        self.createHotPixelListButton = QtWidgets.QPushButton(self.tab_3)
        self.createHotPixelListButton.setObjectName("createHotPixelListButton")
        self.verticalLayout_6.addWidget(self.createHotPixelListButton)
        self.clearCCDhotPixelListPushButton = QtWidgets.QPushButton(self.tab_3)
        self.clearCCDhotPixelListPushButton.setObjectName("clearCCDhotPixelListPushButton")
        self.verticalLayout_6.addWidget(self.clearCCDhotPixelListPushButton)
        self.loadHotPixelProfileButton = QtWidgets.QPushButton(self.tab_3)
        self.loadHotPixelProfileButton.setObjectName("loadHotPixelProfileButton")
        self.verticalLayout_6.addWidget(self.loadHotPixelProfileButton)
        self.hotPixelEraseFromList = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelEraseFromList.setChecked(True)
        self.hotPixelEraseFromList.setObjectName("hotPixelEraseFromList")
        self.verticalLayout_6.addWidget(self.hotPixelEraseFromList)
        self.hotPixelEraseOff = QtWidgets.QRadioButton(self.tab_3)
        self.hotPixelEraseOff.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.hotPixelEraseOff.setChecked(False)
        self.hotPixelEraseOff.setObjectName("hotPixelEraseOff")
        self.verticalLayout_6.addWidget(self.hotPixelEraseOff)
        self.gridLayout_4.addLayout(self.verticalLayout_6, 1, 1, 1, 1)
        spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem10, 1, 2, 1, 1)
        spacerItem11 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem11, 0, 1, 1, 1)
        self.tabWidget.addTab(self.tab_3, "")
        self.tab_11 = QtWidgets.QWidget()
        self.tab_11.setObjectName("tab_11")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.tab_11)
        self.gridLayout_8.setObjectName("gridLayout_8")
        spacerItem12 = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_8.addItem(spacerItem12, 0, 1, 1, 1)
        spacerItem13 = QtWidgets.QSpacerItem(141, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem13, 1, 0, 1, 1)
        self.verticalLayout_33 = QtWidgets.QVBoxLayout()
        self.verticalLayout_33.setObjectName("verticalLayout_33")
        self.horizontalLayout_51 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_51.setObjectName("horizontalLayout_51")
        self.dfRestoreAvailableFramesButton = QtWidgets.QPushButton(self.tab_11)
        self.dfRestoreAvailableFramesButton.setObjectName("dfRestoreAvailableFramesButton")
        self.horizontalLayout_51.addWidget(self.dfRestoreAvailableFramesButton)
        self.dfClearFrameDataButton = QtWidgets.QPushButton(self.tab_11)
        self.dfClearFrameDataButton.setObjectName("dfClearFrameDataButton")
        self.horizontalLayout_51.addWidget(self.dfClearFrameDataButton)
        self.dfHelpButton = QtWidgets.QPushButton(self.tab_11)
        self.dfHelpButton.setMinimumSize(QtCore.QSize(60, 0))
        self.dfHelpButton.setMaximumSize(QtCore.QSize(60, 16777215))
        self.dfHelpButton.setObjectName("dfHelpButton")
        self.horizontalLayout_51.addWidget(self.dfHelpButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_51)
        self.horizontalLayout_44 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_44.setObjectName("horizontalLayout_44")
        self.dfRedactTopLinesLabel = QtWidgets.QLabel(self.tab_11)
        self.dfRedactTopLinesLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.dfRedactTopLinesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.dfRedactTopLinesLabel.setObjectName("dfRedactTopLinesLabel")
        self.horizontalLayout_44.addWidget(self.dfRedactTopLinesLabel)
        self.dfTopRedactSpinBox = QtWidgets.QSpinBox(self.tab_11)
        self.dfTopRedactSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.dfTopRedactSpinBox.setMaximum(9999)
        self.dfTopRedactSpinBox.setObjectName("dfTopRedactSpinBox")
        self.horizontalLayout_44.addWidget(self.dfTopRedactSpinBox)
        self.dfBottomRedactSpinBox = QtWidgets.QSpinBox(self.tab_11)
        self.dfBottomRedactSpinBox.setMaximum(9999)
        self.dfBottomRedactSpinBox.setObjectName("dfBottomRedactSpinBox")
        self.horizontalLayout_44.addWidget(self.dfBottomRedactSpinBox)
        self.dfRedactBottomLinesLabel = QtWidgets.QLabel(self.tab_11)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dfRedactBottomLinesLabel.sizePolicy().hasHeightForWidth())
        self.dfRedactBottomLinesLabel.setSizePolicy(sizePolicy)
        self.dfRedactBottomLinesLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.dfRedactBottomLinesLabel.setIndent(-1)
        self.dfRedactBottomLinesLabel.setObjectName("dfRedactBottomLinesLabel")
        self.horizontalLayout_44.addWidget(self.dfRedactBottomLinesLabel)
        self.dfShowRedactLinesCheckBox = QtWidgets.QCheckBox(self.tab_11)
        self.dfShowRedactLinesCheckBox.setObjectName("dfShowRedactLinesCheckBox")
        self.horizontalLayout_44.addWidget(self.dfShowRedactLinesCheckBox)
        self.verticalLayout_33.addLayout(self.horizontalLayout_44)
        self.horizontalLayout_52 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_52.setObjectName("horizontalLayout_52")
        self.dfRedactLeftColsLabel = QtWidgets.QLabel(self.tab_11)
        self.dfRedactLeftColsLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.dfRedactLeftColsLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.dfRedactLeftColsLabel.setObjectName("dfRedactLeftColsLabel")
        self.horizontalLayout_52.addWidget(self.dfRedactLeftColsLabel)
        self.dfLeftRedactSpinBox = QtWidgets.QSpinBox(self.tab_11)
        self.dfLeftRedactSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.dfLeftRedactSpinBox.setMaximum(9999)
        self.dfLeftRedactSpinBox.setObjectName("dfLeftRedactSpinBox")
        self.horizontalLayout_52.addWidget(self.dfLeftRedactSpinBox)
        self.dfRightRedactSpinBox = QtWidgets.QSpinBox(self.tab_11)
        self.dfRightRedactSpinBox.setMaximum(9999)
        self.dfRightRedactSpinBox.setObjectName("dfRightRedactSpinBox")
        self.horizontalLayout_52.addWidget(self.dfRightRedactSpinBox)
        self.dfRedactRightColsLabel = QtWidgets.QLabel(self.tab_11)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dfRedactRightColsLabel.sizePolicy().hasHeightForWidth())
        self.dfRedactRightColsLabel.setSizePolicy(sizePolicy)
        self.dfRedactRightColsLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.dfRedactRightColsLabel.setIndent(-1)
        self.dfRedactRightColsLabel.setObjectName("dfRedactRightColsLabel")
        self.horizontalLayout_52.addWidget(self.dfRedactRightColsLabel)
        self.dfShowVerticalRedactLinesCheckBox = QtWidgets.QCheckBox(self.tab_11)
        self.dfShowVerticalRedactLinesCheckBox.setObjectName("dfShowVerticalRedactLinesCheckBox")
        self.horizontalLayout_52.addWidget(self.dfShowVerticalRedactLinesCheckBox)
        self.verticalLayout_33.addLayout(self.horizontalLayout_52)
        self.horizontalLayout_46 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_46.setObjectName("horizontalLayout_46")
        self.dfAviSerTypeFileRadioButton = QtWidgets.QRadioButton(self.tab_11)
        self.dfAviSerTypeFileRadioButton.setChecked(True)
        self.dfAviSerTypeFileRadioButton.setObjectName("dfAviSerTypeFileRadioButton")
        self.horizontalLayout_46.addWidget(self.dfAviSerTypeFileRadioButton)
        self.dfFitsFileTypeRadioButton = QtWidgets.QRadioButton(self.tab_11)
        self.dfFitsFileTypeRadioButton.setObjectName("dfFitsFileTypeRadioButton")
        self.horizontalLayout_46.addWidget(self.dfFitsFileTypeRadioButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_46)
        self.horizontalLayout_47 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_47.setObjectName("horizontalLayout_47")
        self.dfSelectDarkVideoButton = QtWidgets.QPushButton(self.tab_11)
        self.dfSelectDarkVideoButton.setObjectName("dfSelectDarkVideoButton")
        self.horizontalLayout_47.addWidget(self.dfSelectDarkVideoButton)
        self.dfProcessDarkButton = QtWidgets.QPushButton(self.tab_11)
        self.dfProcessDarkButton.setEnabled(False)
        self.dfProcessDarkButton.setMinimumSize(QtCore.QSize(110, 0))
        self.dfProcessDarkButton.setMaximumSize(QtCore.QSize(110, 16777215))
        self.dfProcessDarkButton.setObjectName("dfProcessDarkButton")
        self.horizontalLayout_47.addWidget(self.dfProcessDarkButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_47)
        self.horizontalLayout_48 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_48.setObjectName("horizontalLayout_48")
        self.dfSelectFlatVideoButton = QtWidgets.QPushButton(self.tab_11)
        self.dfSelectFlatVideoButton.setObjectName("dfSelectFlatVideoButton")
        self.horizontalLayout_48.addWidget(self.dfSelectFlatVideoButton)
        self.dfProcessFlatButton = QtWidgets.QPushButton(self.tab_11)
        self.dfProcessFlatButton.setEnabled(False)
        self.dfProcessFlatButton.setMinimumSize(QtCore.QSize(110, 0))
        self.dfProcessFlatButton.setMaximumSize(QtCore.QSize(110, 16777215))
        self.dfProcessFlatButton.setObjectName("dfProcessFlatButton")
        self.horizontalLayout_48.addWidget(self.dfProcessFlatButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_48)
        self.dfAnalyzeDarkFlatPairButton = QtWidgets.QPushButton(self.tab_11)
        self.dfAnalyzeDarkFlatPairButton.setEnabled(True)
        self.dfAnalyzeDarkFlatPairButton.setObjectName("dfAnalyzeDarkFlatPairButton")
        self.verticalLayout_33.addWidget(self.dfAnalyzeDarkFlatPairButton)
        self.horizontalLayout_45 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_45.setObjectName("horizontalLayout_45")
        self.dfDarkThreshSpinBox = QtWidgets.QDoubleSpinBox(self.tab_11)
        self.dfDarkThreshSpinBox.setMaximum(9999.0)
        self.dfDarkThreshSpinBox.setSingleStep(0.5)
        self.dfDarkThreshSpinBox.setProperty("value", 2.0)
        self.dfDarkThreshSpinBox.setObjectName("dfDarkThreshSpinBox")
        self.horizontalLayout_45.addWidget(self.dfDarkThreshSpinBox)
        self.dfDarkThreshLabel = QtWidgets.QLabel(self.tab_11)
        self.dfDarkThreshLabel.setObjectName("dfDarkThreshLabel")
        self.horizontalLayout_45.addWidget(self.dfDarkThreshLabel)
        spacerItem14 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_45.addItem(spacerItem14)
        self.dfGainThreshSpinBox = QtWidgets.QDoubleSpinBox(self.tab_11)
        self.dfGainThreshSpinBox.setMaximum(10.0)
        self.dfGainThreshSpinBox.setSingleStep(0.05)
        self.dfGainThreshSpinBox.setProperty("value", 2.0)
        self.dfGainThreshSpinBox.setObjectName("dfGainThreshSpinBox")
        self.horizontalLayout_45.addWidget(self.dfGainThreshSpinBox)
        self.dfGainThreshLabel = QtWidgets.QLabel(self.tab_11)
        self.dfGainThreshLabel.setObjectName("dfGainThreshLabel")
        self.horizontalLayout_45.addWidget(self.dfGainThreshLabel)
        self.verticalLayout_33.addLayout(self.horizontalLayout_45)
        self.dfSaveAvailableFramesButton = QtWidgets.QPushButton(self.tab_11)
        self.dfSaveAvailableFramesButton.setObjectName("dfSaveAvailableFramesButton")
        self.verticalLayout_33.addWidget(self.dfSaveAvailableFramesButton)
        self.horizontalLayout_50 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_50.setObjectName("horizontalLayout_50")
        self.dfShowFlatFrameButton = QtWidgets.QPushButton(self.tab_11)
        self.dfShowFlatFrameButton.setObjectName("dfShowFlatFrameButton")
        self.horizontalLayout_50.addWidget(self.dfShowFlatFrameButton)
        self.dfShowGainFrameButton = QtWidgets.QPushButton(self.tab_11)
        self.dfShowGainFrameButton.setObjectName("dfShowGainFrameButton")
        self.horizontalLayout_50.addWidget(self.dfShowGainFrameButton)
        self.dfShowGainDefectFrameButton = QtWidgets.QPushButton(self.tab_11)
        self.dfShowGainDefectFrameButton.setObjectName("dfShowGainDefectFrameButton")
        self.horizontalLayout_50.addWidget(self.dfShowGainDefectFrameButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_50)
        self.horizontalLayout_49 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_49.setObjectName("horizontalLayout_49")
        self.dfShowDarkFrameButton = QtWidgets.QPushButton(self.tab_11)
        self.dfShowDarkFrameButton.setObjectName("dfShowDarkFrameButton")
        self.horizontalLayout_49.addWidget(self.dfShowDarkFrameButton)
        self.dfShowDarkDefectFrameButton = QtWidgets.QPushButton(self.tab_11)
        self.dfShowDarkDefectFrameButton.setObjectName("dfShowDarkDefectFrameButton")
        self.horizontalLayout_49.addWidget(self.dfShowDarkDefectFrameButton)
        self.verticalLayout_33.addLayout(self.horizontalLayout_49)
        self.gridLayout_8.addLayout(self.verticalLayout_33, 1, 1, 1, 1)
        spacerItem15 = QtWidgets.QSpacerItem(142, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem15, 1, 2, 1, 1)
        spacerItem16 = QtWidgets.QSpacerItem(20, 29, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_8.addItem(spacerItem16, 2, 1, 1, 1)
        self.tabWidget.addTab(self.tab_11, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.tab)
        self.gridLayout_5.setObjectName("gridLayout_5")
        spacerItem17 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem17, 1, 1, 1, 1)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.alignWithStarInfoButton = QtWidgets.QPushButton(self.tab)
        self.alignWithStarInfoButton.setObjectName("alignWithStarInfoButton")
        self.horizontalLayout_11.addWidget(self.alignWithStarInfoButton)
        self.alignWithTwoPointTrackInfoButton = QtWidgets.QPushButton(self.tab)
        self.alignWithTwoPointTrackInfoButton.setObjectName("alignWithTwoPointTrackInfoButton")
        self.horizontalLayout_11.addWidget(self.alignWithTwoPointTrackInfoButton)
        self.fourierAlignHelpButton = QtWidgets.QPushButton(self.tab)
        self.fourierAlignHelpButton.setObjectName("fourierAlignHelpButton")
        self.horizontalLayout_11.addWidget(self.fourierAlignHelpButton)
        self.verticalLayout_3.addLayout(self.horizontalLayout_11)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setSpacing(4)
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.finderRedactTopLinesLabel = QtWidgets.QLabel(self.tab)
        self.finderRedactTopLinesLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.finderRedactTopLinesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.finderRedactTopLinesLabel.setObjectName("finderRedactTopLinesLabel")
        self.horizontalLayout_15.addWidget(self.finderRedactTopLinesLabel)
        self.redactLinesTopEdit = QtWidgets.QLineEdit(self.tab)
        self.redactLinesTopEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.redactLinesTopEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.redactLinesTopEdit.setToolTip("")
        self.redactLinesTopEdit.setObjectName("redactLinesTopEdit")
        self.horizontalLayout_15.addWidget(self.redactLinesTopEdit)
        self.redactLinesBottomEdit = QtWidgets.QLineEdit(self.tab)
        self.redactLinesBottomEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.redactLinesBottomEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.redactLinesBottomEdit.setObjectName("redactLinesBottomEdit")
        self.horizontalLayout_15.addWidget(self.redactLinesBottomEdit)
        self.finderRedactBottomLinesLabel = QtWidgets.QLabel(self.tab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.finderRedactBottomLinesLabel.sizePolicy().hasHeightForWidth())
        self.finderRedactBottomLinesLabel.setSizePolicy(sizePolicy)
        self.finderRedactBottomLinesLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.finderRedactBottomLinesLabel.setIndent(-1)
        self.finderRedactBottomLinesLabel.setObjectName("finderRedactBottomLinesLabel")
        self.horizontalLayout_15.addWidget(self.finderRedactBottomLinesLabel)
        self.verticalLayout_3.addLayout(self.horizontalLayout_15)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        spacerItem18 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_16.addItem(spacerItem18)
        self.finderNumFramesLabel = QtWidgets.QLabel(self.tab)
        self.finderNumFramesLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.finderNumFramesLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.finderNumFramesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.finderNumFramesLabel.setObjectName("finderNumFramesLabel")
        self.horizontalLayout_16.addWidget(self.finderNumFramesLabel)
        self.numFramesToStackEdit = QtWidgets.QLineEdit(self.tab)
        self.numFramesToStackEdit.setMinimumSize(QtCore.QSize(60, 0))
        self.numFramesToStackEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.numFramesToStackEdit.setToolTip("")
        self.numFramesToStackEdit.setObjectName("numFramesToStackEdit")
        self.horizontalLayout_16.addWidget(self.numFramesToStackEdit)
        spacerItem19 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_16.addItem(spacerItem19)
        self.verticalLayout_3.addLayout(self.horizontalLayout_16)
        self.horizontalLayout_33 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_33.setObjectName("horizontalLayout_33")
        self.stackFramesButton = QtWidgets.QPushButton(self.tab)
        self.stackFramesButton.setObjectName("stackFramesButton")
        self.horizontalLayout_33.addWidget(self.stackFramesButton)
        self.fourierAlignButton = QtWidgets.QPushButton(self.tab)
        self.fourierAlignButton.setObjectName("fourierAlignButton")
        self.horizontalLayout_33.addWidget(self.fourierAlignButton)
        self.verticalLayout_3.addLayout(self.horizontalLayout_33)
        self.openFinderPushButton = QtWidgets.QPushButton(self.tab)
        self.openFinderPushButton.setMinimumSize(QtCore.QSize(400, 0))
        self.openFinderPushButton.setObjectName("openFinderPushButton")
        self.verticalLayout_3.addWidget(self.openFinderPushButton)
        self.stackerProgressBar = QtWidgets.QProgressBar(self.tab)
        self.stackerProgressBar.setProperty("value", 0)
        self.stackerProgressBar.setObjectName("stackerProgressBar")
        self.verticalLayout_3.addWidget(self.stackerProgressBar)
        self.finderMethodEdit = QtWidgets.QLineEdit(self.tab)
        self.finderMethodEdit.setReadOnly(True)
        self.finderMethodEdit.setObjectName("finderMethodEdit")
        self.verticalLayout_3.addWidget(self.finderMethodEdit)
        self.gridLayout_5.addLayout(self.verticalLayout_3, 0, 1, 1, 1)
        spacerItem20 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem20, 0, 2, 1, 1)
        spacerItem21 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem21, 0, 0, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.tab_7 = QtWidgets.QWidget()
        self.tab_7.setObjectName("tab_7")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab_7)
        self.gridLayout_6.setObjectName("gridLayout_6")
        spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem22, 0, 0, 1, 1)
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.flipImagesLeftToRightCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.flipImagesLeftToRightCheckBox.setObjectName("flipImagesLeftToRightCheckBox")
        self.verticalLayout_11.addWidget(self.flipImagesLeftToRightCheckBox)
        self.flipImagesTopToBottomCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.flipImagesTopToBottomCheckBox.setObjectName("flipImagesTopToBottomCheckBox")
        self.verticalLayout_11.addWidget(self.flipImagesTopToBottomCheckBox)
        self.line_3 = QtWidgets.QFrame(self.tab_7)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_3.setLineWidth(5)
        self.line_3.setMidLineWidth(5)
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setObjectName("line_3")
        self.verticalLayout_11.addWidget(self.line_3)
        self.cascadeCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.cascadeCheckBox.setMinimumSize(QtCore.QSize(0, 0))
        self.cascadeCheckBox.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.cascadeCheckBox.setSizeIncrement(QtCore.QSize(0, 0))
        self.cascadeCheckBox.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.cascadeCheckBox.setChecked(True)
        self.cascadeCheckBox.setObjectName("cascadeCheckBox")
        self.verticalLayout_11.addWidget(self.cascadeCheckBox)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.plotSymbolSizeLabel = QtWidgets.QLabel(self.tab_7)
        self.plotSymbolSizeLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.plotSymbolSizeLabel.setObjectName("plotSymbolSizeLabel")
        self.horizontalLayout_12.addWidget(self.plotSymbolSizeLabel)
        self.plotSymbolSizeSpinBox = QtWidgets.QSpinBox(self.tab_7)
        self.plotSymbolSizeSpinBox.setToolTip("")
        self.plotSymbolSizeSpinBox.setMinimum(1)
        self.plotSymbolSizeSpinBox.setMaximum(20)
        self.plotSymbolSizeSpinBox.setObjectName("plotSymbolSizeSpinBox")
        self.horizontalLayout_12.addWidget(self.plotSymbolSizeSpinBox)
        self.verticalLayout_11.addLayout(self.horizontalLayout_12)
        self.line_4 = QtWidgets.QFrame(self.tab_7)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_4.setLineWidth(5)
        self.line_4.setMidLineWidth(5)
        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_4.setObjectName("line_4")
        self.verticalLayout_11.addWidget(self.line_4)
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.gammaLabel = QtWidgets.QLabel(self.tab_7)
        self.gammaLabel.setObjectName("gammaLabel")
        self.horizontalLayout_14.addWidget(self.gammaLabel)
        self.gammaSettingOfCamera = QtWidgets.QDoubleSpinBox(self.tab_7)
        self.gammaSettingOfCamera.setMinimum(0.25)
        self.gammaSettingOfCamera.setMaximum(1.0)
        self.gammaSettingOfCamera.setSingleStep(0.05)
        self.gammaSettingOfCamera.setProperty("value", 1.0)
        self.gammaSettingOfCamera.setObjectName("gammaSettingOfCamera")
        self.horizontalLayout_14.addWidget(self.gammaSettingOfCamera)
        self.verticalLayout_11.addLayout(self.horizontalLayout_14)
        self.line_14 = QtWidgets.QFrame(self.tab_7)
        self.line_14.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_14.setLineWidth(5)
        self.line_14.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_14.setObjectName("line_14")
        self.verticalLayout_11.addWidget(self.line_14)
        self.loadNE3lookupTableCheckBox = QtWidgets.QCheckBox(self.tab_7)
        self.loadNE3lookupTableCheckBox.setObjectName("loadNE3lookupTableCheckBox")
        self.verticalLayout_11.addWidget(self.loadNE3lookupTableCheckBox)
        self.gridLayout_6.addLayout(self.verticalLayout_11, 0, 1, 1, 1)
        spacerItem23 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem23, 0, 2, 1, 1)
        spacerItem24 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem24, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_7, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.tab_2)
        self.gridLayout_7.setObjectName("gridLayout_7")
        spacerItem25 = QtWidgets.QSpacerItem(180, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem25, 0, 0, 1, 1)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.manualWcsButton = QtWidgets.QPushButton(self.tab_2)
        self.manualWcsButton.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.manualWcsButton.sizePolicy().hasHeightForWidth())
        self.manualWcsButton.setSizePolicy(sizePolicy)
        self.manualWcsButton.setMinimumSize(QtCore.QSize(0, 0))
        self.manualWcsButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.manualWcsButton.setObjectName("manualWcsButton")
        self.verticalLayout_8.addWidget(self.manualWcsButton)
        self.line = QtWidgets.QFrame(self.tab_2)
        self.line.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line.setLineWidth(5)
        self.line.setMidLineWidth(5)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.verticalLayout_8.addWidget(self.line)
        self.frameToFitsButton = QtWidgets.QPushButton(self.tab_2)
        self.frameToFitsButton.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frameToFitsButton.sizePolicy().hasHeightForWidth())
        self.frameToFitsButton.setSizePolicy(sizePolicy)
        self.frameToFitsButton.setMinimumSize(QtCore.QSize(150, 0))
        self.frameToFitsButton.setMaximumSize(QtCore.QSize(1677215, 16777215))
        self.frameToFitsButton.setObjectName("frameToFitsButton")
        self.verticalLayout_8.addWidget(self.frameToFitsButton)
        self.label_4 = QtWidgets.QLabel(self.tab_2)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_8.addWidget(self.label_4)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setSpacing(4)
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.wcsRedactTopLinesLabel = QtWidgets.QLabel(self.tab_2)
        self.wcsRedactTopLinesLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.wcsRedactTopLinesLabel.setObjectName("wcsRedactTopLinesLabel")
        self.horizontalLayout_8.addWidget(self.wcsRedactTopLinesLabel)
        self.wcsRedactLinesTopEdit = QtWidgets.QLineEdit(self.tab_2)
        self.wcsRedactLinesTopEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.wcsRedactLinesTopEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.wcsRedactLinesTopEdit.setObjectName("wcsRedactLinesTopEdit")
        self.horizontalLayout_8.addWidget(self.wcsRedactLinesTopEdit)
        self.wcsRedactLinesBottomEdit = QtWidgets.QLineEdit(self.tab_2)
        self.wcsRedactLinesBottomEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.wcsRedactLinesBottomEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.wcsRedactLinesBottomEdit.setObjectName("wcsRedactLinesBottomEdit")
        self.horizontalLayout_8.addWidget(self.wcsRedactLinesBottomEdit)
        self.wcsRedactBottomLinesLabel = QtWidgets.QLabel(self.tab_2)
        self.wcsRedactBottomLinesLabel.setObjectName("wcsRedactBottomLinesLabel")
        self.horizontalLayout_8.addWidget(self.wcsRedactBottomLinesLabel)
        self.verticalLayout_8.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setSpacing(4)
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.pixelHeightLabel = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pixelHeightLabel.sizePolicy().hasHeightForWidth())
        self.pixelHeightLabel.setSizePolicy(sizePolicy)
        self.pixelHeightLabel.setMinimumSize(QtCore.QSize(90, 0))
        self.pixelHeightLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.pixelHeightLabel.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.pixelHeightLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.pixelHeightLabel.setObjectName("pixelHeightLabel")
        self.horizontalLayout_7.addWidget(self.pixelHeightLabel)
        self.pixelHeightEdit = QtWidgets.QLineEdit(self.tab_2)
        self.pixelHeightEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.pixelHeightEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.pixelHeightEdit.setObjectName("pixelHeightEdit")
        self.horizontalLayout_7.addWidget(self.pixelHeightEdit)
        self.pixelWidthEdit = QtWidgets.QLineEdit(self.tab_2)
        self.pixelWidthEdit.setMinimumSize(QtCore.QSize(40, 0))
        self.pixelWidthEdit.setMaximumSize(QtCore.QSize(40, 16777215))
        self.pixelWidthEdit.setObjectName("pixelWidthEdit")
        self.horizontalLayout_7.addWidget(self.pixelWidthEdit)
        self.pixelWidthLabel = QtWidgets.QLabel(self.tab_2)
        self.pixelWidthLabel.setMinimumSize(QtCore.QSize(90, 0))
        self.pixelWidthLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.pixelWidthLabel.setObjectName("pixelWidthLabel")
        self.horizontalLayout_7.addWidget(self.pixelWidthLabel)
        self.verticalLayout_8.addLayout(self.horizontalLayout_7)
        self.line_2 = QtWidgets.QFrame(self.tab_2)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_2.setLineWidth(5)
        self.line_2.setMidLineWidth(5)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_8.addWidget(self.line_2)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSpacing(0)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.ucac4Label = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ucac4Label.sizePolicy().hasHeightForWidth())
        self.ucac4Label.setSizePolicy(sizePolicy)
        self.ucac4Label.setObjectName("ucac4Label")
        self.horizontalLayout_5.addWidget(self.ucac4Label)
        self.starIdEdit = QtWidgets.QLineEdit(self.tab_2)
        self.starIdEdit.setObjectName("starIdEdit")
        self.horizontalLayout_5.addWidget(self.starIdEdit)
        self.queryVizierButton = QtWidgets.QPushButton(self.tab_2)
        self.queryVizierButton.setObjectName("queryVizierButton")
        self.horizontalLayout_5.addWidget(self.queryVizierButton)
        self.verticalLayout_8.addLayout(self.horizontalLayout_5)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setSpacing(0)
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.coordinatesEdit = QtWidgets.QLineEdit(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.coordinatesEdit.sizePolicy().hasHeightForWidth())
        self.coordinatesEdit.setSizePolicy(sizePolicy)
        self.coordinatesEdit.setMinimumSize(QtCore.QSize(260, 0))
        self.coordinatesEdit.setObjectName("coordinatesEdit")
        self.horizontalLayout_13.addWidget(self.coordinatesEdit)
        self.saveTargetLocButton = QtWidgets.QPushButton(self.tab_2)
        self.saveTargetLocButton.setEnabled(False)
        self.saveTargetLocButton.setObjectName("saveTargetLocButton")
        self.horizontalLayout_13.addWidget(self.saveTargetLocButton)
        self.verticalLayout_8.addLayout(self.horizontalLayout_13)
        self.gridLayout_7.addLayout(self.verticalLayout_8, 0, 1, 1, 1)
        spacerItem26 = QtWidgets.QSpacerItem(180, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem26, 0, 2, 1, 1)
        spacerItem27 = QtWidgets.QSpacerItem(20, 26, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem27, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_2, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.gridLayout_9 = QtWidgets.QGridLayout(self.tab_4)
        self.gridLayout_9.setObjectName("gridLayout_9")
        spacerItem28 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_9.addItem(spacerItem28, 0, 2, 1, 1)
        spacerItem29 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_9.addItem(spacerItem29, 0, 0, 1, 1)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.toolButton_2 = QtWidgets.QToolButton(self.tab_4)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.toolButton_2.setFont(font)
        self.toolButton_2.setObjectName("toolButton_2")
        self.verticalLayout_7.addWidget(self.toolButton_2)
        self.twoPointHelpButton = QtWidgets.QToolButton(self.tab_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.twoPointHelpButton.sizePolicy().hasHeightForWidth())
        self.twoPointHelpButton.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.twoPointHelpButton.setFont(font)
        self.twoPointHelpButton.setObjectName("twoPointHelpButton")
        self.verticalLayout_7.addWidget(self.twoPointHelpButton)
        self.transportHelp = QtWidgets.QToolButton(self.tab_4)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.transportHelp.sizePolicy().hasHeightForWidth())
        self.transportHelp.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportHelp.setFont(font)
        self.transportHelp.setObjectName("transportHelp")
        self.verticalLayout_7.addWidget(self.transportHelp)
        self.documentationPushButton = QtWidgets.QPushButton(self.tab_4)
        self.documentationPushButton.setObjectName("documentationPushButton")
        self.verticalLayout_7.addWidget(self.documentationPushButton)
        self.gridLayout_9.addLayout(self.verticalLayout_7, 0, 1, 1, 1)
        spacerItem30 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_9.addItem(spacerItem30, 1, 1, 1, 1)
        self.tabWidget.addTab(self.tab_4, "")
        self.tab_9 = QtWidgets.QWidget()
        self.tab_9.setObjectName("tab_9")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_9)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout()
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        spacerItem31 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_17.addItem(spacerItem31)
        self.appSizeToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.appSizeToolButton.setFont(font)
        self.appSizeToolButton.setObjectName("appSizeToolButton")
        self.horizontalLayout_17.addWidget(self.appSizeToolButton)
        spacerItem32 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_17.addItem(spacerItem32)
        self.verticalLayout_19.addLayout(self.horizontalLayout_17)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        spacerItem33 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem33)
        self.frame_2 = QtWidgets.QFrame(self.tab_9)
        self.frame_2.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")
        self.horizontalLayout_30 = QtWidgets.QHBoxLayout(self.frame_2)
        self.horizontalLayout_30.setObjectName("horizontalLayout_30")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout()
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.defAppSize51RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize51RadioButton.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.defAppSize51RadioButton.setChecked(True)
        self.defAppSize51RadioButton.setObjectName("defAppSize51RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize51RadioButton)
        self.defAppSize41RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize41RadioButton.setObjectName("defAppSize41RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize41RadioButton)
        self.defAppSize31RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize31RadioButton.setObjectName("defAppSize31RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize31RadioButton)
        self.defAppSize21RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize21RadioButton.setObjectName("defAppSize21RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize21RadioButton)
        self.defAppSize11RadioButton = QtWidgets.QRadioButton(self.frame_2)
        self.defAppSize11RadioButton.setObjectName("defAppSize11RadioButton")
        self.verticalLayout_18.addWidget(self.defAppSize11RadioButton)
        self.horizontalLayout_30.addLayout(self.verticalLayout_18)
        self.horizontalLayout_10.addWidget(self.frame_2)
        spacerItem34 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem34)
        self.verticalLayout_19.addLayout(self.horizontalLayout_10)
        self.gridLayout.addLayout(self.verticalLayout_19, 0, 0, 1, 1)
        self.verticalLayout_21 = QtWidgets.QVBoxLayout()
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.horizontalLayout_25 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_25.setObjectName("horizontalLayout_25")
        spacerItem35 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem35)
        self.sigmaLevelToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.sigmaLevelToolButton.setFont(font)
        self.sigmaLevelToolButton.setObjectName("sigmaLevelToolButton")
        self.horizontalLayout_25.addWidget(self.sigmaLevelToolButton)
        spacerItem36 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem36)
        self.verticalLayout_21.addLayout(self.horizontalLayout_25)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.frame = QtWidgets.QFrame(self.tab_9)
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")
        self.horizontalLayout_31 = QtWidgets.QHBoxLayout(self.frame)
        self.horizontalLayout_31.setObjectName("horizontalLayout_31")
        spacerItem37 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem37)
        self.verticalLayout_20 = QtWidgets.QVBoxLayout()
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.oneSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.oneSigmaRadioButton.setChecked(False)
        self.oneSigmaRadioButton.setObjectName("oneSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.oneSigmaRadioButton)
        self.twoSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.twoSigmaRadioButton.setChecked(True)
        self.twoSigmaRadioButton.setObjectName("twoSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.twoSigmaRadioButton)
        self.threeSigmaRadioButton = QtWidgets.QRadioButton(self.frame)
        self.threeSigmaRadioButton.setObjectName("threeSigmaRadioButton")
        self.verticalLayout_20.addWidget(self.threeSigmaRadioButton)
        self.horizontalLayout_31.addLayout(self.verticalLayout_20)
        spacerItem38 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem38)
        self.horizontalLayout_21.addWidget(self.frame)
        self.verticalLayout_21.addLayout(self.horizontalLayout_21)
        self.gridLayout.addLayout(self.verticalLayout_21, 0, 1, 1, 1)
        self.verticalLayout_24 = QtWidgets.QVBoxLayout()
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.horizontalLayout_29 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_29.setObjectName("horizontalLayout_29")
        spacerItem39 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem39)
        self.defaultMaskRadiusToolButton = QtWidgets.QToolButton(self.tab_9)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.defaultMaskRadiusToolButton.setFont(font)
        self.defaultMaskRadiusToolButton.setObjectName("defaultMaskRadiusToolButton")
        self.horizontalLayout_29.addWidget(self.defaultMaskRadiusToolButton)
        spacerItem40 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem40)
        self.verticalLayout_24.addLayout(self.horizontalLayout_29)
        self.horizontalLayout_27 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_27.setObjectName("horizontalLayout_27")
        spacerItem41 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem41)
        self.frame_3 = QtWidgets.QFrame(self.tab_9)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")
        self.horizontalLayout_32 = QtWidgets.QHBoxLayout(self.frame_3)
        self.horizontalLayout_32.setObjectName("horizontalLayout_32")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout()
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.radius20radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius20radioButton.setObjectName("radius20radioButton")
        self.verticalLayout_23.addWidget(self.radius20radioButton)
        self.radius24radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius24radioButton.setObjectName("radius24radioButton")
        self.verticalLayout_23.addWidget(self.radius24radioButton)
        self.radius32radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius32radioButton.setChecked(True)
        self.radius32radioButton.setObjectName("radius32radioButton")
        self.verticalLayout_23.addWidget(self.radius32radioButton)
        self.radius40radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius40radioButton.setObjectName("radius40radioButton")
        self.verticalLayout_23.addWidget(self.radius40radioButton)
        self.radius45radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius45radioButton.setObjectName("radius45radioButton")
        self.verticalLayout_23.addWidget(self.radius45radioButton)
        self.radius53radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius53radioButton.setObjectName("radius53radioButton")
        self.verticalLayout_23.addWidget(self.radius53radioButton)
        self.radius68radioButton = QtWidgets.QRadioButton(self.frame_3)
        self.radius68radioButton.setObjectName("radius68radioButton")
        self.verticalLayout_23.addWidget(self.radius68radioButton)
        self.horizontalLayout_32.addLayout(self.verticalLayout_23)
        self.horizontalLayout_27.addWidget(self.frame_3)
        spacerItem42 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem42)
        self.verticalLayout_24.addLayout(self.horizontalLayout_27)
        self.gridLayout.addLayout(self.verticalLayout_24, 0, 2, 1, 1)
        self.tabWidget.addTab(self.tab_9, "")
        self.tab_10 = QtWidgets.QWidget()
        self.tab_10.setObjectName("tab_10")
        self.gridLayout_13 = QtWidgets.QGridLayout(self.tab_10)
        self.gridLayout_13.setObjectName("gridLayout_13")
        spacerItem43 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_13.addItem(spacerItem43, 0, 1, 1, 1)
        spacerItem44 = QtWidgets.QSpacerItem(157, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_13.addItem(spacerItem44, 1, 0, 1, 1)
        self.horizontalLayout_43 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_43.setObjectName("horizontalLayout_43")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout()
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.lineNoiseFilterCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.lineNoiseFilterCheckBox.setEnabled(True)
        self.lineNoiseFilterCheckBox.setObjectName("lineNoiseFilterCheckBox")
        self.verticalLayout_26.addWidget(self.lineNoiseFilterCheckBox)
        self.line_11 = QtWidgets.QFrame(self.tab_10)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_11.setLineWidth(4)
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setObjectName("line_11")
        self.verticalLayout_26.addWidget(self.line_11)
        self.horizontalRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.horizontalRadioButton.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.horizontalRadioButton.setChecked(True)
        self.horizontalRadioButton.setObjectName("horizontalRadioButton")
        self.verticalLayout_26.addWidget(self.horizontalRadioButton)
        self.verticalRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.verticalRadioButton.setObjectName("verticalRadioButton")
        self.verticalLayout_26.addWidget(self.verticalRadioButton)
        self.bothRadioButton = QtWidgets.QRadioButton(self.tab_10)
        self.bothRadioButton.setObjectName("bothRadioButton")
        self.verticalLayout_26.addWidget(self.bothRadioButton)
        self.line_12 = QtWidgets.QFrame(self.tab_10)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_12.setLineWidth(4)
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setObjectName("line_12")
        self.verticalLayout_26.addWidget(self.line_12)
        self.horizontalLayout_38 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_38.setObjectName("horizontalLayout_38")
        self.upperTimestampLineLabel = QtWidgets.QLabel(self.tab_10)
        self.upperTimestampLineLabel.setObjectName("upperTimestampLineLabel")
        self.horizontalLayout_38.addWidget(self.upperTimestampLineLabel)
        self.upperTimestampMedianSpinBox = QtWidgets.QSpinBox(self.tab_10)
        self.upperTimestampMedianSpinBox.setEnabled(False)
        self.upperTimestampMedianSpinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.upperTimestampMedianSpinBox.setMaximum(99999)
        self.upperTimestampMedianSpinBox.setObjectName("upperTimestampMedianSpinBox")
        self.horizontalLayout_38.addWidget(self.upperTimestampMedianSpinBox)
        self.verticalLayout_26.addLayout(self.horizontalLayout_38)
        self.horizontalLayout_39 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_39.setObjectName("horizontalLayout_39")
        self.lowerTimestampLineLabel = QtWidgets.QLabel(self.tab_10)
        self.lowerTimestampLineLabel.setObjectName("lowerTimestampLineLabel")
        self.horizontalLayout_39.addWidget(self.lowerTimestampLineLabel)
        self.lowerTimestampMedianSpinBox = QtWidgets.QSpinBox(self.tab_10)
        self.lowerTimestampMedianSpinBox.setEnabled(False)
        self.lowerTimestampMedianSpinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.lowerTimestampMedianSpinBox.setMaximum(99999)
        self.lowerTimestampMedianSpinBox.setObjectName("lowerTimestampMedianSpinBox")
        self.horizontalLayout_39.addWidget(self.lowerTimestampMedianSpinBox)
        self.verticalLayout_26.addLayout(self.horizontalLayout_39)
        self.showMedianProfileButton = QtWidgets.QPushButton(self.tab_10)
        self.showMedianProfileButton.setEnabled(False)
        self.showMedianProfileButton.setObjectName("showMedianProfileButton")
        self.verticalLayout_26.addWidget(self.showMedianProfileButton)
        self.horizontalLayout_43.addLayout(self.verticalLayout_26)
        self.line_13 = QtWidgets.QFrame(self.tab_10)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_13.setLineWidth(5)
        self.line_13.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_13.setObjectName("line_13")
        self.horizontalLayout_43.addWidget(self.line_13)
        self.verticalLayout_32 = QtWidgets.QVBoxLayout()
        self.verticalLayout_32.setObjectName("verticalLayout_32")
        self.verticalLayout_31 = QtWidgets.QVBoxLayout()
        self.verticalLayout_31.setObjectName("verticalLayout_31")
        self.verticalLayout_30 = QtWidgets.QVBoxLayout()
        self.verticalLayout_30.setObjectName("verticalLayout_30")
        self.verticalLayout_29 = QtWidgets.QVBoxLayout()
        self.verticalLayout_29.setObjectName("verticalLayout_29")
        self.verticalLayout_27 = QtWidgets.QVBoxLayout()
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        self.horizontalLayout_41 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_41.setObjectName("horizontalLayout_41")
        self.horizontalLayout_34 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_34.setSpacing(4)
        self.horizontalLayout_34.setObjectName("horizontalLayout_34")
        self.horizontalLayout_41.addLayout(self.horizontalLayout_34)
        self.verticalLayout_27.addLayout(self.horizontalLayout_41)
        self.lunarCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.lunarCheckBox.setObjectName("lunarCheckBox")
        self.verticalLayout_27.addWidget(self.lunarCheckBox)
        self.verticalLayout_29.addLayout(self.verticalLayout_27)
        self.useYellowMaskCheckBox = QtWidgets.QCheckBox(self.tab_10)
        self.useYellowMaskCheckBox.setObjectName("useYellowMaskCheckBox")
        self.verticalLayout_29.addWidget(self.useYellowMaskCheckBox)
        self.verticalLayout_30.addLayout(self.verticalLayout_29)
        self.view3DButton = QtWidgets.QPushButton(self.tab_10)
        self.view3DButton.setObjectName("view3DButton")
        self.verticalLayout_30.addWidget(self.view3DButton)
        self.verticalLayout_31.addLayout(self.verticalLayout_30)
        self.allowNewVersionPopupCheckbox = QtWidgets.QCheckBox(self.tab_10)
        self.allowNewVersionPopupCheckbox.setObjectName("allowNewVersionPopupCheckbox")
        self.verticalLayout_31.addWidget(self.allowNewVersionPopupCheckbox)
        self.horizontalLayout_42 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_42.setObjectName("horizontalLayout_42")
        self.verticalLayout_31.addLayout(self.horizontalLayout_42)
        self.verticalLayout_32.addLayout(self.verticalLayout_31)
        self.tmeSearch3x3radioButton = QtWidgets.QRadioButton(self.tab_10)
        self.tmeSearch3x3radioButton.setMaximumSize(QtCore.QSize(200, 16777215))
        self.tmeSearch3x3radioButton.setChecked(True)
        self.tmeSearch3x3radioButton.setObjectName("tmeSearch3x3radioButton")
        self.verticalLayout_32.addWidget(self.tmeSearch3x3radioButton)
        self.tmeSearch5x5radioButton = QtWidgets.QRadioButton(self.tab_10)
        self.tmeSearch5x5radioButton.setMinimumSize(QtCore.QSize(0, 0))
        self.tmeSearch5x5radioButton.setMaximumSize(QtCore.QSize(200, 16777215))
        self.tmeSearch5x5radioButton.setObjectName("tmeSearch5x5radioButton")
        self.verticalLayout_32.addWidget(self.tmeSearch5x5radioButton)
        self.tmeSearch7x7radioButton = QtWidgets.QRadioButton(self.tab_10)
        self.tmeSearch7x7radioButton.setMaximumSize(QtCore.QSize(200, 16777215))
        self.tmeSearch7x7radioButton.setObjectName("tmeSearch7x7radioButton")
        self.verticalLayout_32.addWidget(self.tmeSearch7x7radioButton)
        spacerItem45 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_32.addItem(spacerItem45)
        self.horizontalLayout_43.addLayout(self.verticalLayout_32)
        self.gridLayout_13.addLayout(self.horizontalLayout_43, 1, 1, 2, 1)
        spacerItem46 = QtWidgets.QSpacerItem(157, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_13.addItem(spacerItem46, 2, 2, 1, 1)
        spacerItem47 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_13.addItem(spacerItem47, 3, 1, 1, 1)
        self.tabWidget.addTab(self.tab_10, "")
        self.tab_8 = QtWidgets.QWidget()
        self.tab_8.setObjectName("tab_8")
        self.gridLayout_10 = QtWidgets.QGridLayout(self.tab_8)
        self.gridLayout_10.setObjectName("gridLayout_10")
        self.gridLayout_11 = QtWidgets.QGridLayout()
        self.gridLayout_11.setObjectName("gridLayout_11")
        self.horizontalLayout_37 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_37.setObjectName("horizontalLayout_37")
        spacerItem48 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_37.addItem(spacerItem48)
        self.stopFrameLabel = QtWidgets.QLabel(self.tab_8)
        self.stopFrameLabel.setObjectName("stopFrameLabel")
        self.horizontalLayout_37.addWidget(self.stopFrameLabel)
        self.stopFrameEdit = QtWidgets.QLineEdit(self.tab_8)
        self.stopFrameEdit.setObjectName("stopFrameEdit")
        self.horizontalLayout_37.addWidget(self.stopFrameEdit)
        spacerItem49 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_37.addItem(spacerItem49)
        self.gridLayout_11.addLayout(self.horizontalLayout_37, 4, 0, 1, 1)
        self.horizontalLayout_40 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_40.setObjectName("horizontalLayout_40")
        spacerItem50 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_40.addItem(spacerItem50)
        self.startFrameLabel = QtWidgets.QLabel(self.tab_8)
        self.startFrameLabel.setObjectName("startFrameLabel")
        self.horizontalLayout_40.addWidget(self.startFrameLabel)
        self.startFrameEdit = QtWidgets.QLineEdit(self.tab_8)
        self.startFrameEdit.setObjectName("startFrameEdit")
        self.horizontalLayout_40.addWidget(self.startFrameEdit)
        spacerItem51 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_40.addItem(spacerItem51)
        self.gridLayout_11.addLayout(self.horizontalLayout_40, 3, 0, 1, 1)
        self.line_8 = QtWidgets.QFrame(self.tab_8)
        self.line_8.setMinimumSize(QtCore.QSize(0, 4))
        self.line_8.setBaseSize(QtCore.QSize(0, 0))
        self.line_8.setAutoFillBackground(False)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Raised)
        self.line_8.setLineWidth(2)
        self.line_8.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_8.setObjectName("line_8")
        self.gridLayout_11.addWidget(self.line_8, 1, 0, 1, 1)
        spacerItem52 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_11.addItem(spacerItem52, 6, 0, 1, 1)
        self.verticalLayout_22 = QtWidgets.QVBoxLayout()
        self.verticalLayout_22.setObjectName("verticalLayout_22")
        self.activateTimestampRemovalButton = QtWidgets.QPushButton(self.tab_8)
        self.activateTimestampRemovalButton.setEnabled(True)
        self.activateTimestampRemovalButton.setObjectName("activateTimestampRemovalButton")
        self.verticalLayout_22.addWidget(self.activateTimestampRemovalButton)
        self.cmosShowRedactionLinesCheckBox = QtWidgets.QCheckBox(self.tab_8)
        self.cmosShowRedactionLinesCheckBox.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.cmosShowRedactionLinesCheckBox.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.cmosShowRedactionLinesCheckBox.setChecked(True)
        self.cmosShowRedactionLinesCheckBox.setObjectName("cmosShowRedactionLinesCheckBox")
        self.verticalLayout_22.addWidget(self.cmosShowRedactionLinesCheckBox)
        self.verticalLayout_12 = QtWidgets.QVBoxLayout()
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.horizontalLayout_35 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_35.setObjectName("horizontalLayout_35")
        spacerItem53 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_35.addItem(spacerItem53)
        self.upperTimestampPixelLabel = QtWidgets.QLabel(self.tab_8)
        self.upperTimestampPixelLabel.setObjectName("upperTimestampPixelLabel")
        self.horizontalLayout_35.addWidget(self.upperTimestampPixelLabel)
        self.upperTimestampPixelSpinBox = QtWidgets.QSpinBox(self.tab_8)
        self.upperTimestampPixelSpinBox.setEnabled(False)
        self.upperTimestampPixelSpinBox.setMaximum(99999)
        self.upperTimestampPixelSpinBox.setObjectName("upperTimestampPixelSpinBox")
        self.horizontalLayout_35.addWidget(self.upperTimestampPixelSpinBox)
        spacerItem54 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_35.addItem(spacerItem54)
        self.verticalLayout_12.addLayout(self.horizontalLayout_35)
        self.horizontalLayout_36 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_36.setObjectName("horizontalLayout_36")
        spacerItem55 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_36.addItem(spacerItem55)
        self.lowerTimestampPixelLabel = QtWidgets.QLabel(self.tab_8)
        self.lowerTimestampPixelLabel.setObjectName("lowerTimestampPixelLabel")
        self.horizontalLayout_36.addWidget(self.lowerTimestampPixelLabel)
        self.lowerTimestampPixelSpinBox = QtWidgets.QSpinBox(self.tab_8)
        self.lowerTimestampPixelSpinBox.setEnabled(False)
        self.lowerTimestampPixelSpinBox.setMaximum(99999)
        self.lowerTimestampPixelSpinBox.setObjectName("lowerTimestampPixelSpinBox")
        self.horizontalLayout_36.addWidget(self.lowerTimestampPixelSpinBox)
        spacerItem56 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_36.addItem(spacerItem56)
        self.verticalLayout_12.addLayout(self.horizontalLayout_36)
        self.verticalLayout_22.addLayout(self.verticalLayout_12)
        self.gridLayout_11.addLayout(self.verticalLayout_22, 0, 0, 1, 1)
        self.buildDarkAndNoiseFramesButton = QtWidgets.QPushButton(self.tab_8)
        self.buildDarkAndNoiseFramesButton.setEnabled(True)
        self.buildDarkAndNoiseFramesButton.setObjectName("buildDarkAndNoiseFramesButton")
        self.gridLayout_11.addWidget(self.buildDarkAndNoiseFramesButton, 5, 0, 1, 1)
        self.gridLayout_10.addLayout(self.gridLayout_11, 0, 1, 2, 1)
        spacerItem57 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_10.addItem(spacerItem57, 0, 0, 1, 1)
        spacerItem58 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_10.addItem(spacerItem58, 0, 4, 1, 1)
        self.line_9 = QtWidgets.QFrame(self.tab_8)
        self.line_9.setSizeIncrement(QtCore.QSize(0, 0))
        self.line_9.setBaseSize(QtCore.QSize(0, 0))
        self.line_9.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_9.setLineWidth(10)
        self.line_9.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_9.setObjectName("line_9")
        self.gridLayout_10.addWidget(self.line_9, 0, 2, 2, 1)
        self.verticalLayout_25 = QtWidgets.QVBoxLayout()
        self.verticalLayout_25.setObjectName("verticalLayout_25")
        self.pixelPanelInfoButton = QtWidgets.QPushButton(self.tab_8)
        self.pixelPanelInfoButton.setEnabled(True)
        self.pixelPanelInfoButton.setObjectName("pixelPanelInfoButton")
        self.verticalLayout_25.addWidget(self.pixelPanelInfoButton)
        self.showBrightAndDarkPixelsButton = QtWidgets.QPushButton(self.tab_8)
        self.showBrightAndDarkPixelsButton.setObjectName("showBrightAndDarkPixelsButton")
        self.verticalLayout_25.addWidget(self.showBrightAndDarkPixelsButton)
        self.showNoisyAndDeadPixelsButton = QtWidgets.QPushButton(self.tab_8)
        self.showNoisyAndDeadPixelsButton.setObjectName("showNoisyAndDeadPixelsButton")
        self.verticalLayout_25.addWidget(self.showNoisyAndDeadPixelsButton)
        self.buildPixelCorrectionTabelButton = QtWidgets.QPushButton(self.tab_8)
        self.buildPixelCorrectionTabelButton.setObjectName("buildPixelCorrectionTabelButton")
        self.verticalLayout_25.addWidget(self.buildPixelCorrectionTabelButton)
        self.savePixelCorrectionTableButton = QtWidgets.QPushButton(self.tab_8)
        self.savePixelCorrectionTableButton.setObjectName("savePixelCorrectionTableButton")
        self.verticalLayout_25.addWidget(self.savePixelCorrectionTableButton)
        self.loadPixelCorrectionTableButton = QtWidgets.QPushButton(self.tab_8)
        self.loadPixelCorrectionTableButton.setObjectName("loadPixelCorrectionTableButton")
        self.verticalLayout_25.addWidget(self.loadPixelCorrectionTableButton)
        self.applyPixelCorrectionsToCurrentImageButton = QtWidgets.QPushButton(self.tab_8)
        self.applyPixelCorrectionsToCurrentImageButton.setObjectName("applyPixelCorrectionsToCurrentImageButton")
        self.verticalLayout_25.addWidget(self.applyPixelCorrectionsToCurrentImageButton)
        self.applyPixelCorrectionsCheckBox = QtWidgets.QCheckBox(self.tab_8)
        self.applyPixelCorrectionsCheckBox.setObjectName("applyPixelCorrectionsCheckBox")
        self.verticalLayout_25.addWidget(self.applyPixelCorrectionsCheckBox)
        spacerItem59 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_25.addItem(spacerItem59)
        self.gridLayout_10.addLayout(self.verticalLayout_25, 0, 3, 2, 1)
        self.tabWidget.addTab(self.tab_8, "")
        self.verticalLayout_17.addWidget(self.tabWidget)
        self.layoutWidget1 = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_28 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_28.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_28.setObjectName("verticalLayout_28")
        self.frameView = ImageView(self.layoutWidget1)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(2)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frameView.sizePolicy().hasHeightForWidth())
        self.frameView.setSizePolicy(sizePolicy)
        self.frameView.setToolTip("")
        self.frameView.setObjectName("frameView")
        self.verticalLayout_28.addWidget(self.frameView)
        self.verticalLayout_16 = QtWidgets.QVBoxLayout()
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.horizontalLayout_19 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_19.setSpacing(0)
        self.horizontalLayout_19.setObjectName("horizontalLayout_19")
        self.applyDarkFlatCorrectionsCheckBox = QtWidgets.QCheckBox(self.layoutWidget1)
        self.applyDarkFlatCorrectionsCheckBox.setMaximumSize(QtCore.QSize(80, 16777215))
        self.applyDarkFlatCorrectionsCheckBox.setObjectName("applyDarkFlatCorrectionsCheckBox")
        self.horizontalLayout_19.addWidget(self.applyDarkFlatCorrectionsCheckBox)
        self.transportMaxLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportMaxLeft.setFont(font)
        self.transportMaxLeft.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)
        self.transportMaxLeft.setObjectName("transportMaxLeft")
        self.horizontalLayout_19.addWidget(self.transportMaxLeft)
        self.transportBigLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportBigLeft.setFont(font)
        self.transportBigLeft.setObjectName("transportBigLeft")
        self.horizontalLayout_19.addWidget(self.transportBigLeft)
        self.transportSmallLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportSmallLeft.setFont(font)
        self.transportSmallLeft.setObjectName("transportSmallLeft")
        self.horizontalLayout_19.addWidget(self.transportSmallLeft)
        self.transportMinusOneFrame = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportMinusOneFrame.setFont(font)
        self.transportMinusOneFrame.setAutoRepeat(True)
        self.transportMinusOneFrame.setObjectName("transportMinusOneFrame")
        self.horizontalLayout_19.addWidget(self.transportMinusOneFrame)
        self.transportPlayLeft = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportPlayLeft.setFont(font)
        self.transportPlayLeft.setObjectName("transportPlayLeft")
        self.horizontalLayout_19.addWidget(self.transportPlayLeft)
        self.transportAnalyze = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportAnalyze.setMaximumSize(QtCore.QSize(80, 16777215))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportAnalyze.setFont(font)
        self.transportAnalyze.setObjectName("transportAnalyze")
        self.horizontalLayout_19.addWidget(self.transportAnalyze)
        self.transportPause = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportPause.setMinimumSize(QtCore.QSize(0, 0))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportPause.setFont(font)
        self.transportPause.setObjectName("transportPause")
        self.horizontalLayout_19.addWidget(self.transportPause)
        self.transportPlayRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportPlayRight.setFont(font)
        self.transportPlayRight.setObjectName("transportPlayRight")
        self.horizontalLayout_19.addWidget(self.transportPlayRight)
        self.transportPlusOneFrame = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportPlusOneFrame.setFont(font)
        self.transportPlusOneFrame.setAutoRepeat(True)
        self.transportPlusOneFrame.setObjectName("transportPlusOneFrame")
        self.horizontalLayout_19.addWidget(self.transportPlusOneFrame)
        self.transportSmallRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportSmallRight.setFont(font)
        self.transportSmallRight.setObjectName("transportSmallRight")
        self.horizontalLayout_19.addWidget(self.transportSmallRight)
        self.transportBigRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportBigRight.setFont(font)
        self.transportBigRight.setObjectName("transportBigRight")
        self.horizontalLayout_19.addWidget(self.transportBigRight)
        self.transportMaxRight = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        self.transportMaxRight.setFont(font)
        self.transportMaxRight.setObjectName("transportMaxRight")
        self.horizontalLayout_19.addWidget(self.transportMaxRight)
        self.horizontalLayout_18.addLayout(self.horizontalLayout_19)
        self.verticalLayout_16.addLayout(self.horizontalLayout_18)
        self.verticalLayout_13 = QtWidgets.QVBoxLayout()
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.horizontalLayout_23 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_23.setObjectName("horizontalLayout_23")
        spacerItem60 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_23.addItem(spacerItem60)
        self.runPyote = QtWidgets.QCheckBox(self.layoutWidget1)
        self.runPyote.setObjectName("runPyote")
        self.horizontalLayout_23.addWidget(self.runPyote)
        self.horizontalLayout_20 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_20.setSpacing(0)
        self.horizontalLayout_20.setObjectName("horizontalLayout_20")
        spacerItem61 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_20.addItem(spacerItem61)
        self.transportCsv = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportCsv.setEnabled(False)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportCsv.setFont(font)
        self.transportCsv.setObjectName("transportCsv")
        self.horizontalLayout_20.addWidget(self.transportCsv)
        self.transportPlot = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportPlot.setEnabled(False)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportPlot.setFont(font)
        self.transportPlot.setObjectName("transportPlot")
        self.horizontalLayout_20.addWidget(self.transportPlot)
        self.transportCurrentFrameLabel = QtWidgets.QLabel(self.layoutWidget1)
        self.transportCurrentFrameLabel.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.transportCurrentFrameLabel.setObjectName("transportCurrentFrameLabel")
        self.horizontalLayout_20.addWidget(self.transportCurrentFrameLabel)
        self.currentFrameSpinBox = QtWidgets.QSpinBox(self.layoutWidget1)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.currentFrameSpinBox.sizePolicy().hasHeightForWidth())
        self.currentFrameSpinBox.setSizePolicy(sizePolicy)
        self.currentFrameSpinBox.setMinimumSize(QtCore.QSize(50, 0))
        self.currentFrameSpinBox.setMaximumSize(QtCore.QSize(50, 16777215))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.currentFrameSpinBox.setFont(font)
        self.currentFrameSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.currentFrameSpinBox.setFrame(True)
        self.currentFrameSpinBox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
        self.currentFrameSpinBox.setMaximum(999999)
        self.currentFrameSpinBox.setObjectName("currentFrameSpinBox")
        self.horizontalLayout_20.addWidget(self.currentFrameSpinBox)
        self.horizontalLayout_23.addLayout(self.horizontalLayout_20)
        self.horizontalLayout_22 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_22.setSpacing(0)
        self.horizontalLayout_22.setObjectName("horizontalLayout_22")
        self.setLastFrameButton = QtWidgets.QPushButton(self.layoutWidget1)
        self.setLastFrameButton.setMinimumSize(QtCore.QSize(0, 22))
        self.setLastFrameButton.setMaximumSize(QtCore.QSize(24, 22))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(False)
        font.setKerning(False)
        self.setLastFrameButton.setFont(font)
        self.setLastFrameButton.setObjectName("setLastFrameButton")
        self.horizontalLayout_22.addWidget(self.setLastFrameButton)
        self.stopAtFrameSpinBox = QtWidgets.QSpinBox(self.layoutWidget1)
        self.stopAtFrameSpinBox.setMinimumSize(QtCore.QSize(50, 0))
        self.stopAtFrameSpinBox.setMaximumSize(QtCore.QSize(50, 16777215))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.stopAtFrameSpinBox.setFont(font)
        self.stopAtFrameSpinBox.setToolTip("")
        self.stopAtFrameSpinBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.stopAtFrameSpinBox.setFrame(True)
        self.stopAtFrameSpinBox.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)
        self.stopAtFrameSpinBox.setMaximum(999999)
        self.stopAtFrameSpinBox.setObjectName("stopAtFrameSpinBox")
        self.horizontalLayout_22.addWidget(self.stopAtFrameSpinBox)
        self.transportStopAtFrameLabel = QtWidgets.QLabel(self.layoutWidget1)
        self.transportStopAtFrameLabel.setMinimumSize(QtCore.QSize(70, 0))
        self.transportStopAtFrameLabel.setObjectName("transportStopAtFrameLabel")
        self.horizontalLayout_22.addWidget(self.transportStopAtFrameLabel)
        self.label = QtWidgets.QLabel(self.layoutWidget1)
        self.label.setText("")
        self.label.setObjectName("label")
        self.horizontalLayout_22.addWidget(self.label)
        self.transportMark = QtWidgets.QToolButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportMark.setFont(font)
        self.transportMark.setObjectName("transportMark")
        self.horizontalLayout_22.addWidget(self.transportMark)
        self.transportReturnToMark = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportReturnToMark.setEnabled(False)
        self.transportReturnToMark.setMinimumSize(QtCore.QSize(110, 0))
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportReturnToMark.setFont(font)
        self.transportReturnToMark.setObjectName("transportReturnToMark")
        self.horizontalLayout_22.addWidget(self.transportReturnToMark)
        self.horizontalLayout_23.addLayout(self.horizontalLayout_22)
        self.transportClearData = QtWidgets.QToolButton(self.layoutWidget1)
        self.transportClearData.setEnabled(False)
        font = QtGui.QFont()
        font.setFamily(".SF NS Text")
        font.setPointSize(13)
        font.setBold(True)
        self.transportClearData.setFont(font)
        self.transportClearData.setObjectName("transportClearData")
        self.horizontalLayout_23.addWidget(self.transportClearData)
        spacerItem62 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_23.addItem(spacerItem62)
        self.verticalLayout_13.addLayout(self.horizontalLayout_23)
        self.horizontalLayout_24 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_24.setObjectName("horizontalLayout_24")
        self.verticalLayout_13.addLayout(self.horizontalLayout_24)
        self.verticalLayout_16.addLayout(self.verticalLayout_13)
        self.verticalLayout_28.addLayout(self.verticalLayout_16)
        self.splitterOne = QtWidgets.QSplitter(self.splitterThree)
        self.splitterOne.setOrientation(QtCore.Qt.Horizontal)
        self.splitterOne.setObjectName("splitterOne")
        self.layoutWidget2 = QtWidgets.QWidget(self.splitterOne)
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.layoutWidget2)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout()
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.textOut = QtWidgets.QTextEdit(self.layoutWidget2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.textOut.sizePolicy().hasHeightForWidth())
        self.textOut.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font.setPointSize(9)
        font.setBold(True)
        self.textOut.setFont(font)
        self.textOut.setToolTip("")
        self.textOut.setObjectName("textOut")
        self.verticalLayout_14.addWidget(self.textOut)
        self.verticalLayout_4.addLayout(self.verticalLayout_14)
        self.textOutLabel = QtWidgets.QLabel(self.layoutWidget2)
        self.textOutLabel.setObjectName("textOutLabel")
        self.verticalLayout_4.addWidget(self.textOutLabel)
        self.layoutWidget3 = QtWidgets.QWidget(self.splitterOne)
        self.layoutWidget3.setObjectName("layoutWidget3")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.layoutWidget3)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.thumbOneView = ImageView(self.layoutWidget3)
        self.thumbOneView.setObjectName("thumbOneView")
        self.verticalLayout_2.addWidget(self.thumbOneView)
        self.thumbnailOneLabel = QtWidgets.QLabel(self.layoutWidget3)
        self.thumbnailOneLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.thumbnailOneLabel.setObjectName("thumbnailOneLabel")
        self.verticalLayout_2.addWidget(self.thumbnailOneLabel)
        self.horizontalLayout_2.addLayout(self.verticalLayout_2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.thumbTwoView = ImageView(self.layoutWidget3)
        self.thumbTwoView.setObjectName("thumbTwoView")
        self.verticalLayout.addWidget(self.thumbTwoView)
        self.thumbnailTwoLabel = QtWidgets.QLabel(self.layoutWidget3)
        self.thumbnailTwoLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.thumbnailTwoLabel.setObjectName("thumbnailTwoLabel")
        self.verticalLayout.addWidget(self.thumbnailTwoLabel)
        self.horizontalLayout_2.addLayout(self.verticalLayout)
        self.gridLayout_12.addWidget(self.splitterThree, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionLike_special_settings = QtWidgets.QAction(MainWindow)
        self.actionLike_special_settings.setObjectName("actionLike_special_settings")
        self.actionOr_preferences = QtWidgets.QAction(MainWindow)
        self.actionOr_preferences.setObjectName("actionOr_preferences")
        self.actionOpen_AVI_SER_file = QtWidgets.QAction(MainWindow)
        self.actionOpen_AVI_SER_file.setObjectName("actionOpen_AVI_SER_file")

        self.retranslateUi(MainWindow)
        self.roiComboBox.setCurrentIndex(-1)
        self.tabWidget.setCurrentIndex(0)
        self.vtiSelectComboBox.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        MainWindow.setTabOrder(self.infoButton, self.fileInUseEdit)
        MainWindow.setTabOrder(self.fileInUseEdit, self.saveApertureState)
        MainWindow.setTabOrder(self.saveApertureState, self.startFrameEdit)
        MainWindow.setTabOrder(self.startFrameEdit, self.stopFrameEdit)
        MainWindow.setTabOrder(self.stopFrameEdit, self.thresh_inc_1)
        MainWindow.setTabOrder(self.thresh_inc_1, self.thresh_inc_10)
        MainWindow.setTabOrder(self.thresh_inc_10, self.thresh_inc_100)
        MainWindow.setTabOrder(self.thresh_inc_100, self.threshValueEdit)
        MainWindow.setTabOrder(self.threshValueEdit, self.viewFieldsCheckBox)
        MainWindow.setTabOrder(self.viewFieldsCheckBox, self.processAsFieldsCheckBox)
        MainWindow.setTabOrder(self.processAsFieldsCheckBox, self.topFieldFirstRadioButton)
        MainWindow.setTabOrder(self.topFieldFirstRadioButton, self.bottomFieldFirstRadioButton)
        MainWindow.setTabOrder(self.bottomFieldFirstRadioButton, self.showImageControlCheckBox)
        MainWindow.setTabOrder(self.showImageControlCheckBox, self.satPixelSpinBox)
        MainWindow.setTabOrder(self.satPixelSpinBox, self.demoMeanPushButton)
        MainWindow.setTabOrder(self.demoMeanPushButton, self.tabWidget)
        MainWindow.setTabOrder(self.tabWidget, self.readAviFileButton)
        MainWindow.setTabOrder(self.readAviFileButton, self.createAVIWCSfolderButton)
        MainWindow.setTabOrder(self.createAVIWCSfolderButton, self.selectAviWcsFolderButton)
        MainWindow.setTabOrder(self.selectAviWcsFolderButton, self.readFitsFolderButton)
        MainWindow.setTabOrder(self.readFitsFolderButton, self.metadataButton)
        MainWindow.setTabOrder(self.metadataButton, self.enableAdvFrameStatusDisplay)
        MainWindow.setTabOrder(self.enableAdvFrameStatusDisplay, self.openBmpPushButton)
        MainWindow.setTabOrder(self.openBmpPushButton, self.vtiSelectComboBox)
        MainWindow.setTabOrder(self.vtiSelectComboBox, self.loadCustomProfilesButton)
        MainWindow.setTabOrder(self.loadCustomProfilesButton, self.clearOcrDataButton)
        MainWindow.setTabOrder(self.clearOcrDataButton, self.hotPixelHelpButton)
        MainWindow.setTabOrder(self.hotPixelHelpButton, self.createHotPixelListButton)
        MainWindow.setTabOrder(self.createHotPixelListButton, self.loadHotPixelProfileButton)
        MainWindow.setTabOrder(self.loadHotPixelProfileButton, self.hotPixelEraseOff)
        MainWindow.setTabOrder(self.hotPixelEraseOff, self.alignWithStarInfoButton)
        MainWindow.setTabOrder(self.alignWithStarInfoButton, self.alignWithTwoPointTrackInfoButton)
        MainWindow.setTabOrder(self.alignWithTwoPointTrackInfoButton, self.redactLinesTopEdit)
        MainWindow.setTabOrder(self.redactLinesTopEdit, self.redactLinesBottomEdit)
        MainWindow.setTabOrder(self.redactLinesBottomEdit, self.numFramesToStackEdit)
        MainWindow.setTabOrder(self.numFramesToStackEdit, self.stackFramesButton)
        MainWindow.setTabOrder(self.stackFramesButton, self.finderMethodEdit)
        MainWindow.setTabOrder(self.finderMethodEdit, self.flipImagesLeftToRightCheckBox)
        MainWindow.setTabOrder(self.flipImagesLeftToRightCheckBox, self.flipImagesTopToBottomCheckBox)
        MainWindow.setTabOrder(self.flipImagesTopToBottomCheckBox, self.cascadeCheckBox)
        MainWindow.setTabOrder(self.cascadeCheckBox, self.plotSymbolSizeSpinBox)
        MainWindow.setTabOrder(self.plotSymbolSizeSpinBox, self.gammaSettingOfCamera)
        MainWindow.setTabOrder(self.gammaSettingOfCamera, self.manualWcsButton)
        MainWindow.setTabOrder(self.manualWcsButton, self.frameToFitsButton)
        MainWindow.setTabOrder(self.frameToFitsButton, self.wcsRedactLinesTopEdit)
        MainWindow.setTabOrder(self.wcsRedactLinesTopEdit, self.wcsRedactLinesBottomEdit)
        MainWindow.setTabOrder(self.wcsRedactLinesBottomEdit, self.pixelHeightEdit)
        MainWindow.setTabOrder(self.pixelHeightEdit, self.pixelWidthEdit)
        MainWindow.setTabOrder(self.pixelWidthEdit, self.starIdEdit)
        MainWindow.setTabOrder(self.starIdEdit, self.queryVizierButton)
        MainWindow.setTabOrder(self.queryVizierButton, self.coordinatesEdit)
        MainWindow.setTabOrder(self.coordinatesEdit, self.saveTargetLocButton)
        MainWindow.setTabOrder(self.saveTargetLocButton, self.toolButton_2)
        MainWindow.setTabOrder(self.toolButton_2, self.twoPointHelpButton)
        MainWindow.setTabOrder(self.twoPointHelpButton, self.transportHelp)
        MainWindow.setTabOrder(self.transportHelp, self.documentationPushButton)
        MainWindow.setTabOrder(self.documentationPushButton, self.appSizeToolButton)
        MainWindow.setTabOrder(self.appSizeToolButton, self.defAppSize51RadioButton)
        MainWindow.setTabOrder(self.defAppSize51RadioButton, self.defAppSize41RadioButton)
        MainWindow.setTabOrder(self.defAppSize41RadioButton, self.defAppSize31RadioButton)
        MainWindow.setTabOrder(self.defAppSize31RadioButton, self.defAppSize21RadioButton)
        MainWindow.setTabOrder(self.defAppSize21RadioButton, self.defAppSize11RadioButton)
        MainWindow.setTabOrder(self.defAppSize11RadioButton, self.sigmaLevelToolButton)
        MainWindow.setTabOrder(self.sigmaLevelToolButton, self.oneSigmaRadioButton)
        MainWindow.setTabOrder(self.oneSigmaRadioButton, self.twoSigmaRadioButton)
        MainWindow.setTabOrder(self.twoSigmaRadioButton, self.threeSigmaRadioButton)
        MainWindow.setTabOrder(self.threeSigmaRadioButton, self.defaultMaskRadiusToolButton)
        MainWindow.setTabOrder(self.defaultMaskRadiusToolButton, self.radius20radioButton)
        MainWindow.setTabOrder(self.radius20radioButton, self.radius24radioButton)
        MainWindow.setTabOrder(self.radius24radioButton, self.radius32radioButton)
        MainWindow.setTabOrder(self.radius32radioButton, self.radius40radioButton)
        MainWindow.setTabOrder(self.radius40radioButton, self.radius45radioButton)
        MainWindow.setTabOrder(self.radius45radioButton, self.radius53radioButton)
        MainWindow.setTabOrder(self.radius53radioButton, self.radius68radioButton)
        MainWindow.setTabOrder(self.radius68radioButton, self.lineNoiseFilterCheckBox)
        MainWindow.setTabOrder(self.lineNoiseFilterCheckBox, self.horizontalRadioButton)
        MainWindow.setTabOrder(self.horizontalRadioButton, self.verticalRadioButton)
        MainWindow.setTabOrder(self.verticalRadioButton, self.bothRadioButton)
        MainWindow.setTabOrder(self.bothRadioButton, self.upperTimestampMedianSpinBox)
        MainWindow.setTabOrder(self.upperTimestampMedianSpinBox, self.lowerTimestampMedianSpinBox)
        MainWindow.setTabOrder(self.lowerTimestampMedianSpinBox, self.showMedianProfileButton)
        MainWindow.setTabOrder(self.showMedianProfileButton, self.lunarCheckBox)
        MainWindow.setTabOrder(self.lunarCheckBox, self.useYellowMaskCheckBox)
        MainWindow.setTabOrder(self.useYellowMaskCheckBox, self.view3DButton)
        MainWindow.setTabOrder(self.view3DButton, self.editAperturesButton)
        MainWindow.setTabOrder(self.editAperturesButton, self.restoreApertureState)
        MainWindow.setTabOrder(self.restoreApertureState, self.roiComboBox)
        MainWindow.setTabOrder(self.roiComboBox, self.activateTimestampRemovalButton)
        MainWindow.setTabOrder(self.activateTimestampRemovalButton, self.upperTimestampPixelSpinBox)
        MainWindow.setTabOrder(self.upperTimestampPixelSpinBox, self.lowerTimestampPixelSpinBox)
        MainWindow.setTabOrder(self.lowerTimestampPixelSpinBox, self.pixelPanelInfoButton)
        MainWindow.setTabOrder(self.pixelPanelInfoButton, self.frameView)
        MainWindow.setTabOrder(self.frameView, self.transportMaxLeft)
        MainWindow.setTabOrder(self.transportMaxLeft, self.transportBigLeft)
        MainWindow.setTabOrder(self.transportBigLeft, self.transportSmallLeft)
        MainWindow.setTabOrder(self.transportSmallLeft, self.transportMinusOneFrame)
        MainWindow.setTabOrder(self.transportMinusOneFrame, self.transportPlayLeft)
        MainWindow.setTabOrder(self.transportPlayLeft, self.transportPause)
        MainWindow.setTabOrder(self.transportPause, self.transportPlayRight)
        MainWindow.setTabOrder(self.transportPlayRight, self.transportPlusOneFrame)
        MainWindow.setTabOrder(self.transportPlusOneFrame, self.transportSmallRight)
        MainWindow.setTabOrder(self.transportSmallRight, self.transportBigRight)
        MainWindow.setTabOrder(self.transportBigRight, self.transportMaxRight)
        MainWindow.setTabOrder(self.transportMaxRight, self.transportCsv)
        MainWindow.setTabOrder(self.transportCsv, self.transportPlot)
        MainWindow.setTabOrder(self.transportPlot, self.currentFrameSpinBox)
        MainWindow.setTabOrder(self.currentFrameSpinBox, self.stopAtFrameSpinBox)
        MainWindow.setTabOrder(self.stopAtFrameSpinBox, self.transportMark)
        MainWindow.setTabOrder(self.transportMark, self.transportReturnToMark)
        MainWindow.setTabOrder(self.transportReturnToMark, self.transportClearData)
        MainWindow.setTabOrder(self.transportClearData, self.textOut)
        MainWindow.setTabOrder(self.textOut, self.thumbOneView)
        MainWindow.setTabOrder(self.thumbOneView, self.thumbTwoView)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking on this button will open a pdf file that provides version history. The most recent version change descriptions will be at the top for easy reference to the historical record.</p></body></html>"))
        self.infoButton.setText(_translate("MainWindow", "Version Info"))
        self.label_2.setText(_translate("MainWindow", "File:"))
        self.saveApertureState.setToolTip(_translate("MainWindow", "<html><head/><body><p>This function is only available for videos contained in an AVI/SER-WCS folder or a FITS folder.</p><p>Clicking this button will record all the apertures (and all their properties) for later restoration along with the current frame position.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> You will be prompted to supply a name string that will be appended to the file names that comprise this aperture group. This is to allow for multiple aperture groups to be associated with a video.</p><p>To restore a previous configuration, first open the folder, then click the <span style=\" font-weight:600; color:#fc0107;\">Restore aperture group</span> button.</p></body></html>"))
        self.saveApertureState.setText(_translate("MainWindow", "Save aperture group"))
        self.restoreApertureState.setToolTip(_translate("MainWindow", "<html><head/><body><p>This function is only available for videos contained in an AVI/SER-WCS folder or a FITS folder.</p><p>Clicking this button will bring up a file selector dialog with candidates aperture groups highlighted for selection. Choosing one will restore a previously saved aperture group with all the property values present when the <span style=\" font-weight:600; color:#fc0107;\">Save aperture group</span> button was clicked including the frame position.</p><p>Note that this action will first remove all current apertures, including the one that was automatically placed through an available WCS solution. Typically the target aperture would have been included in the saved aperture group anyway.</p><p>It will then position the file to the frame that was current when the \'save\' was performed and recreate all apertures present at the time of \'saving\' on that frame.</p></body></html>"))
        self.restoreApertureState.setText(_translate("MainWindow", "Restore aperture group"))
        self.editAperturesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button brings up a table that contains a row for each aperture that has been placed on the image. The columns list the available properties of an aperture. All property values, including (x,y), can be changed from this dialog box.</p><p>When a row has been selected, Thumbnail One will show the image enclosed by the aperture and Thumbnail Two will show the computed mask unless the default mask radius cell is active, in which case the default mask will be displayed instead.  This allows for edits of threshold and default mask radius with \'live\' updates shown in Thumbnail Two.</p><p>Any changes made through this dialog take effect when either the enter key is pressed, the cell is exited (via a tab key or arrow key press for example), or the dialog is closed.</p><p>Columns for color, joggable, auto textOut, and thumbnail source have right-click context menus for making changes in those cells.</p><p>The columns for name, thresh, def mask radius, and csv output order are edited by highlighting the cell (single or double click) and then typing the new value. </p><p><span style=\" font-weight:600; color:#fc0107;\">!!! When editing the value in a cell, the edit is NOT complete until you leave that cell or press enter. Make it a practice to \'tab out\' of a cell that you have modified. (This procedure is not needed for a cell that has been modified by a right-click context menu) !!!</span></p><p><span style=\" color:#000000;\">Constraints on property values:</span></p><p><span style=\" color:#000000;\">---- name: none</span></p><p><span style=\" color:#000000;\">---- thresh: positive integer</span></p><p><span style=\" color:#000000;\">---- def mask radius: minimum value of 2.00 (initial value is 5.3)</span></p><p><span style=\" color:#000000;\">---- color: only one green allowed and no more than two yellows</span></p><p><span style=\" color:#000000;\">---- thumbnail source: only a single aperture can be set as the thumbnail source</span></p><p><span style=\" color:#000000;\">---- csv output order: positive integer (it\'s up to you to avoid duplicates!)</span></p></body></html>"))
        self.editAperturesButton.setText(_translate("MainWindow", "Examine/change aperture settings"))
        self.roiComboBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This drop-down selection box changes the measurement aperture size.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> it is a reqirement that all apertures be the same size during a lightcurve extraction, so changing the aperture size will automatically remove all existing apertures.</p><p>If there is substantial wind shake in the video, you should select an aperture size sufficent to contain the \'wanderings\' of the star you have selected for tracking or, if there is no tracking star, then the target star itself.</p><p>If there is no significant wind shake, use of a smaller aperture (like 31) may be more useful in dealing with dense star fields.</p></body></html>"))
        self.selectApertureSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This drop-down selection box changes the measurement aperture size.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> it is a reqirement that all apertures be the same size during a lightcurve extraction, so changing the aperture size will automatically remove all existing apertures.</p><p>If there is substantial wind shake in the video, you should select an aperture size sufficent to contain the \'wanderings\' of the star you have selected for tracking or, if there is no tracking star, then the target star itself.</p><p>If there is no significant wind shake, use of a smaller aperture (like 31) may be more useful in dealing with dense star fields.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note: </span><span style=\" font-weight:600; color:#0000ff;\">An aperture is never allowed to extend outside the image boundary. As a result, if an aperture is placed on a star that is close to the image edge and that star subsequently moves closer to the edge, tracking will be lost when the aperture bumps up against edge. In this case, use of a smaller aperture will allow tracking closer to the edge.</span></p></body></html>"))
        self.selectApertureSizeLabel.setText(_translate("MainWindow", "Select aperture size"))
        self.label_3.setText(_translate("MainWindow", "Threshold spinner increments:"))
        self.thresh_inc_1.setText(_translate("MainWindow", "1"))
        self.thresh_inc_10.setText(_translate("MainWindow", "10"))
        self.thresh_inc_100.setText(_translate("MainWindow", "100"))
        self.setMskthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there is a currently \'green\' aperture showing, its threshold value will be set to any new value from this spinner and <span style=\" font-weight:600; color:#fc0107;\">Thumbnail Two</span> in the lower right corner will update dynamically to show the effect of the change on the binary sample mask generation.</p><p>The mask threshold is always set as counts above average background. A good starting point for setting this value is to set it equal to the background noise (found in the column labelled <span style=\" font-weight:600; color:#fc0107;\">bkstd</span> in the text box) rounded up. The program tries to do this automatically so, in most cases, this value will already be preset. This is sometimes referred to as <span style=\" color:#0000ff;\">\'setting the threshold to 1 sigma\'</span>.</p><p>Note: <span style=\" font-weight:600; color:#fc0107;\">mskth</span> (mask threshold) and <span style=\" font-weight:600; color:#fc0107;\">bkavg</span> (background average) are column headings in the text box.</p></body></html>"))
        self.setMskthLabel.setText(_translate("MainWindow", "<html><head/><body><p>Set mask threshold (mskth) counts above background (bkavg)</p></body></html>"))
        self.viewFieldsCheckBox.setText(_translate("MainWindow", "View avi fields"))
        self.processAsFieldsCheckBox.setText(_translate("MainWindow", "Process avi in field mode"))
        self.topFieldFirstRadioButton.setText(_translate("MainWindow", "top field is first in time"))
        self.bottomFieldFirstRadioButton.setText(_translate("MainWindow", "bottom field is first in time"))
        self.showImageControlCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If this box is checked, an image control widget will appear to the right of the main image.</p><p>This widget shows a useful/interesting histogram of the image pixel values and gives you the ability to change how pixel values are mapped to the black-to-white grayscale.</p><p>To change the pixel mappings, click and drag the horizontal bars (in the left portion of the widget) that enclose the histogram display and that connect visually to the black-white colorbar.</p><p><span style=\" font-weight:600; color:#fc0107;\">NOTE:</span> changes made via this control do <span style=\" font-weight:600; text-decoration: underline;\">not</span> affect the data that is used for generating lightcurves. It only changes what you see in the main image display. But when you right click on the main image and select \'export\', the display values are what gets exported; this is the <span style=\" font-weight:600; text-decoration: underline;\">only</span> time that \'display\' values are used.</p><p>Until this image control is opened, the grayscale mapping of each image changes based on the minimum and maximum pixel values in that image. This automatic rescaling is usually acceptable but can cause apparent \'flashing\' of the images during playback. Opening and then closing this image control will freeze the automatic rescaling.</p><p><span style=\" font-weight:600; color:#fc0107;\">NOTE:</span> if you do not close the image control, when you return to the frame that was used to decide the desired settings, the settings are automatically reset --- this is not a useful behavior, so ... Best practice: activate the control; adjust the sliders; close the control.</p></body></html>"))
        self.showImageControlCheckBox.setText(_translate("MainWindow", "Show image contrast control"))
        self.satPixelLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This value controls the coloring of pixels in ThumbNail One  and Thumbnail Two.</p><p>Pixels that are at or above this level will be colored in shades of red to give a visual clue that such pixels are at or near saturation.</p><p>Pixels that are below this level are shown in the usual gray scale.</p><p>Thumbnail Two shows the parts of the aperture that are \'masked off\' in yellow and allows the display of the pixels that are included by the mask to be shown as their actual values.</p></body></html>"))
        self.satPixelLabel.setText(_translate("MainWindow", "sat. pixel value"))
        self.demoMeanPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The \'robust\' calculation of the background average and the \'robust\' estimation of the dispersion (noise) in the background is an important factor in the calculation of signal intensities.</p><p>This button demonstrates with a detailed plot the calculation as it was performed for the current \'thumbnail\'.</p><p>This is meant primarily for education purposes but may be useful in special cases to confirm (or not) that the \'robust\' calculations are reasonable.</p><p>The algorithm works by calculating a histogram of the pixels present in an aperture. The \'background\' pixels show up in the prominent \'hump\' in that histogram at the left (low pixel values). The \'hump\' is analyzed to determine where the righthand tail ends.  A red line is drawn on the histogram to show where this demarcation is. Then, all the points to the left of this demarcation are used to calculate the mean and standard deviation of those points in the usual manner.</p></body></html>"))
        self.demoMeanPushButton.setText(_translate("MainWindow", "Plot Robust Mean"))
        self.h1.setToolTip(_translate("MainWindow", "<html><head/><body><p>You are seeing this help panel because you clicked on a <span style=\" font-weight:600; color:#fc0107;\">\'track path\'</span> menu item in a non-yellow aperture --- those menu items have an effect <span style=\" font-weight:600;\">only</span> in the context of a yellow aperture and are used to define a \'tracking path\', a tracking option designed to assist in processing \'drift-through\' videos.</p><p>A \'tracking path\' is a straight line across an image that is to be followed frame-by-frame by the center of a yellow tracking aperture as the video is analyzed. This can be used to \'follow\' an object that disappears completely, particularly useful in the situation where there are no other stars that remain visible enough to provide a separate tracking reference. And, as always, the presence of a yellow aperture locks all apertures into a \'constellation\' that moves as a unit.</p><p>Note: to ease the task of re-positioning the yellow aperture as you advance to later frames, enable jogging on the aperture.</p><p>To define a \'tracking path\', use a <span style=\" font-weight:600; text-decoration: underline;\">single</span> yellow aperture and position that aperture at a desired point early in the video (it does <span style=\" font-weight:600;\">not</span> have to be frame 0) and click on the menu item <span style=\" font-weight:600; color:#fc0107;\">Use current position as early track path point</span></p><p><span style=\" color:#000000;\">To complete the definition of the \'tracking path\', position the tracking aperture at a desired point late in the video (it does not have to be the last frame) and click on the menu item </span><span style=\" font-weight:600; color:#fc0107;\">Use current position as late track path point</span></p><p><span style=\" color:#000000;\">Note: with a \'tracking path\' defined, the entire aperture constellation will move in a straight line (defined by the xy and frame number values of the early and late points). While this constellation will not itself follow windshake, stars can continue to \'dance\' within the apertures and will be \'followed\' by the mask generating routines --- for red apertures, it will look for a bright blob within an 8 pixel radius; for yellow apertures, it will look for the brightest blob anywhere in the aperture. You can always set a very high threshold to force the use of fixed circular masks in apertures where you want to suppress this behavior.</span></p><p><span style=\" color:#000000;\">Note: If you delete the yellow aperture (or add a second one), the current tracking path data will be erased.</span></p><p><span style=\" color:#000000;\">Note: You can overwrite either of the data points at any time.</span></p></body></html>"))
        self.readAviFileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: video files are read using OpenCV which employs ffmpeg to do the actual file reading. As a result, a wide range of codecs are standardly available.</p><p>In particular, avi files using Lagarith compression will be read without problem.</p><p>There is a remote possibility that a video was recorded with an unusual codec and so fail to be read by PyMovie. In that case, you will need to use an external file conversion program that can decode the file as recorded and rewrite it using a more common codec.</p><p>.adv files must be Version 2, monochrome.</p><p>.aav files must be Version 2, monochrome.</p></body></html>"))
        self.readAviFileButton.setText(_translate("MainWindow", "Open AVI/MOV/SER/ADV/AAV file"))
        self.createAVIWCSfolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will only be active when a \'bare\' avi/mov/ser/adv/aav file is opened (rather than from an AVI/MOV/SER/ADV/AAV-WCS folder).</p><p>This button has been added because of the decision to perform timestamp OCR only on files that live in an AVI/MOV/SER/ADV/AAV-WCS folder. While that is a good way to collect the (many) files that result from OCR, WCS, PyMovie, and PyOTE operations, there are likely to be users that have opted for a flat (or flatter) directory structure. This button will ease (hopefully) the transition to an alternate file organization.</p><p>When clicked, a Directory dialog will appear to allow the user to select (or even create) the directory that is to hold the newly created (and filled) AVI/MOV/SER/ADV/AAV-WCS folder. It defaults to the directory that holds the opened video file.</p><p>The name of the newly created AVI/MOV/SER/ADV/AAV-WCS folder will always be the name of the video file with its outermost extension removed.</p><p>The folder will then be populated with an alias (Mac) to the video or a Shortcut (Windows) to the video, so this file structure will be frugal with file space.</p><p>Finally, behind-the-scenes, the program simulates the user clicking on <span style=\" font-weight:600; color:#fc0107;\">Select AVI/MOV/SER/ADV/AAV-WCS folder</span> and then clicking on <span style=\" font-weight:600; color:#fc0107;\">Accept</span> (possible because after a \'creation of AVI/MOV/SER/ADV/AAV-WCS folder\', the default directory/folder is set to that of the newly created folder). We could not imagine a workflow where a user would <span style=\" font-weight:600;\">not</span> want to immediately start processing the video from within an AVI/MOV/SER/ADV/AAV-WCS folder, so the automation seems reasonable and unlikely to get in anyone\'s way.<br/></p></body></html>"))
        self.createAVIWCSfolderButton.setText(_translate("MainWindow", "Create AVI/MOV/SER/ADV/AAV-WCS folder from file"))
        self.selectAviWcsFolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>An AVI/MOV/SER/ADV/AAV-WCS folder is a container for a single observation video and its related files. As such, there must be only a single .avi/.mov/.ser/.adv/.aav file in the folder either explicitly, or by shortcut (Windows) or alias (MacOS). This requirement is enforced.</p><p>This folder may also contain a simple text file that contains the Ra and DEC coordinates of the occulted star, filled in by the user through a dialog box that appears when this position information file is found missing during WCS calibration operations.</p><p>This folder is also where the WCS calibration data will be placed if the user opts for calibrating frame 0 by making an on-line submission to astrometry.net.</p><p>This folder is also the default location for storing csv files and copies of the last lightcurve plots.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> avi files are read using OpenCV which employs ffmpeg to do the actual file reading. As a result, a wide range of avi codecs are standardly available.</p><p>In particular, avi files using Lagarith compression will be read without problem.</p><p>There is a remote possibility that an avi was recorded with an unusual codec and so fail to be read by PyMovie. In that case, you will need to use an external file conversion program that can decode the file as recorded and rewrite it using a more common codec.</p><p>ADV and AAV files must be Version 2 monochrome.</p></body></html>"))
        self.selectAviWcsFolderButton.setText(_translate("MainWindow", "Select AVI/MOV/SER/ADV/AAV-WCS folder"))
        self.readFitsFolderButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>A <span style=\" color:#fc0107;\">FITS</span> folder should contain a set of *.fits files, all from a single recording.</p><p>There should be no other .fits files in that folder.</p><p>It is assumed that the alphabetic ordering of the file names corresponds to sequential frames.</p><p>There is a button titled <span style=\" font-weight:600; color:#fc0107;\">Show FITS/SER/ADV/AAV metadata</span> below that will read and display in the text box (lower left corner) all the metadata entries from the currently displayed .fits/.ser/.adv file image.</p></body></html>"))
        self.readFitsFolderButton.setText(_translate("MainWindow", "Select FITS folder"))
        self.metadataButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button will show (in the text box in the lower left corner of the GUI) all metadata from the currently displayed .fits/.ser/.adv/.aav file.</p><p>\'metadata\' is the text information that is present in the header of the .fits/.ser file or the SYSTEM and USER metadata that is present in an ADV or AAV Version 2 files.</p></body></html>"))
        self.metadataButton.setText(_translate("MainWindow", "Show FITS/SER/ADV/AAV file metadata"))
        self.enableAdvFrameStatusDisplay.setToolTip(_translate("MainWindow", "<html><head/><body><p>Data frames in ADV or AAV Version 2 files can have metadata associated with each frame. If this checkbox is checked, and there is metadata available, the metadata will be displayed in the text box (lower left corner of GUI) as each frame is read.</p></body></html>"))
        self.enableAdvFrameStatusDisplay.setText(_translate("MainWindow", "Display frame metadata for ADV/AAV frames"))
        self.openBmpPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a file selection dialog with all available &quot;finder&quot; image files highlighted --- it is not uncommon to have more than one.</p><p>The &quot;finder&quot; images generated by PyMovie have a frame number imbedded in the filename. That frame number will be extracted and used to position the video to that frame before displaying the &quot;finder&quot; image.</p><p>By judicious use of static apertures, a constellation of apertures can be placed on the &quot;finder&quot; image and will remain in place when the video frame replaces the &quot;finder&quot; image --- this happens whenever the current frame number is changed.</p><p><br/></p></body></html>"))
        self.openBmpPushButton.setText(_translate("MainWindow", "Open \"finder\" image"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_5), _translate("MainWindow", "File/Folder"))
        self.vtiSelectLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This control provides a drop-down list of VTI (video time inserter) models for which OCR (optical character recognition) timestamp processing is available. Selecting an entry will cause a constellation of character extraction boxes to be displayed on the image and there will be an automatic switch to field view and to a frame other than frame 0 --- which is often an improperly formatted frame with duplicate fields (a startup artifact of the frame grabber).</p><p><span style=\" font-weight:600; color:#fc0107;\">Note that this control will only be active when an AVI/SER-WCS folder is in use AND model digit training has not been completed. Its purpose is to provide a default set of ocr character selection boxes that are approximately in good positions.</span></p><p>If the character selection boxes enclose the correct characters and are reasonably well-aligned, then you\'re ready to do fine adjustments to the box positions and, after all the boxes have had their positions optimized, select the digits 0 to 9 that will be used as model digits for the optical character recognition algorithms.</p><p>If you\'re using a Kiwi VTI, which has two positions for the timestamp and switches from one to the other when the minutes field changes, you must first determine whether the timestamp is in its lefthand position or its righthand position because you need to know which set of selection boxes to put on the image (the dropdown list for Kiwi provides a lefthand and a righthand version). So, for the Kiwi you will need to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1)</span> Try both the lefthand and righthand selection box sets --- if one them already fits well, go ahead and use it, skipping steps 2 and 3 below. If there was <span style=\" text-decoration: underline;\">no</span> obvious \'winner\', then perform the next steps.</p><p><span style=\" font-weight:600; color:#fc0107;\">2)</span> Starting with frame 1, move forward in 10 second increments until the time stamp shifts. If it shifts to the right, then frame 1 has a left-positioned timestamp. If it shifts to the left, then frame 1 has a right-positioned timestamp.</p><p><span style=\" font-weight:600; color:#fc0107;\">3)</span> Move back to frame 1 and click the select VTI dropdown list --- choose Kiwi lefthand or righthand to match the position of the timestamp determined above.</p><p>The next step is jog the position of the selection boxes so that the enclosed characters are well-centered.</p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p><span style=\" font-weight:600;\">The easiest way to adjust the selection boxes is to put the mouse cursor inside a selection and press j on the keyboard. The selection box color will change from red to yellow to show that it can be jogged by the keyboard arrow keys. The thumbnail expanded view of the selection box will be active during jog movements, so it is very easy to see when good centering has been achieved. Press the j key again to disable jogging on that box and move your cursor to the next box. Rinse and repeat until all characters are well centered.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p>It is also possible to right-click on an ocr selection box and use the resulting pop-up menu to enable all ocr boxes in a row to be enabled for jogging, or even all selection boxes at once. The arrow keys control the jogs and their direction. When a selection box is joggable (responds to the keyboard arrow keys), its color will change from red to yellow.</p><p>Finally, record the digits 0 through 9 as model digits to complete the \'training\' for the avi in this folder --- you may have to advance the video to subsequent frames to get a particular character sample.</p><p>We call the set of character selection boxes and the model digits an OCR profile. OCR profiles can be saved to (and loaded from) a list. This facility is provided because, for a given recording chain --- camera, VTI, frame-grabber ---, it is very likely that the OSD characters will be in the same place for all recordings employing that chain. So once an OCR profile has been established for that chain, it should be saved for reuse.</p></body></html>"))
        self.vtiSelectLabel.setText(_translate("MainWindow", "select VTI: "))
        self.vtiSelectComboBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Note: this control will only be active when an AVI-WCS folder is in use.</span></p><p>This control provides a drop-down list of VTI (video time inserter) models for which timestamp extraction is available.</p><p>Except for the <span style=\" font-weight:600; color:#fc0107;\">SharpCap 8 bit avi</span> entry, selecting an entry will cause a constellation of character extraction boxes to be displayed on the image (which automatically switches to field view).</p><p>If the character selection boxes enclose the correct characters and are well-aligned, then you\'re ready to go.</p><p>If you\'re dealing with a Kiwi timestamp, which has two positions for the timestamp character --- a left position and a right position --- you should first select the position that best encloses the timestamp characters in the displayed frame.</p><p>If the character boxes are not well aligned, use the jogging buttons to the right to achieve a better alignment.</p><p><span style=\" font-weight:600; text-decoration: underline; color:#fc0107;\">Note: Kiwi timestamp boxes must only be adjusted (jogged) when the timestamp position is the same as that of frame 1.</span></p><p><span style=\" color:#000000;\">The </span><span style=\" font-weight:600; color:#fc0107;\">SharpCap 8 bit avi</span> entry is special in that no OCR (optical character recognition) is needed. This is because the SharpCap program encodes a 64 bit timestamp in the first 8 bytes of the image and that is where PyMovie gets its timestamp information. So, there are no character selection boxes and there is no need to save a profile.</p></body></html>"))
        self.loadCustomProfilesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is only active whan an AVI/SER-WCS folder is open.</p><p>In that case, it displays the list of available custom ocr profiles (character selection box placements and model digits) retrieved from the file found in your user home directory with the name pymovie-ocr-profiles.p</p><p>In the dialog box that appears, you can:</p><p>1) edit the names of previously saved profiles or </p><p>2) give a name to and save the current profile or</p><p>3) delete a saved profile or</p><p>4) select a profile and \'load it\'. This will overwrite the currently active ocr profile.</p><p>To share (or get a profile from another user), these are the files in the AVI-WCS folder that comprise the ocr profile:</p><p><span style=\" font-weight:600; color:#fc0107;\">custom-boxes-upper.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">custom-boxes-lower.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">custom-digits.p</span></p><p><span style=\" font-weight:600; color:#fc0107;\">formatter.txt</span></p><p>Sharing just those files is all that is required. Put them in your AVI/SER-WCS folder and then use this dialog to save that profile with a name of your choosing into your personal list of custom ocr profiles.</p></body></html>"))
        self.loadCustomProfilesButton.setText(_translate("MainWindow", "Select/save custom ocr profile"))
        self.clearOcrDataButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button deletes all OCR profile files from the current folder--- it\'s a \'clean start-over\' to be used when an OCR setup/training session has gone pear-shaped in a big way.</p></body></html>"))
        self.clearOcrDataButton.setText(_translate("MainWindow", "Clear ocr data"))
        self.vtiHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">The </span><span style=\" font-weight:600; color:#0000ff;\">select VTI:</span><span style=\" font-weight:600; color:#fc0107;\"> dropdown list will only be active when an AVI/SER-WCS folder is in use AND model digit training has not been completed.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">An AVI/SER-WCS folder is needed because setting up the VTI timestamp extraction profile (selection box positions and character trainings) produces files that are unique to the present video and so need a space of their own in which to be saved.</span></p><p>The <span style=\" font-weight:600; color:#0000ff;\">select VTI:</span> control provides a drop-down list of VTI (video time inserter) models for which OCR (optical character recognition) timestamp processing is available. Selecting an entry will cause a constellation of character extraction boxes to be displayed on the image and there will be an automatic switch to field view and to a frame other than frame 0 --- which is often an improperly formatted frame with duplicate fields (a startup artifact of the frame grabber).</p><p>If the character selection boxes enclose the correct characters and are reasonably well-aligned, then you\'re ready to do fine adjustments to the box positions and, after all the boxes have had their positions optimized, select the digits 0 to 9 that will be used as model digits for the optical character recognition algorithms.</p><p>If you\'re using a Kiwi VTI, which has two positions for the timestamp and switches from one to the other when the minutes field changes, you must first determine whether the timestamp is in its lefthand position or its righthand position because you need to know which set of selection boxes to put on the image (the dropdown list for Kiwi provides a lefthand and a righthand version). So, for the Kiwi you will need to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1)</span> Try both the lefthand and righthand selection box sets --- if one them already fits well, go ahead and use it, skipping steps 2 and 3 below. If there was <span style=\" text-decoration: underline;\">no</span> obvious \'winner\', then perform the next steps.</p><p><span style=\" font-weight:600; color:#fc0107;\">2)</span> Starting with frame 1, move forward in 10 second increments until the time stamp shifts. If it shifts to the right, then frame 1 has a left-positioned timestamp. If it shifts to the left, then frame 1 has a right-positioned timestamp.</p><p><span style=\" font-weight:600; color:#fc0107;\">3)</span> Move back to frame 1 and click the select VTI dropdown list --- choose Kiwi lefthand or righthand to match the position of the timestamp determined above.</p><p>The next step is jog the position of the selection boxes so that the enclosed characters are well-centered.</p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p><span style=\" font-weight:600;\">The easiest way to adjust the selection boxes is to put the mouse cursor inside a selection and press j on the keyboard. The selection box color will change from red to yellow to show that it can be jogged by the keyboard arrow keys. The thumbnail expanded view of the selection box will be active during jog movements, so it is very easy to see when good centering has been achieved. Press the j key again to disable jogging on that box and move your cursor to the next box. Rinse and repeat until all characters are well centered.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">===============================================================</span></p><p>It is also possible to right-click on an ocr selection box and use the resulting pop-up menu to enable all ocr boxes in a row to be enabled for jogging, or even all selection boxes at once. The arrow keys control the jogs and their direction. When a selection box is joggable (responds to the keyboard arrow keys), its color will change from red to yellow.</p><p>Finally, record the digits 0 through 9 as model digits to complete the \'training\' for the avi in this folder --- you may have to advance the video to subsequent frames to get a particular character sample.</p><p>We call the set of character selection boxes and the model digits an OCR profile. OCR profiles can be saved to (and loaded from) a list. This facility is provided because, for a given recording chain --- camera, VTI, frame-grabber ---, it is very likely that the OSD characters will be in the same place for all recordings employing that chain. So once an OCR profile has been established for that chain, it should be saved for reuse.</p></body></html>"))
        self.vtiHelpButton.setText(_translate("MainWindow", "Timestamp setup help"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_6), _translate("MainWindow", "Timestamp"))
        self.hotPixelHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This panel provides tools for dealing with what are commonly referred to as hot-pixels in the contecxt of CCD image sensors.</p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">If you are using a CMOS camera (which frequently have too many hot-pixels to use individual apertures to locate them) use the tools in the CMOS hot pixels tab for more comprehensive treatment of the pixel issues prevalent in CMOS cameras.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Sometimes it may be more efficient to use the CMOS tools for locating the highly isolated hot-pixels in a CCD array and then to return to this panel for dealing with the hot-pixel clumps that appear in some CCD sensors. Then one can enable \'hot-pixel\' treatment using both mechanisms. This works because the CMOS pixel correction treament (which is applied first) will deal easily with the isolated pixels, but does not deal well with hot-pixel clumps. But then the CCD hot-pixel treatment will follow and deal with the hot-pixel clumps in a better manner.</span></p><p><span style=\" font-family:\'Helvetica\'; font-weight:700; color:#ff0000;\">Note:</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> CMOS treats hot pixels by replacing the pixel value with the mean of its 8 neighbors. This is effective because CMOS hot-pixels are nearly always isolated and surrounded by healthy neighbors.</span></p><p><span style=\" font-family:\'Helvetica\'; font-weight:700; color:#ff0000;\">Note:</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> CCD treats hot pixels by replacing them with an average pixel value (determined from the center of the image using a default size aperture). This is necessary because CCD hot-pixels occur in clumps (usually) and so the \'mean of neighbors\' used for isolated CMOS hot-pixels cannot be used here.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">The primary use of hot-pixel removal is to help produce clean videos so that stars in the video can be correlated with finder charts.  If there are hot-pixels in frames, they appear on stacked &quot;finder&quot; images as distracting streaks (if the star field is in motion between frames) or false/spurious stars.  Either situation makes it more difficult to correlate a star chart with the video or finder image and thus to locate the desired target star.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">The use of hot-pixel removal during analysis should be restricted to those rare occasions where the interaction of the target (or tracking) star with a hot-pixel must be mitigated.  In such cases, run the analysis both with and without hot-pixel removal and use the best light curve.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Right-click on each of the hot-pixel removal buttons to learn how to create a custom hot pixel list and remove hot pixels from your videos.</span><br/></p></body></html>"))
        self.hotPixelHelpButton.setText(_translate("MainWindow", "Hot-pixel removal explanation/help"))
        self.createHotPixelListButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Click this button after placing </span><span style=\" font-family:\'Helvetica\'; text-decoration: underline; color:#000000;\">static</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> mask apertures on each hot pixel group present in the image that you want removed. Remember, the hot-pixel constellation may be different from frame to frame,so step through several frames to find and mark all the hot pixels you want removed.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Perform the above sequentially for each hot pixel group.When done with all hot pixel groups,press the </span><span style=\" font-family:\'Helvetica\'; font-weight:600; color:#fc0107;\">Add to hot-pixel list... </span><span style=\" font-family:\'Helvetica\'; color:#000000;\">button. You will need to set a threshold that gives the intensity level above which a pixel is considered \'hot\'. A judicious use of the Plot Robust Mean button will give you a way to estimate an appropriate value to use.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Clicking the </span><span style=\" font-family:\'Helvetica\'; font-weight:600; color:#fc0107;\">Add to hot-pixel list... </span><span style=\" font-family:\'Helvetica\'; color:#000000;\">button also removes the apertures. You can place another set and repeat the process - the additional hot-pixel list will be appended to that already gathered. This may be a useful procedure if the hot-pixel threshold must be set differently for different hot-pixel groups.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Hot pixels are \'removed\' by replacing their value with that of the average background, determined from the center of the image using a default size aperture.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">This list will be used to remove those hot pixels from each frame in the video.This is desirable in the creation of a &quot;finder&quot; image because hot pixels,which do not move,often produce annoying streaks or false/spurious stars in the &quot;finder&quot; images.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Even when hot-pixels don\'t produce streaks (guidance of the telescope has to be very good in such a case) it is also useful to remove hot pixel groups so that they don\'t add confusing asterisms --- it\'s easier to correlate a finder image without spurious \'stars\' that don\'t appear in a sky chart.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Use the </span><span style=\" font-family:\'Helvetica\'; font-weight:600; color:#fc0107;\">load/save/delete hot-pixels profiles</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> button below the </span><span style=\" font-family:\'Helvetica\'; font-weight:600; color:#fc0107;\">Add to hot-pixel list... </span><span style=\" font-family:\'Helvetica\'; color:#000000;\">button if you want to name and save this list into a hot-pixel list database for future use.Since the hot pixel constellation for a given camera/camera setting will change,either slowly with time or when different gain or integration levels are used,such saved profiles can be quickly recalled and will often be sufficient for hot pixel removal.At the very least, it will serve as good starting point.</span></p></body></html>"))
        self.createHotPixelListButton.setText(_translate("MainWindow", "Add to hot-pixel list from aperture(s) placed"))
        self.clearCCDhotPixelListPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This clears the hot pixel list.</p><p>The hot pixel list is added to whenever the <span style=\" font-weight:700; color:#0000ff;\">Add to hot-pixel list from aperture(s) placed button</span> is clicked. This clears that cumulative list.</p></body></html>"))
        self.clearCCDhotPixelListPushButton.setText(_translate("MainWindow", "Clear hot pixel list"))
        self.loadHotPixelProfileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Once you have created a hot-pixel removal list,you may name and save the list for use on future videos captured with the current camera and settings.Clicking this button will bring up a menu allowing you to:</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">* Add a hot-pixel removal list as a New profile to the profile menu</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">* Load a previously saved profile list from the table of hot-pixel profiles.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">* Delete a previously saved profile </span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Loading a previously saved list profile will allow removal of hot-pixels when the </span><span style=\" font-family:\'Helvetica\'; font-weight:700; color:#0000ff;\">Enable hot-pixel erase</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> radio button is selected.This gives you an opportunity to compare the new video to the previous video custom hot pixel list and if new hot pixels have appeared,to make any changes that may be required and save as a new list profile.</span></p><p><span style=\" font-family:\'Helvetica\'; font-weight:700; color:#ff0000;\">Tip: It is common that new hot-pixels will occur with time. To accommodate this, it is possible to add to an existing profile by following the procedure below ---</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">1) Use table displayed when this button is clicked to load the most recent hot-pixel profile. The apertures surrounding those hot-pixel groups will appear.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">2) </span><span style=\" font-family:\'Helvetica\'; font-weight:700; text-decoration: underline; color:#000000;\">Leave the apertures visible</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> from step 1 and add apertures around the new hot-pixel groups.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">3) Click the </span><span style=\" font-family:\'Helvetica\'; font-weight:700; color:#0000ff;\">Add to hot-pixel list from aperture(s) placed</span><span style=\" font-family:\'Helvetica\'; color:#000000;\"> button. All apertures will disappear, but both the old and the new will become the current profile.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">4) Save the updated current profile (with a new date)</span></p></body></html>"))
        self.loadHotPixelProfileButton.setText(_translate("MainWindow", "load/save/delete hot-pixel profiles"))
        self.hotPixelEraseFromList.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this radio button is selected, hot-pixel removal is active.</p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Beware: there is always the possibility of generating a spurious \'dip\' in a light curve that has a hot pixel group overlapping a star image,particularly on a drift-through video because every pixel identified in the list has its value replaced by the procedure explained below with a value that essentially removes it from the calculation of the star intensity.</span></p><p><span style=\" font-family:\'Helvetica\'; color:#000000;\">Hot pixel removal is performed on a frame-by-frame basis by calculating an average background for that frame through a Robust Mean calculation applied to a default-sized aperture placed at the center of the frame.Then, this value is used to overwrite the pixel value at each coordinate point present in the hot pixel list with the average background value.</span></p></body></html>"))
        self.hotPixelEraseFromList.setText(_translate("MainWindow", "Enable hot-pixel erase"))
        self.hotPixelEraseOff.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this radio button selected, all hot-pixel removal is disabled.</p></body></html>"))
        self.hotPixelEraseOff.setText(_translate("MainWindow", "Disable hot-pixel erase"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "CCD tools"))
        self.dfRestoreAvailableFramesButton.setText(_translate("MainWindow", "Restore Dark/Flat frames"))
        self.dfClearFrameDataButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clearing all frame data is useful when an observation folder is in use. The problem is that opening an observation folder that contains dark/flat frame files already will fill dark/flat frames from those files. Without clearing all of that dark/flat frame data, it would be impossible to get rid of unwanted dark/flat files from that folder.</p><p>Click this button to create a \'clean sheet\' for creating a new set of dark/flat frame data. Then, a subsequent click on the <span style=\" font-weight:700; color:#0000ff;\">Save Dark/Flat frames</span> button will save a completely new set of dark/flat frame files to the observation folder.</p></body></html>"))
        self.dfClearFrameDataButton.setText(_translate("MainWindow", "Clear all frames"))
        self.dfHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Dark videos (a recording where no light is allowed on the sensor) and Flat videos (a recording where a constant light level is presented at the sensor sufficient to reach about 75% of max linear intensity) can be used for two purposes: sensor quality control (locating misbehaving pixels); correction for pixel to pixel variations in black level and responsivity to light (gain differences) to reduce light curve noise from these sources.</p><p><span style=\" font-weight:700; color:#ff0000;\">The expected work flow is:</span></p><p>1) Click <span style=\" font-weight:700; color:#0000ff;\">Select &quot;dark&quot; video</span> - this will open the file and enable the <span style=\" font-weight:700; color:#0000ff;\">Calc darkFrame</span> button.</p><p>2) Set the desired start and stop frame numbers.</p><p>3) Click the <span style=\" font-weight:700; color:#0000ff;\">show</span> checkboxes to activate lines that designate the ROI (region of interest) - elimination of timestamp information is the primary purpose for the selection, but removing a couple of rows at the top and a couple of columns at the left and right edges is useful to deal with edge effects that are frequently present. The spinners for positioning the ROI lines can be clicked, or edited, or if your mouse has a wheel, spin that wheel while the mouse pointer is in the widget.</p><p>4) Whatever settings for the ROI are chosen MUST be used for both the dark and flat frame generation. This is enforced during the <span style=\" font-weight:700; color:#0000ff;\">Save Dark/Flat frames</span> process.</p><p>5) Click the <span style=\" font-weight:700; color:#0000ff;\">Calc darkFrame</span> button to finally form the dark frame.</p><p>6) Click the <span style=\" font-weight:700; color:#0000ff;\">Show dark defects</span> button to view \'dark defects\' - the <span style=\" font-weight:700; color:#0000ff;\">dark thresh</span> spinner sets the threshold (in ADU units) - any dark frame pixels above this threshold are considered defective, relative to the median value.</p><p>7) Click <span style=\" font-weight:700; color:#0000ff;\">Select &quot;flat&quot; video</span> - this will open the file and enable the <span style=\" font-weight:700; color:#0000ff;\">Calc flatFrame</span> button. Click on that button to form the flat frame.</p><p>8) Click the <span style=\" font-weight:700; color:#0000ff;\">Calc gain frame from dark/flat pair</span> button.</p><p>9) Use the <span style=\" font-weight:700; color:#0000ff;\">dark thresh</span> and <span style=\" font-weight:700; color:#0000ff;\">gain thresh</span> spinners to calculate dark defects and gain defects frames.</p><p>10) Click the <span style=\" font-weight:700; color:#0000ff;\">Save Dark/Flat frames</span> button and give the directory a name that reflects accurately the camera used and the settings used for the recordings.</p><p><span style=\" font-weight:700; color:#ff0000;\">Calculations performed to form the gain frame:</span></p><p>reference_signal = flatMedian - darkMedian</p><p>repeat for all pixels (i is the index):</p><p>delta = flat[i] - dark[i]</p><p>if delta &lt;= 0.0 then gain[i] = 0.25 goto_next_pixel</p><p>gain_needed = reference_signal / delta</p><p>if gain_needed &gt; 3.0 then gain[i] = 3.0 else if gain_needed &lt; 0.33 then gain[i] = 0.33 else gain[i] = gain_needed</p><p>goto_next_pixel</p><p><span style=\" font-weight:700; color:#ff0000;\">Use of the gain frame (defined above) and the dark frame to correct pixel non-uniformities during frame reading:</span></p><p><span style=\" color:#000000;\">As each frame is read, the following correction is made:</span></p><p><span style=\" color:#000000;\">repeat for all pixels in the frame:</span></p><p><span style=\" color:#000000;\">corrected_pixel[i] = (pixel[i] - dark[i]) * gain[i] + darkMedian</span></p><p><span style=\" font-weight:700; color:#ff0000;\">Dark/Flat repository structure:</span></p><p><span style=\" color:#000000;\">In your home directory (which is shown in the message window when PyMovie is started) the follwing file/directory structure is maintained:</span></p><p><span style=\" font-weight:700; color:#00aa00;\">DARKS-FLATS</span><span style=\" color:#000000;\"> (folder)</span></p><p><span style=\" color:#000000;\">=== </span><span style=\" font-weight:700; color:#00aa00;\">UserNamedCamera1</span><span style=\" color:#000000;\"> (sub-folder holding dark/flat files)</span></p><p><span style=\" color:#000000;\">=== </span><span style=\" font-weight:700; color:#00aa00;\">UserNamedCamera2 </span><span style=\" color:#000000;\">(sub-folder holding dark/flat files)</span></p><p><span style=\" font-weight:700; color:#ff0000;\">Note:</span><span style=\" color:#000000;\"> The names of the sub-folders inside the DARK-FLATS folder are provided by the user when the </span><span style=\" font-weight:700; color:#0000ff;\">Save Dark/Flat frames</span><span style=\" color:#000000;\"> button is clicked.</span></p><p><br/></p><p><br/></p></body></html>"))
        self.dfHelpButton.setText(_translate("MainWindow", "Help"))
        self.dfRedactTopLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information.</p><p>For a &quot;dark&quot;, this region is filled with 0.0</p><p>For a &quot;flat&quot;, this region is given a gain of 1.0</p><p>The combined effect of the above settings is that during frame reading with &quot;corrections&quot;, the pixels in the timestamp regions retain their original values.</p></body></html>"))
        self.dfRedactTopLinesLabel.setText(_translate("MainWindow", "<html><head/><body><p>redaction: top </p></body></html>"))
        self.dfRedactBottomLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information.</p><p>For a &quot;dark&quot;, this region is filled with 0.0</p><p>For a &quot;flat&quot;, this region is given a gain of 1.0</p><p>The combined effect of the above settings is that during frame reading with &quot;corrections&quot;, the pixels in the timestamp regions retain their original values.</p></body></html>"))
        self.dfRedactBottomLinesLabel.setText(_translate("MainWindow", "bottom   "))
        self.dfShowRedactLinesCheckBox.setText(_translate("MainWindow", "show"))
        self.dfRedactLeftColsLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information.</p><p>For a &quot;dark&quot;, this region is filled with 0.0</p><p>For a &quot;flat&quot;, this region is given a gain of 1.0</p><p>The combined effect of the above settings is that during frame reading with &quot;corrections&quot;, the pixels in the timestamp regions retain their original values.</p></body></html>"))
        self.dfRedactLeftColsLabel.setText(_translate("MainWindow", "<html><head/><body><p>redaction: left </p></body></html>"))
        self.dfRedactRightColsLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information.</p><p>For a &quot;dark&quot;, this region is filled with 0.0</p><p>For a &quot;flat&quot;, this region is given a gain of 1.0</p><p>The combined effect of the above settings is that during frame reading with &quot;corrections&quot;, the pixels in the timestamp regions retain their original values.</p></body></html>"))
        self.dfRedactRightColsLabel.setText(_translate("MainWindow", "right"))
        self.dfShowVerticalRedactLinesCheckBox.setText(_translate("MainWindow", "show"))
        self.dfAviSerTypeFileRadioButton.setText(_translate("MainWindow", "Avi/Ser/ADV/AAV  video   "))
        self.dfFitsFileTypeRadioButton.setText(_translate("MainWindow", "FITS video"))
        self.dfSelectDarkVideoButton.setText(_translate("MainWindow", "Select \"dark\" video"))
        self.dfProcessDarkButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The <span style=\" font-weight:700; color:#ff0000;\">darkFrame</span> is formed by summing the frames in the range set by the <span style=\" font-weight:700; color:#0000ff;\">current frame:</span> edit box and the <span style=\" font-weight:700; color:#0000ff;\">stop frame:</span> edit box. It is a simple average.</p></body></html>"))
        self.dfProcessDarkButton.setText(_translate("MainWindow", "Calc darkFrame"))
        self.dfSelectFlatVideoButton.setText(_translate("MainWindow", "Select \"flat\" video"))
        self.dfProcessFlatButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The <span style=\" font-weight:700; color:#ff0000;\">flat</span><span style=\" font-weight:700; color:#ff0000;\">Frame</span> is formed by summing the frames in the range set by the <span style=\" font-weight:700; color:#0000ff;\">current frame:</span> edit box and the <span style=\" font-weight:700; color:#0000ff;\">stop frame:</span> edit box. It is a simple average.</p></body></html>"))
        self.dfProcessFlatButton.setText(_translate("MainWindow", "Calc flatFrame"))
        self.dfAnalyzeDarkFlatPairButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will be active only when both a &quot;dark&quot; video and a &quot;flat&quot; video have been read.</p><p>The analysis consists of:</p><p><span style=\" font-weight:700; color:#ff0000;\">1)</span> locating excessively noisy pixels (using <span style=\" font-weight:700; color:#0000ff;\">noise std</span> threshold below)</p><p><span style=\" font-weight:700; color:#ff0000;\">2)</span> Calculating a gain matrix:  gain[i] = (mean_flat_intensity - mean_dark_intensity) / (flat[i] - dark[i])</p><p><span style=\" font-weight:700; color:#ff0000;\">3)</span> Locating defective pixels by gain deviation (using <span style=\" font-weight:700; color:#0000ff;\">gain std</span> threshold below)</p></body></html>"))
        self.dfAnalyzeDarkFlatPairButton.setText(_translate("MainWindow", "Calc gainFrame from darkFrame/flatFrame pair"))
        self.dfDarkThreshLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This value sets the ADU value above the median value for which a pixel is considered defective due to high dark level (hot pixel).</p><p><br/></p></body></html>"))
        self.dfDarkThreshLabel.setText(_translate("MainWindow", "dark thresh"))
        self.dfGainThreshSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This sets the deviation from median gain above or below which a pixel is considered a defect pixel becuase it requires and excessive gain correction compared to its neighbors..</p></body></html>"))
        self.dfGainThreshLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This value sets the <span style=\" font-weight:700; color:#0000ff;\">gain_delta</span> above or below which a pixel is considered defective due to a gain error.</p><p>The comparison is against the median gain. That is, if the needed gain is outside the range <span style=\" font-weight:700; color:#0000ff;\">median_gain</span> +/- <span style=\" font-weight:700; color:#0000ff;\">gain_delta</span>, then the pixel is defective due to a need for excessive gain correction.</p></body></html>"))
        self.dfGainThreshLabel.setText(_translate("MainWindow", "gain thresh"))
        self.dfSaveAvailableFramesButton.setText(_translate("MainWindow", "Save Dark/Flat frames"))
        self.dfShowFlatFrameButton.setText(_translate("MainWindow", "    Show flatFrame    "))
        self.dfShowGainFrameButton.setText(_translate("MainWindow", "   Show gainFrame    "))
        self.dfShowGainDefectFrameButton.setText(_translate("MainWindow", "   Show gain defects    "))
        self.dfShowDarkFrameButton.setText(_translate("MainWindow", "Show darkFrame"))
        self.dfShowDarkDefectFrameButton.setText(_translate("MainWindow", "Show dark defects"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_11), _translate("MainWindow", "Dark/Flat"))
        self.alignWithStarInfoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p>Note: the Fourier alignment method should be used in preference to the star alignment method becuase it is more precise. Sometimes the Fourier correlation calculation gets stuck on hot pixels and so won\'t align to the star filed but rather align to the hot pixels. In this case, the star alignment will have to be used.</p><p>An easy to use method for performing image alignment by a star is to use an aperture with a name that starts with \'stack\' to follow a bright star through the frames that are to be aligned --- the xy translations of that star are used subsequently to align the frames. </p><p>To use the <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> method: </p><p>1) Place a snap-to-blob aperture on the desired star while at the desired starting frame.</p><p>2) Give that aperture a name that starts with \'stack\' (case-insensitive)</p><p>3) Fill in the top and bottom redact numbers (used for removing timestamp overlays).</p><p>4) Specify the number of frames to stack. </p><p>5) Click on Generate &quot;finder&quot;. What you will see is an &quot;analysis&quot; run (with the \'stack\' aperture following the star), followed by an image alignment run, followed by the appearance of the &quot;finder&quot; image. Note: This is an actual analysis run so data will be collected. </p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.alignWithStarInfoButton.setText(_translate("MainWindow", "Help: align to star"))
        self.alignWithTwoPointTrackInfoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p><span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> requires that a 2 point tracking path be established for the video. A 2 point tracking path is a bit tedious to set up but works very well for frame alignment when there is just a single, possibly disappearing, star. Note that it cannot follow windshake. Use <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> if at all possible whenever there is much windshake. </p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> to get instructions on setting a 2 point tracking path, click on the Help tab, then on the button labeled \'Help for two point tracking\'</p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.alignWithTwoPointTrackInfoButton.setText(_translate("MainWindow", "Help: 2 point track"))
        self.fourierAlignHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>With Fourier transform based image registration, 0.1 pixel resolution is possible as images are &quot;stacked&quot; to produce a &quot;finder&quot;. This results in a high precision image stack that accurately measures the psf of all the stars in the image sequence.</p><p>The &quot;finder\' image is calculated by summing the (aligned) frame stack, and then dividing that sum by the number of frames.</p><p>It is necessary to exclude regions of the image that are covered by timestamp data or other non-image data, but otherwise the registration is performed using the entire image and there is no need for a &quot;stacking&quot; star to be designated, so it is quick and easy to generate this kind of &quot;finder&quot;.</p><p>The accuracy of the instrumental psf is important in the <span style=\" font-weight:700; color:#0000ff;\">TME</span> (Tight Mask Extraction) process, so a Fourier aligned finder image is to be preferred. If this is not possible (perhaps because of an excess of hot pixels which defeat the Fourier correlation calculation), then use the target star as the stack aligning star when possible.</p></body></html>"))
        self.fourierAlignHelpButton.setText(_translate("MainWindow", "Help: Fourier align"))
        self.finderRedactTopLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information.</p><p>For generating a &quot;finder&quot; image, getting rid of the timestamp is <span style=\" font-weight:600; color:#fc0107;\">essential</span> for getting a good image to image registration based on the star field movement. If the timestamp is not removed, then the stacking process will likely register on the timestamp instead.</p><p>This entry is also used when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (takes longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the top get this treatment.</p></body></html>"))
        self.finderRedactTopLinesLabel.setText(_translate("MainWindow", "redact: top "))
        self.finderRedactBottomLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information.</p><p>For generating a &quot;finder&quot; image, getting rid of the timestamp is <span style=\" font-weight:600; color:#fc0107;\">essential</span> for getting a good image to image registration based on the star field movement. If the timestamp is not removed, then the stacking process will likely register on the timestamp instead.</p><p>This entry is also used when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (takes longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the bottom get this treatment.</p></body></html>"))
        self.finderRedactBottomLinesLabel.setText(_translate("MainWindow", "bottom   "))
        self.finderNumFramesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This edit box specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p>Of course, your objective might be to get a \'pretty picture\' of the star field. If so, have at it, but be aware that stars may \'appear\' for which an occultation light curve cannot be extracted when processing is done frame by frame.</p></body></html>"))
        self.finderNumFramesLabel.setText(_translate("MainWindow", "num frames:"))
        self.stackFramesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>To assist in locating a dim target star, an enhanced &quot;finder&quot; image can be generated by aligning and stacking (summing) a number of frames.</p><p>This intensified image can then be used for positioning an aperture on the target star, even though that star might be invisible in a single frame.</p><p>There are two available algorithms for performing image alignment: </p><p>1) <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> uses an aperture with a name that starts with \'stack\' to follow a bright star through the frames that are to be aligned --- the xy translations of that star are used subsequently to align the frames. This is the simplest and most reliable method to use and takes priority over methods 2 and 3. Click the <span style=\" font-weight:600; color:#fc0107;\">Align: star</span> button for how-to-use details.</p><p>2) <span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> uses a 2 point tracking path that has been established for the video. This is more tedious to set up but also works very well for frame alignment although it will not follow windshake. Use 1) whenever there is much windshake. Click the <span style=\" font-weight:600; color:#fc0107;\">Align: 2 point track</span> button for how-to-use details.</p><p>The &quot;finder\' image is calculated by summing the (aligned) frame stack, dividing that sum by the number of frames.</p><p><span style=\" font-weight:600; color:#fc0107;\">General notes:</span></p><p>The edit boxes labelled \'redact top\' and \'redact bottom\' specify how many lines to remove from the top and bottom of the image to get rid of timestamp or other non-image data.</p><p>The edit box labelled \'num frames\' specifies how many frames to register and sum. For the purpose of locating a star that can produce an occultation light curve, a number of frames in the range of 100 to 400 is effective. If this number is set too high, while the target star might become visible in this enhanced image, it is likely to be lost in quantization and noise effects when frame by frame aperture photometry is attempted.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if timestamps were present (but redacted), the &quot;finder&quot; image will show the timestamp of the first frame in the stack, the so-called reference frame that all others are aligned/registered against to build the \'stack\'.</p></body></html>"))
        self.stackFramesButton.setText(_translate("MainWindow", "Make \"finder\" via star align"))
        self.fourierAlignButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button starts the proess of building a finder frame using the entire image (except for timestamp redaction zones) using a Fourier transform based sub-pixel resolution registration method.</p><p>The redact zones (top and bottom) plus the frame count must have been previously set.</p><p>The number of the frame currently displayed will be encoded in the &quot;finder&quot; name and subsequently used to position the video reader to this frame when the &quot;finder&quot; is loaded.</p><p><span style=\" font-weight:700; color:#ff0000;\">Note:</span> If there are too many hot pixels in the recording, the Fourier alignment method will lock onto the hot pixels rather than the star field and defeat the alignment process. In this case, use the star alignment method to generate a finder.</p></body></html>"))
        self.fourierAlignButton.setText(_translate("MainWindow", "Make \"finder\" via Fourier align"))
        self.openFinderPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a file selection dialog with all available &quot;finder&quot; image files highlighted --- it is not uncommon to have more than one.</p><p>The &quot;finder&quot; images generated by PyMovie have a frame number imbedded in the filename. That frame number will be extracted and used to position the video to that frame before displaying the &quot;finder&quot; image.</p><p>By judicious use of static apertures, a constellation of apertures can be placed on the &quot;finder&quot; image and will remain in place when the video frame replaces the &quot;finder&quot; image --- this happens whenever the current frame number is changed.</p></body></html>"))
        self.openFinderPushButton.setText(_translate("MainWindow", "Open an existing  \"finder\""))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "\"finder\""))
        self.flipImagesLeftToRightCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to flip the image left to right.</p></body></html>"))
        self.flipImagesLeftToRightCheckBox.setText(_translate("MainWindow", "Flip images left/right"))
        self.flipImagesTopToBottomCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to invert the Y axes on the main image as well as the two thumbnails.</p><p>This control is necessary because: the origin of composite video images is the upper left corner of the image; for .fits files, the origin is at the lower left corner of the image.</p></body></html>"))
        self.flipImagesTopToBottomCheckBox.setText(_translate("MainWindow", "Flip images top/bottom"))
        self.cascadeCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If checked, lightcurve plots will cascade from the upper left of the monitor diagonally toward the lower right.</p><p>If unchecked, lightcurve plots will stack on top of each other in the center of the monitor.</p></body></html>"))
        self.cascadeCheckBox.setText(_translate("MainWindow", "cascade the lightcurve plots"))
        self.plotSymbolSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the size of the symbols used in the plots to show a data value position. </p><p>If you open a set of plots and would like to see smaller or larger dots, simply close the plots, change the symbol size using this spinner and reopen the plots.</p></body></html>"))
        self.plotSymbolSizeLabel.setText(_translate("MainWindow", "Plot symbol size:"))
        self.gammaLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the video was recorded with a gamma setting other than 1.00, put that value in this spin box (it can be directly edited if the 0.05 steps of the spinner are inappropriate).</p><p>If a value other than 1.00 is present in this edit box, all images will have a gamma reversal applied on a pixel by pixel basis. This is desirable when more accurate photometrics are needed as it improves the linearity of the pixel response to light.</p><p>The reversal equation used is: <span style=\" font-weight:600; color:#fc0107;\">xnew = maxval * ((x / maxval) ^ (1 / gamma))</span> where maxval is either 65535 (for 16 bit images) or 255 (for 8 bit images).</p></body></html>"))
        self.gammaLabel.setText(_translate("MainWindow", "gamma"))
        self.loadNE3lookupTableCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>The Night Eagle 3 has 4 gamma settings: 0.45, 0.55, 0.65, and 0.75. However, the resulting response curves are NOT that of a standard gamma curve. PyMovie is handling this situation by using a custom pixel remapping table that was measured experimentally while the camera was operating at AGC 7, GAMMA 0.75, BRT 20. Testing has shown that there is little reason to operate this camera at any other settings other than DNR which can set to OFF, LOW, MIDDLE, or HIGH at the observer\'s discretion.</p><p>The custom table is loaded when this check box is checked and subsequently used to translate the pixel response curve to something close to linear.</p></body></html>"))
        self.loadNE3lookupTableCheckBox.setText(_translate("MainWindow", "Enable Night Eagle 3 gamma 0.75"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_7), _translate("MainWindow", "Image/Plot"))
        self.manualWcsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button starts a \'manual\' WCS calibration (user guided reference star designation).</p><p><span style=\" font-weight:600; color:#fc0107;\">Manual WCS calibration</span> utilizes two stars with known icrs coordinates together with their xy position in the image to compute a mapping from icrs coordinates to pixel coordinates.</p><p>When this button is pressed, all previous manual WCS calibration data is erased (you have to confirm this action). Then the work flow expected is:</p><p>1) Use the VizieR query to get the icrs coordinates of the first reference star. (So do your star chart with UCAC4 annotations).</p><p>2) Put an aperture on that star.</p><p>3) Adjust (if necessary) the aperture so that the centering is satisfactory.</p><p>4) Right click on the aperture and click on <span style=\" font-weight:600; color:#fc0107;\">Set RA Dec (from VizieR query results)</span></p><p><span style=\" color:#000000;\">5) Repeat steps 1...4 for the second reference star.</span></p><p><span style=\" color:#000000;\">6) If you have already defined the target coordinates, an aperture will immediately appear at the proper image location, otherwise ...</span></p><p><span style=\" color:#000000;\">7) ... use the VizieR query to get the target coordinates and then click the </span><span style=\" font-weight:600; color:#fc0107;\">Set as target</span><span style=\" color:#000000;\"> button. The target aperture will then appear.</span></p><p><br/></p></body></html>"))
        self.manualWcsButton.setText(_translate("MainWindow", "Manual WCS calib"))
        self.frameToFitsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is used to get a WCS calibration for the current image by utilizing the on-line service nova.astrometry.net </p><p>If the WCS calibration is successful, while the frame that was submitted for calibration is displayed, hovering the mouse over the image will cause the RA/DEC information to be displayed in the status bar at the bottom left of the window. Additionally, if the w key is pressed while RA/DEC info is available, a box will popup with RA/DEC information formatted for easy entry into C2A.</p><p>If this service fails (see discussion below) then you could try the<span style=\" font-weight:600; color:#fc0107;\"> Manual WCS calibration</span> button. It prompts you to put an aperture around two known stars in your image by using a star chart (preferably with UCAC4 star designations). If those stars are sufficiently far apart, we can use the icrs coordinates in conjuction with the xy position of the aperture to \'calibrate\' that image.</p><p>nova.astrometry.net is designed to do \'blind\' identification and WCS calibration on star field images. But it will not be able to identify images that have a too narrow field of view. If your field of view is under 15 arcmin, it is not likely to be able to calibrate that image and it will spend a long time (many minutes) trying. If an image is going to be successfully identified, it will take only a few seconds of cpu time after getting a job assigned (which takes one to two minutes).</p><p>Note: another possible reason for a \'failure\' is that the camera pixels used for the video were not square and the proper pixel width and height values were not specified properly.</p><p>Clicking this button reads the current frame and redacts the timestamp area by replacing all bytes in the timestamp zone with the Robust background (constant value).</p><p>The number of lines to be redacted are controlled by the <span style=\" font-weight:600; color:#fc0107;\">redact lines</span> edit box.</p><p>This redacted image is written as a file suitable for submission to nova.astrometry.net together with a user entered target star position (RA and Dec at J2000). The image will have been resized based on the pixel width and height information for non-square pixels in the source camera.</p><p>The entries for the star position values are entered into a star position dialog that will appear if no star position has yet been defined.</p><p>That same dialog form provides for the entry of the user\'s nova.astrometry.net api key. This value will be \'sticky\' (preserved across runs of PyMovie) and is required for submitting images for WCS calibration. It\'s easy (and free) to obtain. Simply go to nova.astrometry.net and sign in by clicking on your choice of credential supplier, no need to create a username/password combination. After signing in, click on My Profile and your api key will be displayed there.</p></body></html>"))
        self.frameToFitsButton.setText(_translate("MainWindow", "astrometry WCS calib"))
        self.label_4.setText(_translate("MainWindow", "<html><head/><body><p>Note: if WCS calibration succeeds, hovering over the</p><p>calibrated image will cause RA/DEC information to</p><p>be displayed in the status bar (bottom, left) and</p><p>pressing the w key will cause a popup box with</p><p>RA/DEC information formatted for easy entry into C2A</p></body></html>"))
        self.wcsRedactTopLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image top to remove to get rid of timestamp information when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (take longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacing those lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the top get this treatment.</p></body></html>"))
        self.wcsRedactTopLinesLabel.setText(_translate("MainWindow", "     redact: top"))
        self.wcsRedactLinesTopEdit.setText(_translate("MainWindow", "0"))
        self.wcsRedactLinesBottomEdit.setText(_translate("MainWindow", "0"))
        self.wcsRedactBottomLinesLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This entry is used to specify how many lines from the image bottom to remove to get rid of timestamp information when preparing a frame for submission to nova.astrometry.net for WCS calibration.</p><p>If there is a timestamp overlay, its presence may make the WCS location and calibration harder (take longer) for nova.astrometry.net. So, before submitting an image to nova.astrometry.net, we like to \'redact\' the timestamp data by replacingthose lines with the average background (sampled from the center of the image). The value in this box controls how many lines from the bottom get this treatment.</p></body></html>"))
        self.wcsRedactBottomLinesLabel.setText(_translate("MainWindow", "bottom"))
        self.pixelHeightLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the camera used for the video does not have square pixels, the image sent to nova.astrometry.net for WCS calibration will need to have the image resized to compensate for the rectangular shape of the camera pixels. This is required so that the plate scale (arcseconds/pixel) will be the same in the x direction as the y direction.</p><p>This correction is needed for manual WCS calibration as well, but is accomplished in a different manner: a rescaling of x and y dimensions during the calculations rather than an image resize.</p><p>If you know that the camera pixels are square, enter the same number for pixel height and pixel width. The units don\'t matter. The number used doesn\'t matter. All that matters is that pixelWidth / pixelHeight = 1.000 (i.e., pixel aspect ratio = 1.000).</p><p>If the camera pixels are not square, but instead are rectangular, enter the correct width and height of the pixels in these edit boxes. The units used do not matter. All that matters is the ratio of these two numbers.</p><p>Example: for a Watec 910 camera, enter 9.8 as pixelHeight and 8.4 as pixelWidth. (The units are actually microns, but that does not matter.)</p><p>The RunCam Night Eagle Pro II camera has square pixels (6x6 microns). You can enter a 6 in both edit boxes for this camera.</p></body></html>"))
        self.pixelHeightLabel.setText(_translate("MainWindow", " pixel height: "))
        self.pixelHeightEdit.setText(_translate("MainWindow", "4"))
        self.pixelWidthEdit.setText(_translate("MainWindow", "4"))
        self.pixelWidthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the camera used for the video does not have square pixels, the image sent to nova.astrometry.net for WCS calibration will need to have the image resized to compensate for the rectangular shape of the camera pixels. This is required so that the plate scale (arcseconds/pixel) will be the same in the x direction as the y direction.</p><p>This correction is needed for manual WCS calibration as well, but is accomplished in a different manner: a rescaling of x and y dimensions during the calculations rather than an image resize.</p><p>If you know that the camera pixels are square, enter the same number for pixel height and pixel width. The units don\'t matter. The number used doesn\'t matter. All that matters is that pixelWidth / pixelHeight = 1.000 (i.e., pixel aspect ratio = 1.000).</p><p>If the camera pixels are not square, but instead are rectangular, enter the correct width and height of the pixels in these edit boxes. The units used do not matter. All that matters is the ratio of these two numbers.</p><p>Example: for a Watec 910 camera, enter 9.8 as pixelHeight and 8.4 as pixelWidth. (The units are actually microns, but that does not matter.)</p><p>The RunCam Night Eagle Pro II camera has square pixels (6x6 microns). You can enter a 6 in both edit boxes for this camera.</p></body></html>"))
        self.pixelWidthLabel.setText(_translate("MainWindow", ": pixel width"))
        self.ucac4Label.setToolTip(_translate("MainWindow", "<html><head/><body><p>The entry here must be of the form XXX-XXXXXX otherwise you will get a \'star not found\' message instead of the coordinates you were seeking.</p></body></html>"))
        self.ucac4Label.setText(_translate("MainWindow", "UCAC4"))
        self.starIdEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>The entry here <span style=\" text-decoration: underline;\">must</span> be of the form XXX-XXXXXX otherwise you will get a \'star not found\' message instead of the coordinates you were seeking.</p></body></html>"))
        self.queryVizierButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button triggers a query to Vizier for the J2000 coordinates of a UCAC4 star. The coordinates found are displayed in the edit box below in hms dms format.</p><p>The UCAC4 caltalog is used (VizieR catalog I/322A)</p></body></html>"))
        self.queryVizierButton.setText(_translate("MainWindow", "Query VizieR"))
        self.saveTargetLocButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you are working in a FITS folder or an AVI-WCS folder, clicking this button causes the location in the edit box to the left to be written to the file <span style=\" font-weight:600; color:#fc0107;\">target-location.txt </span>in that folder.  This is how one sets the coordinates of star-to-be-occulted --- the \'target\'.</p></body></html>"))
        self.saveTargetLocButton.setText(_translate("MainWindow", "Set as target"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "WCS"))
        self.toolButton_2.setText(_translate("MainWindow", "The best and most relevant help is obtained by right-clicking\n"
"on buttons. Most buttons have help info built into them.\n"
"There are some labels that provide the same service ---\n"
"this is used when the GUI element already has a right-click\n"
"action associated with it."))
        self.twoPointHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Two point tracking is a tool used primarily in conjunction with drift-through videos when there is no other suitable star for tracking other than the target star which will be (hopefully) disappearing somtime during the video.</p><p>Two point tracking allows a \'tracking path\' to be associated with a yellow aperture by using it to locate a star that is visible at two points in the video sequence and then recording the coordinate/frame values at those two points. </p><p>A \'tracking path\' is a straight line across an image that is to be followed frame-by-frame by the center of a yellow tracking aperture as the video is analyzed. This can be used to \'follow\' an object that disappears completely, particularly useful in the situation where there are no other stars that remain visible enough to provide a separate tracking reference. And, as always, the presence of a yellow aperture locks all apertures into a \'constellation\' that moves as a unit.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> to ease the task of re-positioning the yellow aperture as you advance to later frames, jogging on newly added apertures is automatically enabled.</p><p>To define a \'tracking path\', use a <span style=\" font-weight:600; text-decoration: underline;\">single</span> yellow aperture and position that aperture at a desired point early in the video (it does <span style=\" font-weight:600;\">not</span> have to be frame 0) and do a right-click on the aperture and then left-click on the menu item <span style=\" font-weight:600; color:#fc0107;\">Use current position as early track path point</span></p><p><span style=\" color:#000000;\">To complete the definition of the \'tracking path\', position the tracking aperture at a desired point late in the video (it does not have to be the last frame), do a right-click on the aperture and then left-click on the menu item </span><span style=\" font-weight:600; color:#fc0107;\">Use current position as late track path point</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> with a \'tracking path\' defined, the entire aperture constellation will move in a straight line (defined by the xy and frame number values of the early and late points). While this constellation will not itself follow windshake, stars can continue to \'dance\' within the apertures and will be \'followed\' by the mask generating routines --- for red apertures, it will look for a bright blob within an 8 pixel radius; for yellow apertures, it will look for the brightest blob anywhere in the aperture. You can always set a very high threshold to force the use of fixed circular masks in apertures where you want to suppress this behavior.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> If you delete the yellow aperture (or add a second one), the current tracking path data will be erased.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span><span style=\" color:#000000;\"> You can overwrite either of the data points at any time.</span></p><p><span style=\" color:#000000;\">If an aperture group is saved, any tracking path defined will be saved as well.</span></p></body></html>"))
        self.twoPointHelpButton.setText(_translate("MainWindow", "Help for two point tracking"))
        self.transportHelp.setToolTip(_translate("MainWindow", "<html><head/><body><p>Context menus invoked by the usual mouse right-click are used to place measurement apertures, change their properties, name them, remove them, and control the image view itself.</p><p>For controlling the image view itself, a left-click and hold will allow the image to be panned in all directions with subsequent mouse movement.</p><p>A right-click and hold allows zooming in the direction of subsequent mouse movement.</p><p>A right-click in a region that does not contain a measuring aperture will cause a context menu to appear that has four menu entries for adding measuring apertures either singly or in \'nests\' of 5 or 10 apertures. </p><p>A <span style=\" font-weight:600; text-decoration: underline;\">white</span> aperture should be placed using the <span style=\" font-weight:700; color:#0000ff;\">Add static (fixed circular) mask</span> (so that it does not move during the analysis.</p><p>On this same context menu, there are menu items for controlling aspects of the image view itself; the most used menu item will be <span style=\" font-weight:600; color:#fc0107;\">View all</span>, used after a <span style=\" font-weight:600; text-decoration: underline; color:#fc0107;\">scroll wheel zoom</span> or <span style=\" text-decoration: underline; color:#fc0107;\">left-click-drag-for-pan</span> have been used to adjust the view to return the size and position to the original condition.</p><p>A right-click <span style=\" font-weight:600; text-decoration: underline;\">inside</span> a measurement aperture brings up a context menu that allows you to change propertires of the aperture. You will be most concerned with the color of the aperture:</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">yellow</span> aperture around a bright star causes that star to be used as a tracking reference. If you select a single star as a tracking reference, translation movements (the image as a whole moves some number of pixels up, down, and sideways) of the star field will be tracked. The aperture constellation as a whole will be translated.</p><p>You can add a second yellow aperture (no more than two are allowed) if there a possibility of field rotation as well as field translation. In this case, tracking equations are used that allow for the aperture constellation as a whole to be both rotated and translated in order to follow the star field.</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">green</span> aperture is connected to the threshold setting spinner to make it easier to modify threshold settings. That spinner has the longish title: <span style=\" color:#fc0107;\">set mskth counts above bkavg</span></p><p>A <span style=\" font-weight:600; text-decoration: underline;\">white</span> aperture is useful when flash-tags have been recorded in the video. The special thing about a white aperture is that all pixels in the aperture are summed and output as the \'signal\' with no background subtraction. Such a signal can be employed by PyOTE to provide an alternative to the timestamp overlay from Video Time Inserters. In addition, a \'white\' aperture always stays where placed --- it does not track and is never part of an aperture constellation group (does not \'follow\' a yellow aperture).</p><p>A <span style=\" font-weight:600; text-decoration: underline;\">red</span> aperture has the special property that it will only form a mask from a blob that is within 8 pixels of the center. This helps keep a nearby bright star from interfering with mask formation.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note: </span><span style=\" font-weight:600; color:#0000ff;\">An aperture is never allowed to extend outside the image boundary. As a result, if an aperture is placed on a star that is close to the image edge and that star subsequently moves closer to the edge, tracking will be lost when the aperture bumps up against edge. In this case, use of a smaller aperture will allow tracking closer to the edge.</span></p><p><span style=\" font-weight:700; color:#ff0000;\">Naming conventions for apertures:</span></p><p>If you want to base NRE on this star\'s image, begin the name with \'psf-star\' (without the quotes).</p><p>A star/aperture so named will be the one used in estimating the instrumental psf when the<br/>generate NRE psf\' button is pressed.</p><p>Of course, only a single aperture with a name starting with \'psf-star\' is allowed, but <span style=\" font-weight:700;\">if you want other stars<br/>to use NRE</span>, put the string \'psf-star\' somewhere in the name. (Usually the psf would be determined from the target star, but<br/>you can control this by using the naming conventions described here.)</p><p>If you want to suppress the re-centering of static masks within an<br/>aperture, put the string \'no-rc\' (or \'no_rc\' or \'no rc\') somewhere in the name. (Dynamic masks must<br/>relocate to do their job, so the presence of a \'no-rc\' code will be ignored.)</p><p>Apertures named \'empty\' or \'no-star\', or \'no_star\' or \'no star\' are<br/>treated as though they contain the \'no-rc\' string - this is because the<br/>N-brightest-pixel-mass-centroid re-centering of static circular masks,<br/>if allowed to \'hunt\' within the aperture, will find opportunistic<br/>clumps of pixels that are a little brighter than other clumps and thus<br/>generate a tiny, but false, signal - disabling recentering prevents this.))</p></body></html>"))
        self.transportHelp.setText(_translate("MainWindow", "Help for image area (aperture placement, etc)"))
        self.documentationPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking on this button will open a pdf file that provides additional documentation beyond that incorporated in the <span style=\" font-weight:600; color:#fc0107;\">right-click-for-help</span> system (which will/should be your first stop for assistance).</p></body></html>"))
        self.documentationPushButton.setText(_translate("MainWindow", "Documentation"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Help"))
        self.appSizeToolButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> The aperture size selected here will only take effect when PyMovie is closed and then reopened. The selected value will be used to set the<span style=\" font-weight:600; color:#fc0107;\"> Select aperture size</span> spinner on the main page when PyMovie starts up.</p></body></html>"))
        self.appSizeToolButton.setText(_translate("MainWindow", "aperture size to be\n"
"used at startup"))
        self.defAppSize51RadioButton.setText(_translate("MainWindow", "51"))
        self.defAppSize41RadioButton.setText(_translate("MainWindow", "41"))
        self.defAppSize31RadioButton.setText(_translate("MainWindow", "31"))
        self.defAppSize21RadioButton.setText(_translate("MainWindow", "21"))
        self.defAppSize11RadioButton.setText(_translate("MainWindow", "11"))
        self.sigmaLevelToolButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>When a snap-to-blob aperture is initially placed on an image, a mask threshold will be calculated as either one, two, or three sigma. (Sigma is extracted by the Robust Mean extraction routine from the background noise and is the standard deviation of the background.)</p><p>This radio button group determines whether one, two, or three sigma will be used as the mask threshold when the next snap-to-blob aperture is placed.</p></body></html>"))
        self.sigmaLevelToolButton.setText(_translate("MainWindow", "Number of sigmas \n"
"(std-dev) to set\n"
"mask threshold \n"
"above background"))
        self.oneSigmaRadioButton.setText(_translate("MainWindow", "1 sigma"))
        self.twoSigmaRadioButton.setText(_translate("MainWindow", "2 sigma"))
        self.threeSigmaRadioButton.setText(_translate("MainWindow", "3 sigma"))
        self.defaultMaskRadiusToolButton.setText(_translate("MainWindow", "Default mask radius.\n"
"This takes effect on next\n"
"aperture placement."))
        self.radius20radioButton.setText(_translate("MainWindow", "2.0"))
        self.radius24radioButton.setText(_translate("MainWindow", "2.4"))
        self.radius32radioButton.setText(_translate("MainWindow", "3.2"))
        self.radius40radioButton.setText(_translate("MainWindow", "4.0"))
        self.radius45radioButton.setText(_translate("MainWindow", "4.5"))
        self.radius53radioButton.setText(_translate("MainWindow", "5.3"))
        self.radius68radioButton.setText(_translate("MainWindow", "6.8"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_9), _translate("MainWindow", "Pref."))
        self.lineNoiseFilterCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Under some conditions for some cameras,&nbsp;the background will exhibit a \'patterning\' where some scan lines are a little brighter than others.</span></p><p><span style=\" font-size:18pt;\">We refer to this \'patterning\' as \'line noise\'.</span></p><p><span style=\" font-size:18pt;\">If you check this box,&nbsp;images will be subjected to a median filter on a line by line basis.</span></p><p><span style=\" font-size:18pt;\">The filter operates by finding the median value along a scan line and using this value to adust all rows such that they share a common median value.&nbsp;This procedure suppresses/eliminates the \'patterning\'.</span></p><p><span style=\" font-size:18pt;\">It is up to you to decide whether this is a valid procedure,&nbsp;but I have provided one tool that may help: I accumulate the line-by-line median values and calculate the average median value for each row.&nbsp;This plot can be displayed by clicking on the </span><span style=\" font-size:18pt; font-weight:600; color:#0000ff;\">Show Median Profile</span><span style=\" font-size:18pt;\"> button below.&nbsp;If the \'patterning\' is due to chip/camera construction,&nbsp;the median values for a line will be consistent from frame to frame and this plot will show the row to row variation in the background brightness of the rows.&nbsp;If there is a consistent and significant row to row brightness difference,&nbsp;I believe you have good justification in applying this filter as it \'corrects\' a systematic/instrumental effect from the chip/camera design.</span></p><p><span style=\" font-size:18pt;\">If,&nbsp;instead,&nbsp;the row to row brightness differences are random,&nbsp;the average median value from row to row will not differ much.&nbsp;That means that the chip/camera is NOT showing instrumental bias and you should be cautious and conservative in deciding whther to use median line filtering for such a video.</span></p></body></html>"))
        self.lineNoiseFilterCheckBox.setText(_translate("MainWindow", "apply \'line noise\' median filter"))
        self.horizontalRadioButton.setText(_translate("MainWindow", "apply horizontally"))
        self.verticalRadioButton.setText(_translate("MainWindow", "apply vertically"))
        self.bothRadioButton.setText(_translate("MainWindow", "apply horizontally and vertically"))
        self.upperTimestampLineLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">For OCR and the median filter to work properly,&nbsp;the median filter must avoid processing lines that include timestamp or other overlaid annotation.</span></p><p><span style=\" font-size:18pt;\">Use this spinner to move the red line from the topmost line down (increasing spinner values) until any timestamp or annotations are above it.</span></p></body></html>"))
        self.upperTimestampLineLabel.setText(_translate("MainWindow", "upper timestamp limit"))
        self.lowerTimestampLineLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">For OCR and the median filter to work properly, the median filter must avoid processing lines that include timestamp or other overlaid annotation.</span></p><p><span style=\" font-size:18pt;\">Use this spinner to move the yellow line from the bottom line up (increasing spinner values) until any timestamp or annotations are below it.</span></p></body></html>"))
        self.lowerTimestampLineLabel.setText(_translate("MainWindow", "lower timestamp limit"))
        self.showMedianProfileButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">During the median filtering on each processed frame,&nbsp;the line-by-line median values are accumulated so that when this button is clicked,&nbsp;an average median value for each row can be calculated and displayed.</span></p><p><span style=\" font-size:18pt;\">If the \'line patterning\' is due to chip/camera construction,&nbsp;the median values for a line will be consistent from frame to frame and this plot will show a row to row variation in the background brightness of the rows.&nbsp;If there is a consistent and significant row to row brightness difference,&nbsp;then you have good justification in applying this filter and using the resulting light-curve because this filter process has \'corrected\' a systematic/instrumental effect from the chip/camera design.</span></p><p><span style=\" font-size:18pt;\">If,&nbsp;instead,&nbsp;the row to row brightness differences are random,&nbsp;the average median value from row to row will not differ much.&nbsp;That means that the chip/camera is NOT showing instrumental bias and you should be cautious and conservative in deciding whther to use median line filtering for such a video.</span></p></body></html>"))
        self.showMedianProfileButton.setText(_translate("MainWindow", "Show Median Profile"))
        self.lunarCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Only for use with lunar occultations</span></p><p><span style=\" color:#000000;\">When an aperture is placed on a sunlit lunar limb, it will contain pixels from the sky, pixels from the lunar limb, and pixels from the about-to-be-occulted star. This is also true for a fixed circular sampling mask positioned on the star. In that situation, what is the \'correct\' way to subtract \'background\'? Limovie has answered that question by providing a special aperture (Avoid Sunlit Face) that can be positioned so that a semi-circular area can be oriented so that only sky pixels are contained. Those pixels are then used to calculate the background value.</span></p><p><span style=\" color:#000000;\">When this box is checked, PyMovie does effectively the same thing but by a different method: it uses a statistical analysis of all the pixels in an aperture and sorts out which are from the sky and which are not by how their intensities are distributed. You can check what is happening by clicking on the Plot Robust Mean button to see where it placed the green line that shows the calculated mean value.</span></p></body></html>"))
        self.lunarCheckBox.setText(_translate("MainWindow", "lunar"))
        self.useYellowMaskCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there is significant wind shake during the occultation, the use of a default circular mask is inappropriate because we know that the star image is not circular but rather more snake-like.</p><p>However, it is reasonable to expect that the wanderings of the tracking star are the same as the wanderings of the target star and so a mask computed from the tracking star, while it will probably contain more pixels than one might like, has the correct shape to be used for the target star as well.</p><p>Checking this box will cause the \'yellow\' mask to be used for measuring all target images.</p><p>This is a \'last hope\' option: good luck with it.</p></body></html>"))
        self.useYellowMaskCheckBox.setText(_translate("MainWindow", "yellow mask = default"))
        self.view3DButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a new window that shows a 3D rendering of the Thumbnail One image.</p></body></html>"))
        self.view3DButton.setText(_translate("MainWindow", "Show 3D thumbnail"))
        self.allowNewVersionPopupCheckbox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt;\">This splash screen can be disabled on the </span><span style=\" font-size:10pt; font-weight:700; color:#0000ff;\">Misc.</span><span style=\" font-size:10pt;\"> tab.</span></p><p><span style=\" font-weight:700; color:#ff0000;\">What\'s new with this version:</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">A video archive feature is now available. It operates by writing selected apertures frame by frame to a FITS frame folder during light curve extraction. Apertures are selected by including the string archive anywhere in the aperture name. <br/>Saving only aperture data results in a much smaller video file to be archived. For example, the number of bytes in a 31x31 aperture is less than 0.3% of the number of bytes in a 720x480 video frame.<br/><br/>When multiple apertures are selected, they are placed in a strip and written to a FITS file together with timestamp data and a legend that gives the name of the aperture at each position in the strip.<br/><br/>It is recommended that a 31x31 aperture be used at a minimum. This would allow a 21x21 aperture to be placed on the archived apertures for TME extraction during a reprocessing run.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">Typically, one would archive the target aperture, the tracking aperture, and a reference aperture at a minimum.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">The archive folder can/should be zipped to get maximum compression as FITS files have repetitive meta data in each frame.</span></p><p><span style=\" font-weight:700; color:#ff0000;\">Previously:</span></p><p><span style=\" font-size:10pt; font-weight:700; color:#ff0000;\">1) </span><span style=\" font-weight:700; color:#0000ff;\">Dark/Flat</span> tab has been added. If a 10 second (or longer) dark video is recorded prior to, or following an observation (with camera setting unchanged), that video can be analyzed for defective (hot) pixels in this tab. PyMovie will use this information to flag any light curve points whose sampling mask overlapped any defect pixel during light curve extraction. This information is made available to PyOTE in the csv file and those points are shown enclosed by a red doughnut by PyOTE. This is an important quality control tool.</p><p>If a contemporaneous recording of a flat is available (intensity level about 75% of max linear range is desirable), that information can be combined with the dark video to produce correction information that can normalize the response of all the pixels. This can reduce noise and the effects of amplifier glow and vignetting. Such correction is optional - there is a check box to enable this located to the left of the transport controls under the main image. </p><p>Even if pixel normalization (correction) is not wanted or needed, some additional defective pixels may be located during the processing of the flat video, most notably pixels that are stuck at a low value.</p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; font-size:10pt; font-weight:700; color:#ff0000;\">2)</span><span style=\" font-family:\'Arial\',\'sans-serif\';\">Added a new (and superior) method of generating finder frames. This method uses a Fourier transform based image to image correlation calculation to determine frame alignments to 0.1 pixel resolution. This does not require a stacking star to be designated and so is easier and quicker to use. This method should be used wherever possible to generate finder frames as they are better formed and more accurately identify star positions. This is the preferred finder to be used for the new (described below) Tight Mask Extraction (TME) light-curve generator.<br/><br/>If there are dominant hot-pixels in the video, the fourier aligner may lock onto the hot-pixel constellation rather than the star field and cause the finder process to fail. In this case, reverting to a stacking star or a 2 point track will be necessary.</span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-size:10pt;\"><br/></span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; font-size:10pt; font-weight:700; color:#ff0000;\">3)</span><span style=\" font-family:\'Arial\',\'sans-serif\';\">A new and very promising method of light-curve extraction has been added. It is called Tight Mask Extraction (TME) and leverages the improved fourier-aligned finder frame process described above.<br/><br/>When a TME aperture is placed on a star while a finder image (fourier-aligned finder is preferred) is being displayed, the instrumental psf for that star is used to calculate an optimally tight mask. That mask is determined using the growth-curve method: starting with the brightest pixel in the psf an SNR metric is calculated. Then the next brightest pixel is included, which causes the signal to increase, as well as the noise. A new SNR metric is calculated. That metric will get better (larger) as additional pixels are included in the mask, but eventually the metric will stop increasing. At that point the optimally tight mask has been determined (see the editing possibility described below).<br/><br/>The optimally tight mask determined above is treated as a static mask (in that no re-calculations are performed) during the analysis process.<br/><br/>It is reasonable to think of a TME sampling mask as an optimal non-circular static mask.</span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-size:10pt;\"><br/><br/></span><span style=\" font-family:\'Arial\',\'sans-serif\';\">That mask is applied to pixel locations controlled by a search grid (size is selectable on the </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0070c0;\">Median/Misc</span><span style=\" font-family:\'Arial\',\'sans-serif\';\"> tab) for each frame to find the maximum signal for that frame  a form of optimal alignment of the sampling mask with respect to the image  it hunts for the largest signal in that search grid. This hunting behavior can be suppressed by including the string </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#ff0000;\">no-rc</span><span style=\" font-family:\'Arial\',\'sans-serif\';\"> in the aperture name. This makes it possible to place two TME apertures on a target, one that hunts and one that doesnt.<br/><br/>Testing indicates that this method reduces baseline noise (sigmaB), sometimes significantly.<br/><br/>It is now possible to edit a static mask when a finder image is being displayed. Simply left click on any pixel being shown in Thumbnail Two or Thumbnail One to toggle that mask pixel on or off. This can be used to either slightly modify static masks, or to experiment with mask designs of your own. The modified masks can be preserved by saving them as part of an aperture group.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#ff0000;\">4) Noise Reduction Extraction has been removed:</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\">Extensive testing was done to determine if there was any value in keeping the NRE aperture. The conclusion was that NRE is rarely the best aperture (and when best, TME is equivalent) and so has been moth balled.</span><span style=\" font-family:\'Arial\',\'sans-serif\';\"><br/><br/></span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#ff0000;\">Important tip:</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">Before doing an analysis, be sure to set the csv order in which the aperture data columns will be output to the csv file. This is easily done by clicking on the </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">Examine/change aperture settings</span><span style=\" font-family:\'Arial\',\'sans-serif\';\"> button. In the panel that appears, the rightmost column is titled </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">csv output order</span><span style=\" font-family:\'Arial\',\'sans-serif\';\">. Use that column to set the expected best aperture for the target to 0 - this is because when PyOTE reads this file, it will be the first lightcurve displayed. With the latest version of PyOTE, all the other data sets/lightcurves will be accessible through a drop-down list and the order of items in this list are controlled by their order in the csv file, so set the csv order to make this list order be convenient for you.<br/><br/></span></p></body></html>"))
        self.allowNewVersionPopupCheckbox.setText(_translate("MainWindow", "show \"new version\" info"))
        self.tmeSearch3x3radioButton.setText(_translate("MainWindow", "TME 3x3 search grid"))
        self.tmeSearch5x5radioButton.setText(_translate("MainWindow", "TME 5x5 search grid"))
        self.tmeSearch7x7radioButton.setText(_translate("MainWindow", "TME 7x7 search grid"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_10), _translate("MainWindow", "Median/Misc"))
        self.stopFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this edit box to set the frame number to the end of a series of \'lens cap on\' frames.</p><p>This series of frames while be used to identify the coordinates of pixels that are not behaving normally.</p></body></html>"))
        self.stopFrameLabel.setText(_translate("MainWindow", "stop frame: "))
        self.startFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this edit box to set the frame number to the beginning of a series of \'lens cap on\' frames.</p><p>This series of frames while be used to identify the coordinates of pixels that are not behaving normally.</p></body></html>"))
        self.startFrameLabel.setText(_translate("MainWindow", "start frame: "))
        self.activateTimestampRemovalButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there is a timestamp overlay on the video, it must be removed during the development of the <span style=\" font-weight:600; color:#0000ff;\">pixels-to-fix</span> table.</p><p>Click this button to activate the spinners below and place a red horizontal line at the very top of the image and a yellow horizontal line at the very bottom.</p><p>These lines can then be positioned most easily by hovering the mouse cursor over spinner and rolling the mouse scroll wheel.</p><p>Alternatively, you can click the up/down buttons on the spinner or even type a number directly into the box.</p></body></html>"))
        self.activateTimestampRemovalButton.setText(_translate("MainWindow", "Activate timestamp removal"))
        self.cmosShowRedactionLinesCheckBox.setText(_translate("MainWindow", "  Show timestamp redaction lines"))
        self.upperTimestampPixelLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This \'spinner\' controls the redaction of timestamp information that is at the top of the image.</p><p>The redaction zone is indicated by a red line that will appear from the top whenever the spinner value is non-zero.</p><p>You can change the spinner value by typing a number in the box, clicking the up/down arrows, or using the scroll wheel when the mouse cursor is in the spinner.</p></body></html>"))
        self.upperTimestampPixelLabel.setText(_translate("MainWindow", "upper timestamp limit"))
        self.lowerTimestampPixelLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This \'spinner\' controls the redaction of timestamp information that is at the bottom of the image.</p><p>The redaction zone is indicated by a yellow line that will appear from the bottom of the image whenever the spinner value is non-zero.</p><p>You can change the spinner value by typing a number in the box, clicking the up/down arrows, or using the scroll wheel when the mouse cursor is in the spinner.</p></body></html>"))
        self.lowerTimestampPixelLabel.setText(_translate("MainWindow", "lower timestamp limit"))
        self.buildDarkAndNoiseFramesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use the start and stop frame numbers set in the edit boxes above to create two special frames stacked from those frames.</p><p>One special frame is called a \'dark frame\'. It is simply the sum of the frame set divided by the number of frames - a simple &quot;finder&quot; frame. This frame will accentuate pixels that are consistently too dark or too bright compared with their more numerous neighbors in the way that &quot;finder&quot; frames do for star fields.</p><p>Since we are dealing with lens-cap-on (dark) frames, there is no observation noise exciting pixel responses, only the read noise of the camera. Healthy pixels will have very similar levels of such read noise. But unhealthy pixels will either exhibit noise in excess of expected read noise, or not enough noise, a sign that the pixel is unresponsive - a dead pixel.</p><p>In the second special frame we measure the read noise of each pixel (a measure of how much it sparkles computed over the frame set) and put that value in a frame at the coordinates of that pixel. We call this a read noise frame and it shows pixels that are too noisy (sparkling pixels) or with too little noise (dead pixels) compared with their more numerous neighbors.</p></body></html>"))
        self.buildDarkAndNoiseFramesButton.setText(_translate("MainWindow", "Build dark frame and read noise frame"))
        self.pixelPanelInfoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This panel provides a way to deal with the thousands of out-of-normal (outlaw pixels that don\'t follow the \'rules\') that frequently appear in CMOS camera videos.</p><p>Examples of abnormal pixels in this context are: pixels stuck at some high value (hot-pixel); pixels that \'sparkle\' (bright and abnormally noisy); dark pixels (unresponsive).</p><p>Fortunately these pixels nearly always appear in isolation - they are surrounded by healthy pixels that can then be used to replace the unhealthy pixel value with a reasonable and relevant value - the average of its neighbors.</p><p>Such replacement can even be used during analysis (but test it) because one pixel in a star image being replaced by the average value of its neighbors will have a very small effect on the recorded intensity yet the overall noise in an extracted light-curve is likely to be slightly reduced.</p><p>The steps in the procedure are:</p><p>1) Click the <span style=\" font-weight:600; color:#0000ff;\">Activate timestamp removal</span> button. This enables most of the other controls in this panel.</p><p>2) If there is information at the top and/or bottom of the image that needs to be excluded (redacted), use the spinners provided to position a line near the top (it will be red line that appears when the spinner value is non-zero) to just below any top edge information overlay, and position a line near the bottom (a yellow line will appear) to just above any bottom edge information overlay.</p><p>3) Select the starting and ending frame numbers of the lens-cap-on frame sequence to be used to identify unhealthy pixels. A hundred frames is usually adequate.</p><p>4) Click the <span style=\" font-weight:600; color:#0000ff;\">Build dark frame and read noise frame</span> button. Watch the current frame edit box to determine the progress</p><p>5) Click the <span style=\" font-weight:600; color:#0000ff;\">Show dark frame </span><span style=\" color:#000000;\">button</span> and follow the instructions provided in the plot legend box to extract the coordinates of too dark or too bright pixels.</p><p>6) Click the <span style=\" font-weight:600; color:#0000ff;\">Show read noise frame</span> button and follow the instructions provided in the plot legend box to extract the coordinates of dead or too noisy (sparkly) pixels.</p><p>7) Click the <span style=\" font-weight:600; color:#0000ff;\">Build pixel correction table</span> button to compose the composite pixel correction coordinates table with duplicate entries removed.</p><p>8) If desired, save the pixel correction table for future use. The name given to the table should reflect the camera, its gain setting, and date.</p><p><br/></p><p><span style=\" font-weight:600; color:#fc0107;\">NOTE:</span> You can examine the isolation of outlaw pixels by displaying either the dark frame or the read noise frame and zooming in. The isolation can then be clearly seen and confirmed.</p></body></html>"))
        self.pixelPanelInfoButton.setText(_translate("MainWindow", "Click me for help/info"))
        self.showBrightAndDarkPixelsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to show the \'dark frame\' and simultaneously create a plot showing the distribution of pixel values in that frame.</p><p>The pixel distribution plot will have a broad middle section. This is the group of pixels that are behaving similarly to their neighbors and are presumably the \'healthy\' pixels.</p><p>The plot has two movable horizontal lines, a green one and a blue one. Use your mouse to \'grab\' the green line and move it up. Then use your mouse to \'grab\' the blue line and drag it down. Position these lines so that they enclose the \'normal\' \'healthy\' pixels. When satisified, click the yellow button at the upper left to cause the creation of the dark and bright pixel list.</p></body></html>"))
        self.showBrightAndDarkPixelsButton.setText(_translate("MainWindow", "Show dark frame and pixel distribution"))
        self.showNoisyAndDeadPixelsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to show the \'read noise frame\' and simultaneously create a plot showing the distribution of pixel values in that frame.</p><p>The pixel distribution plot will have a broad middle section. This is the group of pixels that are behaving similarly to their neighbors and are presumably the \'healthy\' pixels.</p><p>The plot has two movable horizontal lines, a green one and a blue one. Use your mouse to \'grab\' the green line and move it up. Then use your mouse to \'grab\' the blue line and drag it down. Position these lines so that they enclose the \'normal\' \'healthy\' pixels. When satisified, click the orange button at the upper left to cause the creation of the dead and too noisy pixel list.</p></body></html>"))
        self.showNoisyAndDeadPixelsButton.setText(_translate("MainWindow", "Show read noise frame and pixel distribution"))
        self.buildPixelCorrectionTabelButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to create the pixel correction table.</p><p>It combines the dark and bright pixels list (if present) with the dead and too noisy pixels list (if present) and eliminates duplicate entries.</p><p>There can be duplicates because a dark pixel can also be a dead pixel because it is stuck at a low value. Because it is \'stuck\', it will have zero noise and so is also a dead pixel.</p><p>Similarly, a bright pixel can also be a too noisy pixel if it is \'sparkling\' at a high intensity. Or it can be a dead pixel if it is simply stuck at a high intensity.</p></body></html>"))
        self.buildPixelCorrectionTabelButton.setText(_translate("MainWindow", "Build pixel correction table"))
        self.savePixelCorrectionTableButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button opens a file save dialog in a predefined default directory.</p><p>It is recommended that you accept this default directory unless there is a very good reason to store pixel correction tables in a different manner.</p><p>Give the file a useful name (no need for an extension) which includes a date and a camera name at the minimum. Adding settings for the camera like gain is likely to be useful as well.</p><p><br/></p><p>Example: Flir-16S2M-gain45-5Dec2021</p><p><br/></p><p>The pixel correction table is a Python object and it is stored as a \'pickled\' file with extension p.</p></body></html>"))
        self.savePixelCorrectionTableButton.setText(_translate("MainWindow", "Save pixel correction table"))
        self.loadPixelCorrectionTableButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button opens a file selection dialog in the directory where pixel correction tables are stored. There will be found the *.p files (Python pickled object files) that have been previously saved.</p></body></html>"))
        self.loadPixelCorrectionTableButton.setText(_translate("MainWindow", "Load pixel correction table"))
        self.applyPixelCorrectionsToCurrentImageButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Apply the current pixel corrections to the currently displayed image.</p><p>When a &quot;finder&quot; image is built and displayed, clicking this button will apply the current pixel corrections to that image.</p><p>Note: building a &quot;finder&quot; image with pixel corrections being applied at each frame read should be used for drift-through videos (non-tracking) even though the &quot;drift&quot; effect automatically reduces the effect of outlaw pixels because they appear over time at different locations in the frame stack and so get averaged out/reduced. But not having such pixels in any frame that gets added to the &quot;finder&quot; stack is a more thorough way of reducing their impact.</p></body></html>"))
        self.applyPixelCorrectionsToCurrentImageButton.setText(_translate("MainWindow", "Apply corrections to current image"))
        self.applyPixelCorrectionsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Check this box if you want pixel corrections to be applied during light-curve extraction or the generation of a &quot;finder&quot; image.</p><p>For most CMOS cameras, this is a safe procedure that will slightly reduce noise in the light-curve.</p><p>If this option is selected, it is recommended that light-curves be extracted both with and without pixel corrections to provide evidence that using pixel corrections during light-curve extraction is justified.</p></body></html>"))
        self.applyPixelCorrectionsCheckBox.setText(_translate("MainWindow", "Apply corrections during frame reads"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_8), _translate("MainWindow", "CMOS tools"))
        self.applyDarkFlatCorrectionsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this box is checked, if there is a set of dark and gain frames (see the <span style=\" font-weight:700; color:#0000ff;\">Dark/Flat</span> tab) that is compatible in shape with the current video file, each pixel in a frame will be corrected so that it\'s light sensing behavior will be more closely matched to that of its neighbors. The correction applied is described by the <span style=\" font-weight:700; color:#0000ff;\">Help</span> button on the <span style=\" font-weight:700; color:#0000ff;\">Dark/Flat</span> tab.</p><p><span style=\" font-weight:700; color:#ff0000;\">Note:</span> Correction should be enabled only when a dark video was recorded either immediately before the event recording (but with enough time for the camera temperature to stabilize) or immediately after the event recording. The issue here is that the black level of a pixel depends on the temperature of the pixel - it is important that pixel temperatures during the dark video is closely matched to the pixel temperaturesduring the event recording.</p></body></html>"))
        self.applyDarkFlatCorrectionsCheckBox.setText(_translate("MainWindow", "Apply corr"))
        self.transportMaxLeft.setToolTip(_translate("MainWindow", "Jump to frame 0"))
        self.transportMaxLeft.setText(_translate("MainWindow", "<<"))
        self.transportBigLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump left 10 seconds (if avi in use) or 200 frames (if FITS file in use).</p></body></html>"))
        self.transportBigLeft.setText(_translate("MainWindow", "- 10 sec"))
        self.transportSmallLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump left 1 second (if avi in use) or 25 frames (if FITS file in use).</p></body></html>"))
        self.transportSmallLeft.setText(_translate("MainWindow", "- 1 sec"))
        self.transportMinusOneFrame.setToolTip(_translate("MainWindow", "<html><head/><body><p>Move left 1 frame</p></body></html>"))
        self.transportMinusOneFrame.setText(_translate("MainWindow", "-1 fr"))
        self.transportPlayLeft.setToolTip(_translate("MainWindow", "<html><head/><body><p>Play the file continuously to the left (earlier in time). No data is recorded during \'play\'. You must click <span style=\" font-weight:600; color:#fc0107;\">analyze</span> in order to have data recorded.</p></body></html>"))
        self.transportPlayLeft.setText(_translate("MainWindow", "<"))
        self.transportAnalyze.setToolTip(_translate("MainWindow", "<html><head/><body><p>Extract light curves using photometry determined on an aperture by aperture basis controlled in large part by aperture naming conventions. Pay attention to the documentation that appears every time an aperture is placed and a name is asked for. In addition, on the <span style=\" font-weight:700; color:#0000ff;\">Help</span> tab, there is a <span style=\" font-weight:700; color:#0000ff;\">Help for image area</span> button that repeats a similar instruction.</p><p>Available photometry extraction methods are: standard aperture photometry with fixed radius circular masks; computed masks that fit a sampling mask to the star image to minimize background pixel inclusion (particularly useful for handling wind-shake); and Naylor Noise Reduction Extraction.</p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">Naylor Noise Reduction Extraction in PyMovie is automatically triggered if there is an aperture that has a name that starts with </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">psf-star</span><span style=\" font-family:\'Arial\',\'sans-serif\';\">.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">Typical steps to take to get the best results from this extraction method are:</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">1) Use the target star if possible. Otherwise, choose a representative star that is fairly bright but not saturated and place a static mask aperture on this star. </span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\';\">2) Name this aperture with a string that starts with: </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">psf-star</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\">3) Set the radius of the circular mask in this aperture to a size that generously encloses the star image. 6.8 has been found to be effective.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\">4) The circular mask radius of any other static mask apertures that contain the string \'psf-star\' in the name must be the same as that used in </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">psf-star</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\">5) Place a static mask aperture on the target star (if it wasn\'t used as the psf-star) using the same circular mask radius used in step 3 and include </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">psf-star</span><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\"> in its name.</span></p><p><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\">6) Click on the </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">analyze</span><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\"> button. That will trigger a determination of the instrumental psf by reading a number of frames (controlled by the psf frame count spin box on the </span><span style=\" font-family:\'Arial\',\'sans-serif\'; font-weight:700; color:#0000ff;\">Median/Misc.</span><span style=\" font-family:\'Arial\',\'sans-serif\'; color:#000000;\"> tab) starting fron the current frame. When this process completes, all aperture data is cleared and analysis proceeds from the original start and end frames specified.</span></p><p><span style=\" font-weight:700;\">============ Background =================</span></p><p>Optimal extraction for imaging photometry was introduced by Tim Naylor in his 1998 paper titled: <span style=\" font-weight:700; color:#ff0000;\">An optimal extraction algorithm for imaging photometry. [Mon. Not. R. Astron. Soc. 296, 339-346 (1998)]</span><span style=\" color:#000000;\">.</span></p><p><span style=\" color:#000000;\">Naylor\'s algorithm utilizes a two-dimensional gaussian as an approximation to the psf of stars in the image and demonstrates that this is an effective approximation in practice. Using this analytic psf, the paper describes how to calculate a weighted mask that lowers the noise in a star intensity measurement by giving a larger weight to those pixel that have a higher SNR and a lower weight to dimmer, noisier pixels - </span><span style=\" font-weight:700; color:#000000;\">this is the core idea in all optimal extraction schemes</span><span style=\" color:#000000;\">.</span></p><p>PyMovie uses the Naylor algorithm in the form that is optimal for sky-limited observations - i.e., dim targets - and can be used for occultations where the target completely disappears.</p><p><br/></p></body></html>"))
        self.transportAnalyze.setText(_translate("MainWindow", "analyze"))
        self.transportPause.setToolTip(_translate("MainWindow", "<html><head/><body><p>Pause an analysis (light curve extraction) that is in progress.</p></body></html>"))
        self.transportPause.setText(_translate("MainWindow", "pause"))
        self.transportPlayRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Play the file to the right (forward in time). No data is recorded during \'play\'. You must click <span style=\" font-weight:600; color:#fc0107;\">analyze</span> in order to have data recorded.</p></body></html>"))
        self.transportPlayRight.setText(_translate("MainWindow", ">"))
        self.transportPlusOneFrame.setToolTip(_translate("MainWindow", "<html><head/><body><p>Move right 1 frame.</p><p>If an analysis was in process but paused by a click on the <span style=\" font-weight:700; color:#0000ff;\">pause</span> button, each click on this button will advance to the next frame AND add that frame\'s data to all of the apertures. This gives the user a way to step through a video frame by frame while data is being extracted for the csv file and give time to observe how the apertures and masks are \'tracking\'.</p></body></html>"))
        self.transportPlusOneFrame.setText(_translate("MainWindow", "+1 fr"))
        self.transportSmallRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump right 1 second (if avi in use) or 25 frames (if FITS file in use).</p></body></html>"))
        self.transportSmallRight.setText(_translate("MainWindow", "+ 1 sec"))
        self.transportBigRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump right 10 seconds (if avi in use) or 200 frames (if FITS file in use).</p></body></html>"))
        self.transportBigRight.setText(_translate("MainWindow", "+ 10 sec"))
        self.transportMaxRight.setToolTip(_translate("MainWindow", "<html><head/><body><p>Jump to last frame.</p><p>In addition, set <span style=\" font-weight:600; color:#fc0107;\">stop frame</span> to the frame number of the last frame.</p></body></html>"))
        self.transportMaxRight.setText(_translate("MainWindow", ">>"))
        self.runPyote.setText(_translate("MainWindow", "auto-run PyOTE"))
        self.transportCsv.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button opens a Save File dialog. Use this dialog to name and, optionally select the directory where you wish the csv file to be written. The default directory is the directory from which the video data was read.</p><p>A set of columns is created for each aperture with the column naming incorporating the aperture name for identification.</p><p>Hopefully you named each aperture in a logical manner. While there is an automatic unique name given to each aperture at creation time, providing user-friendly aperture names will help greatly in identifying the csv file columns.</p><p>Apertures can be renamed at any time without losing any data, so please make use of this feature: it will make consumers of your csv file happy.</p></body></html>"))
        self.transportCsv.setText(_translate("MainWindow", "write csv"))
        self.transportPlot.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button triggers the production of a set of plots that provides a visual summary of the aperture data collected.  Note the <span style=\" font-weight:600; color:#fc0107;\">cascade</span> checkbox that controls whether these plots are done on top of each other (exactly aligned with each other) or spread like a deck of cards (cascased).</p><p>These plots make use of the name that you have assigned to each aperture (you did do that didn\'t you?). While there is an automatic unique name given to each aperture at creation time, providing user-friendly aperture names will help greatly in identifying the plots and is particularly useful in identifying csv file columns.</p><p>Apertures can be renamed at any time without losing any data, so please make use of this feature: it will make consumers of your lightcurves happy.</p><p>A composite plot is produced that contains the lightcurves for all of the apertures on a single plot.</p><p>Then a plot for each individual aperture is produced. This plot has two parts: a large \'signal intensity\' suplot at the top and a smaller \'number of mask pixels\' subplot at the bottom.</p><p>In the individual plots a symbol code is used to indicate when a default mask was used. Instead of a colored circle for signal intensity, a black triangle is used instead to indicate that the mask used in measuring this point\'s intensity was not computed from the image but was instead a \'default\' of some kind.</p></body></html>"))
        self.transportPlot.setText(_translate("MainWindow", "plot"))
        self.transportCurrentFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This box shows the frame number of the currently displayed frame.</p><p>This will be the first frame whose data will be recorded when an analysis is started.</p></body></html>"))
        self.transportCurrentFrameLabel.setText(_translate("MainWindow", " current frame:"))
        self.setLastFrameButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to place the last frame number in the <span style=\" font-weight:700; color:#0000ff;\">stop frame</span> spin box (without moving from the current frame)</p></body></html>"))
        self.setLastFrameButton.setText(_translate("MainWindow", "E"))
        self.transportStopAtFrameLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This box sets the final frame processed during an analysis run (light curve extraction).</p><p>If the<span style=\" font-weight:600; color:#fc0107;\"> stop frame</span> number is greater than the <span style=\" font-weight:600; color:#fc0107;\">cur frame</span> number, analysis proceeds in that direction and the data will include that of the stop frame.</p><p>If the <span style=\" font-weight:600; color:#fc0107;\">stop frame</span> number is less than the <span style=\" font-weight:600; color:#fc0107;\">cur frame</span> number, analysis proceeds backwards (toward earlier time) and stops one frame before the given stop at frame. This is to facilate building a light curve by analyzing both forward and backward in time.</p></body></html>"))
        self.transportStopAtFrameLabel.setText(_translate("MainWindow", ":stop frame"))
        self.transportMark.setToolTip(_translate("MainWindow", "<html><head/><body><p>After a new video is loaded, when the first \'analysis\' run is started, the number and positions of the apertures present at that time are automatically \'remembered\' (\'marked\'). </p><p>This is very helpful if the starfield moves in a substantial way and yet you have a need to start over. A direct jump to the beginning would usually lose tracking and the apertures would need to be repositioned. But PyMovie \'remembers\' the aperture and frame number setup so that with a click on the <span style=\" font-weight:600; color:#fc0107;\">Return to \'mark\'</span> button in the transport button array under the image, you can jump back and start over without the need to reset the aperture positions.</p><p>Because that \'remembering\' is automatic, this will likely be a seldom used button.</p><p>But if there is a need to override the automatic \'mark\', this button is the one to push.</p><p>Note that <span style=\" font-weight:600; color:#fc0107;\">ONLY</span> the aperture count and positions are \'remembered\', not the accumulated data or any other property change that you may have instituted during the run (like a threshold change or change in default mask, etc). Therefore, be sure to click on the <span style=\" font-weight:600; color:#fc0107;\">Clear aperture data</span> button before resuming.</p><p>Note: a \'marked\' position is <span style=\" font-weight:600; color:#fc0107;\">NOT</span> remembered between runs. Use the <span style=\" font-weight:600; color:#fc0107;\">Save aperture group</span> button if it is desired to have an aperture group/constellation be \'sticky\'.</p></body></html>"))
        self.transportMark.setText(_translate("MainWindow", "mark"))
        self.transportReturnToMark.setToolTip(_translate("MainWindow", "<html><head/><body><p>Return to the aperture constellation position present when either the first \'analysis\' was started, or when the <span style=\" font-weight:600; color:#fc0107;\">mark</span> button was clicked (to override the normal automatic position recording).</p><p>The frame number is set as well.</p></body></html>"))
        self.transportReturnToMark.setText(_translate("MainWindow", "Back to \'mark\'"))
        self.transportClearData.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking this button deletes all data that has been accumulated in the apertures. (The apertures are \'objects\' with properties like color, location, threshold, and also hold the recorded data itself).</p><p>This also removes any psf information gathered in support of NRE (Naylor Extraction). That will force a recalculation from the next selected analysis starting point.</p><p>It is often the case that one will \'experiment\' with the video by analyzing short stretches of it.</p><p>All of the data produced while in the \'analyze\' state is accumulated, even when you do it piecemeal. This can cause data points to be recorded multiple times.</p><p>Best practice is, before starting a production run/extraction by setting the starting and stopping frame numbers, clear any previous data.</p></body></html>"))
        self.transportClearData.setText(_translate("MainWindow", "clear data"))
        self.textOutLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Here is the \'decoder\' for the column headings:</p><p>signal = sum of all pixels included in the mask with the background (bkavg) subtracted from each one.</p><p>appsum = sum of all pixels included in the mask </p><p>bkavg = average background, calculated using a Robust Mean estimator with 50% outlier rejection.</p><p>bkstd = standard deviation of the background, calculated using a Robust Scale estimator with 50% outlier rejection (assumes gaussian distribution)</p><p>mskth = Thresh used in forming mask. This value is added to bkavg to compute binary mask</p><p>mskpx = number of pixels in binary mask - if negative, a default mask was used</p><p>cvxhull = convex hull: the area enclosed by a rubber band that surrounds the mask.</p><p>xpos = y position of centroid in image coordinates</p><p>ypos = x position of centroid in image coordinates</p><p>minpx = minimum value pixel contained in the pixels selected by the mask</p><p>maxpx = maximum value pixel contained in the pixels selected by the mask</p></body></html>"))
        self.textOutLabel.setText(_translate("MainWindow", "Right-click here for info"))
        self.thumbOneView.setToolTip(_translate("MainWindow", "thumbnailOne"))
        self.thumbnailOneLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:14pt;\">This panel shows a zoomed version of the image contained within the aperture boundaries.</span></p></body></html>"))
        self.thumbnailOneLabel.setText(_translate("MainWindow", "<html><head/><body><p>Thumbnail One (right-click here for info)</p></body></html>"))
        self.thumbTwoView.setToolTip(_translate("MainWindow", "thumbnailTwo"))
        self.thumbnailTwoLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This image shows the mask that will be applied to the image shown in Thumbnail One.</p><p>A \'dynamic mask\' is calculated by the following steps: </p><p>1) Thumbnail One is blurred using a 5x5 pixel Gaussian.</p><p>2)<span style=\" font-weight:600; color:#fc0107;\"> \'mask threshold above background</span><span style=\" color:#fc0107;\">\'</span> is used to turn the blurred Thumbnail One image into a binary image (only the values 0 and 1 are present) by setting to 0 all pixels that are &lt;= <span style=\" font-weight:600; color:#fc0107;\">\'mask threshold above background</span><span style=\" color:#fc0107;\">\'+ bkavg</span> and setting to 1 all pixels that are greater than <span style=\" font-weight:600; color:#fc0107;\">\'mask threshold above background</span><span style=\" color:#fc0107;\">\'+ bkavg</span>. </p><p>3) The resulting binary image is processed to find all \'blobs\' (connected groups of pixels with value 1).</p><p>4) The signal contained in each blob is computed (with background subtraction).</p><p>5) If a tracking star is present and this is a target star (non-yellow aperture), an additional constraint is enforced: the centroid of the \'blob\' must lie within a 8 pixel radius of the aperture center. This helps suppress any bright stars that may be in the aperture, but not in the center.</p><p>6) The \'blob\' found in step 5 is turned into the mask that is displayed in this thumbnail.</p><p>A static mask (where threshold = 99999) can be an aproximation to a circle or can be a \'tight mask\' computed from a \'finder\' image.</p><p>A static mask can be edited by left-clicking on this thumbnail. The pixel clicked will be toggled - if an image pixel, it turns into a mask pixel - if a mask pixel, it turns back into an image pixel. If you want any such changes to persist, save the aperture group.</p><p>A TME aperture (Tight Mask Extraction) is computed  from the instrumental psf of a \'finder\' image by the \'growth curve method\'. Starting with the brightest pixel, additional pixels (ranked by brightness) are added to the mask until the signal to noise ratio reaches a maximum. This results in a very tight mask with the lowest possible noise level.</p></body></html>"))
        self.thumbnailTwoLabel.setText(_translate("MainWindow", "<html><head/><body><p>Thumbnail Two (right-click here for info)</p></body></html>"))
        self.actionLike_special_settings.setText(_translate("MainWindow", "Like special settings"))
        self.actionOr_preferences.setText(_translate("MainWindow", "Or preferences"))
        self.actionOpen_AVI_SER_file.setText(_translate("MainWindow", "Open AVI/SER file"))
from pyqtgraph import ImageView
